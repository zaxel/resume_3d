var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      var _a2;
      (function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n);
        new MutationObserver((n) => {
          for (const r of n) if (r.type === "childList") for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function e(n) {
          const r = {};
          return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? r.credentials = "include" : n.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function i(n) {
          if (n.ep) return;
          n.ep = true;
          const r = e(n);
          fetch(n.href, r);
        }
      })();
      const Dh = "175", ts = {
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      }, Yr = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      }, Sg = 0, Ud = 1, Cg = 2, ip = 1, np = 2, mn = 3, Cn = 0, yi = 1, Ki = 2, Hn = 0, es = 1, Qd = 2, Od = 3, zd = 4, Ig = 5, hr = 100, Mg = 101, Tg = 102, Rg = 103, Bg = 104, Dg = 200, Pg = 201, Fg = 202, Lg = 203, Tl = 204, Rl = 205, kg = 206, Ng = 207, Ug = 208, Qg = 209, Og = 210, zg = 211, Gg = 212, Hg = 213, Vg = 214, Bl = 0, Dl = 1, Pl = 2, ss = 3, Fl = 4, Ll = 5, kl = 6, Nl = 7, qo = 0, Wg = 1, jg = 2, Vn = 0, qg = 1, Xg = 2, Yg = 3, Kg = 4, Jg = 5, Zg = 6, $g = 7, Gd = "attached", t_ = "detached", rp = 300, gr = 301, as = 302, So = 303, Ul = 304, Xo = 306, ni = 1e3, _i = 1001, Co = 1002, mi = 1003, sp = 1004, Ps = 1005, Re = 1006, mo = 1007, Zi = 1008, Je = 1009, ap = 1010, op = 1011, js = 1012, Ph = 1013, _r = 1014, ii = 1015, Ci = 1016, Fh = 1017, Lh = 1018, qs = 1020, cp = 35902, lp = 1021, hp = 1022, We = 1023, dp = 1024, up = 1025, Xs = 1026, Ys = 1027, xn = 1028, kh = 1029, ur = 1030, Nh = 1031, Uh = 1033, wo = 33776, Ns = 33777, bo = 33778, Us = 33779, Io = 35840, Ql = 35841, Mo = 35842, Ol = 35843, To = 36196, Ro = 37492, Bo = 37496, Ks = 37808, zl = 37809, Gl = 37810, Hl = 37811, Js = 37812, Vl = 37813, Wl = 37814, jl = 37815, ql = 37816, Xl = 37817, Yl = 37818, Kl = 37819, Jl = 37820, Zl = 37821, Qs = 36492, $l = 36494, Do = 36495, fp = 36283, th = 36284, eh = 36285, ih = 36286, Yo = 2200, e_ = 2201, i_ = 2202, Zs = 2300, $s = 2301, _c = 2302, Kr = 2400, Jr = 2401, Po = 2402, Qh = 2500, n_ = 2501, r_ = 0, pp = 1, nh = 2, s_ = 3200, a_ = 3201, Ko = 0, o_ = 1, an = "", ne = "srgb", di = "srgb-linear", Fo = "linear", ge = "srgb", Sr = 7680, Hd = 519, c_ = 512, l_ = 513, h_ = 514, Ap = 515, d_ = 516, u_ = 517, f_ = 518, p_ = 519, rh = 35044, Vd = "300 es", vn = 2e3, Lo = 2001;
      class Xn {
        addEventListener(t, e) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
        }
        hasEventListener(t, e) {
          const i = this._listeners;
          return i === void 0 ? false : i[t] !== void 0 && i[t].indexOf(e) !== -1;
        }
        removeEventListener(t, e) {
          const i = this._listeners;
          if (i === void 0) return;
          const n = i[t];
          if (n !== void 0) {
            const r = n.indexOf(e);
            r !== -1 && n.splice(r, 1);
          }
        }
        dispatchEvent(t) {
          const e = this._listeners;
          if (e === void 0) return;
          const i = e[t.type];
          if (i !== void 0) {
            t.target = this;
            const n = i.slice(0);
            for (let r = 0, a = n.length; r < a; r++) n[r].call(this, t);
            t.target = null;
          }
        }
      }
      const ai = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ];
      let Wd = 1234567;
      const Os = Math.PI / 180, os = 180 / Math.PI;
      function $i() {
        const s = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (ai[s & 255] + ai[s >> 8 & 255] + ai[s >> 16 & 255] + ai[s >> 24 & 255] + "-" + ai[t & 255] + ai[t >> 8 & 255] + "-" + ai[t >> 16 & 15 | 64] + ai[t >> 24 & 255] + "-" + ai[e & 63 | 128] + ai[e >> 8 & 255] + "-" + ai[e >> 16 & 255] + ai[e >> 24 & 255] + ai[i & 255] + ai[i >> 8 & 255] + ai[i >> 16 & 255] + ai[i >> 24 & 255]).toLowerCase();
      }
      function Ht(s, t, e) {
        return Math.max(t, Math.min(e, s));
      }
      function Oh(s, t) {
        return (s % t + t) % t;
      }
      function A_(s, t, e, i, n) {
        return i + (s - t) * (n - i) / (e - t);
      }
      function g_(s, t, e) {
        return s !== t ? (e - s) / (t - s) : 0;
      }
      function zs(s, t, e) {
        return (1 - e) * s + e * t;
      }
      function __(s, t, e, i) {
        return zs(s, t, 1 - Math.exp(-e * i));
      }
      function m_(s, t = 1) {
        return t - Math.abs(Oh(s, t * 2) - t);
      }
      function w_(s, t, e) {
        return s <= t ? 0 : s >= e ? 1 : (s = (s - t) / (e - t), s * s * (3 - 2 * s));
      }
      function b_(s, t, e) {
        return s <= t ? 0 : s >= e ? 1 : (s = (s - t) / (e - t), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function y_(s, t) {
        return s + Math.floor(Math.random() * (t - s + 1));
      }
      function x_(s, t) {
        return s + Math.random() * (t - s);
      }
      function v_(s) {
        return s * (0.5 - Math.random());
      }
      function E_(s) {
        s !== void 0 && (Wd = s);
        let t = Wd += 1831565813;
        return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
      function S_(s) {
        return s * Os;
      }
      function C_(s) {
        return s * os;
      }
      function I_(s) {
        return (s & s - 1) === 0 && s !== 0;
      }
      function M_(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function T_(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function R_(s, t, e, i, n) {
        const r = Math.cos, a = Math.sin, o = r(e / 2), c = a(e / 2), l = r((t + i) / 2), h = a((t + i) / 2), d = r((t - i) / 2), u = a((t - i) / 2), f = r((i - t) / 2), p = a((i - t) / 2);
        switch (n) {
          case "XYX":
            s.set(o * h, c * d, c * u, o * l);
            break;
          case "YZY":
            s.set(c * u, o * h, c * d, o * l);
            break;
          case "ZXZ":
            s.set(c * d, c * u, o * h, o * l);
            break;
          case "XZX":
            s.set(o * h, c * p, c * f, o * l);
            break;
          case "YXY":
            s.set(c * f, o * h, c * p, o * l);
            break;
          case "ZYZ":
            s.set(c * p, c * f, o * h, o * l);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
        }
      }
      function Ji(s, t) {
        switch (t.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return s / 4294967295;
          case Uint16Array:
            return s / 65535;
          case Uint8Array:
            return s / 255;
          case Int32Array:
            return Math.max(s / 2147483647, -1);
          case Int16Array:
            return Math.max(s / 32767, -1);
          case Int8Array:
            return Math.max(s / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function Ae(s, t) {
        switch (t.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return Math.round(s * 4294967295);
          case Uint16Array:
            return Math.round(s * 65535);
          case Uint8Array:
            return Math.round(s * 255);
          case Int32Array:
            return Math.round(s * 2147483647);
          case Int16Array:
            return Math.round(s * 32767);
          case Int8Array:
            return Math.round(s * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const ke = {
        DEG2RAD: Os,
        RAD2DEG: os,
        generateUUID: $i,
        clamp: Ht,
        euclideanModulo: Oh,
        mapLinear: A_,
        inverseLerp: g_,
        lerp: zs,
        damp: __,
        pingpong: m_,
        smoothstep: w_,
        smootherstep: b_,
        randInt: y_,
        randFloat: x_,
        randFloatSpread: v_,
        seededRandom: E_,
        degToRad: S_,
        radToDeg: C_,
        isPowerOfTwo: I_,
        ceilPowerOfTwo: M_,
        floorPowerOfTwo: T_,
        setQuaternionFromProperEuler: R_,
        normalize: Ae,
        denormalize: Ji
      };
      class rt {
        constructor(t = 0, e = 0) {
          rt.prototype.isVector2 = true, this.x = t, this.y = e;
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return this.x = t, this.y = e, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x, i = this.y, n = t.elements;
          return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
        }
        clamp(t, e) {
          return this.x = Ht(this.x, t.x, e.x), this.y = Ht(this.y, t.y, e.y), this;
        }
        clampScalar(t, e) {
          return this.x = Ht(this.x, t, e), this.y = Ht(this.y, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ht(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const i = this.dot(t) / e;
          return Math.acos(Ht(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this;
        }
        rotateAround(t, e) {
          const i = Math.cos(e), n = Math.sin(e), r = this.x - t.x, a = this.y - t.y;
          return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Ot {
        constructor(t, e, i, n, r, a, o, c, l) {
          Ot.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, e, i, n, r, a, o, c, l);
        }
        set(t, e, i, n, r, a, o, c, l) {
          const h = this.elements;
          return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = r, h[5] = c, h[6] = i, h[7] = a, h[8] = l, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements, i = t.elements;
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
        }
        extractBasis(t, e, i) {
          return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements, n = e.elements, r = this.elements, a = i[0], o = i[3], c = i[6], l = i[1], h = i[4], d = i[7], u = i[2], f = i[5], p = i[8], m = n[0], g = n[3], A = n[6], x = n[1], b = n[4], y = n[7], M = n[2], T = n[5], R = n[8];
          return r[0] = a * m + o * x + c * M, r[3] = a * g + o * b + c * T, r[6] = a * A + o * y + c * R, r[1] = l * m + h * x + d * M, r[4] = l * g + h * b + d * T, r[7] = l * A + h * y + d * R, r[2] = u * m + f * x + p * M, r[5] = u * g + f * b + p * T, r[8] = u * A + f * y + p * R, this;
        }
        multiplyScalar(t) {
          const e = this.elements;
          return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
        }
        determinant() {
          const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8];
          return e * a * h - e * o * l - i * r * h + i * o * c + n * r * l - n * a * c;
        }
        invert() {
          const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], d = h * a - o * l, u = o * c - h * r, f = l * r - a * c, p = e * d + i * u + n * f;
          if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m = 1 / p;
          return t[0] = d * m, t[1] = (n * l - h * i) * m, t[2] = (o * i - n * a) * m, t[3] = u * m, t[4] = (h * e - n * c) * m, t[5] = (n * r - o * e) * m, t[6] = f * m, t[7] = (i * c - l * e) * m, t[8] = (a * e - i * r) * m, this;
        }
        transpose() {
          let t;
          const e = this.elements;
          return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
        }
        setUvTransform(t, e, i, n, r, a, o) {
          const c = Math.cos(r), l = Math.sin(r);
          return this.set(i * c, i * l, -i * (c * a + l * o) + a + t, -n * l, n * c, -n * (-l * a + c * o) + o + e, 0, 0, 1), this;
        }
        scale(t, e) {
          return this.premultiply(mc.makeScale(t, e)), this;
        }
        rotate(t) {
          return this.premultiply(mc.makeRotation(-t)), this;
        }
        translate(t, e) {
          return this.premultiply(mc.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
          return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
        }
        makeRotation(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
          return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
          const e = this.elements, i = t.elements;
          for (let n = 0; n < 9; n++) if (e[n] !== i[n]) return false;
          return true;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const mc = new Ot();
      function gp(s) {
        for (let t = s.length - 1; t >= 0; --t) if (s[t] >= 65535) return true;
        return false;
      }
      function ta(s) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", s);
      }
      function B_() {
        const s = ta("canvas");
        return s.style.display = "block", s;
      }
      const jd = {};
      function yo(s) {
        s in jd || (jd[s] = true, console.warn(s));
      }
      function D_(s, t, e) {
        return new Promise(function(i, n) {
          function r() {
            switch (s.clientWaitSync(t, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case s.WAIT_FAILED:
                n();
                break;
              case s.TIMEOUT_EXPIRED:
                setTimeout(r, e);
                break;
              default:
                i();
            }
          }
          setTimeout(r, e);
        });
      }
      function P_(s) {
        const t = s.elements;
        t[2] = 0.5 * t[2] + 0.5 * t[3], t[6] = 0.5 * t[6] + 0.5 * t[7], t[10] = 0.5 * t[10] + 0.5 * t[11], t[14] = 0.5 * t[14] + 0.5 * t[15];
      }
      function F_(s) {
        const t = s.elements;
        t[11] === -1 ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1);
      }
      const qd = new Ot().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), Xd = new Ot().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function L_() {
        const s = {
          enabled: true,
          workingColorSpace: di,
          spaces: {},
          convert: function(n, r, a) {
            return this.enabled === false || r === a || !r || !a || (this.spaces[r].transfer === ge && (n.r = En(n.r), n.g = En(n.g), n.b = En(n.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (n.applyMatrix3(this.spaces[r].toXYZ), n.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ge && (n.r = is(n.r), n.g = is(n.g), n.b = is(n.b))), n;
          },
          fromWorkingColorSpace: function(n, r) {
            return this.convert(n, this.workingColorSpace, r);
          },
          toWorkingColorSpace: function(n, r) {
            return this.convert(n, r, this.workingColorSpace);
          },
          getPrimaries: function(n) {
            return this.spaces[n].primaries;
          },
          getTransfer: function(n) {
            return n === an ? Fo : this.spaces[n].transfer;
          },
          getLuminanceCoefficients: function(n, r = this.workingColorSpace) {
            return n.fromArray(this.spaces[r].luminanceCoefficients);
          },
          define: function(n) {
            Object.assign(this.spaces, n);
          },
          _getMatrix: function(n, r, a) {
            return n.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(n) {
            return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(n = this.workingColorSpace) {
            return this.spaces[n].workingColorSpaceConfig.unpackColorSpace;
          }
        }, t = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], e = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return s.define({
          [di]: {
            primaries: t,
            whitePoint: i,
            transfer: Fo,
            toXYZ: qd,
            fromXYZ: Xd,
            luminanceCoefficients: e,
            workingColorSpaceConfig: {
              unpackColorSpace: ne
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: ne
            }
          },
          [ne]: {
            primaries: t,
            whitePoint: i,
            transfer: ge,
            toXYZ: qd,
            fromXYZ: Xd,
            luminanceCoefficients: e,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: ne
            }
          }
        }), s;
      }
      const zt = L_();
      function En(s) {
        return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function is(s) {
        return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      let Cr;
      class k_ {
        static getDataURL(t, e = "image/png") {
          if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
          let i;
          if (t instanceof HTMLCanvasElement) i = t;
          else {
            Cr === void 0 && (Cr = ta("canvas")), Cr.width = t.width, Cr.height = t.height;
            const n = Cr.getContext("2d");
            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), i = Cr;
          }
          return i.toDataURL(e);
        }
        static sRGBToLinear(t) {
          if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const e = ta("canvas");
            e.width = t.width, e.height = t.height;
            const i = e.getContext("2d");
            i.drawImage(t, 0, 0, t.width, t.height);
            const n = i.getImageData(0, 0, t.width, t.height), r = n.data;
            for (let a = 0; a < r.length; a++) r[a] = En(r[a] / 255) * 255;
            return i.putImageData(n, 0, 0), e;
          } else if (t.data) {
            const e = t.data.slice(0);
            for (let i = 0; i < e.length; i++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(En(e[i] / 255) * 255) : e[i] = En(e[i]);
            return {
              data: e,
              width: t.width,
              height: t.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
        }
      }
      let N_ = 0;
      class zh {
        constructor(t = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: N_++
          }), this.uuid = $i(), this.data = t, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, n = this.data;
          if (n !== null) {
            let r;
            if (Array.isArray(n)) {
              r = [];
              for (let a = 0, o = n.length; a < o; a++) n[a].isDataTexture ? r.push(wc(n[a].image)) : r.push(wc(n[a]));
            } else r = wc(n);
            i.url = r;
          }
          return e || (t.images[this.uuid] = i), i;
        }
      }
      function wc(s) {
        return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? k_.getDataURL(s) : s.data ? {
          data: Array.from(s.data),
          width: s.width,
          height: s.height,
          type: s.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let U_ = 0;
      class Pe extends Xn {
        constructor(t = Pe.DEFAULT_IMAGE, e = Pe.DEFAULT_MAPPING, i = _i, n = _i, r = Re, a = Zi, o = We, c = Je, l = Pe.DEFAULT_ANISOTROPY, h = an) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: U_++
          }), this.uuid = $i(), this.name = "", this.source = new zh(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new rt(0, 0), this.repeat = new rt(1, 1), this.center = new rt(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Ot(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = true, this;
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(t) {
          if (this.mapping !== rp) return t;
          if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case ni:
              t.x = t.x - Math.floor(t.x);
              break;
            case _i:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case Co:
              Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
              break;
          }
          if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case ni:
              t.y = t.y - Math.floor(t.y);
              break;
            case _i:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case Co:
              Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
              break;
          }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          t === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(t) {
          t === true && this.pmremVersion++;
        }
      }
      Pe.DEFAULT_IMAGE = null;
      Pe.DEFAULT_MAPPING = rp;
      Pe.DEFAULT_ANISOTROPY = 1;
      class jt {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          jt.prototype.isVector4 = true, this.x = t, this.y = e, this.z = i, this.w = n;
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, i, n) {
          return this.x = t, this.y = e, this.z = i, this.w = n, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this.w = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setW(t) {
          return this.w = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this.w += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
        }
        applyMatrix4(t) {
          const e = this.x, i = this.y, n = this.z, r = this.w, a = t.elements;
          return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, i, n, r;
          const c = t.elements, l = c[0], h = c[4], d = c[8], u = c[1], f = c[5], p = c[9], m = c[2], g = c[6], A = c[10];
          if (Math.abs(h - u) < 0.01 && Math.abs(d - m) < 0.01 && Math.abs(p - g) < 0.01) {
            if (Math.abs(h + u) < 0.1 && Math.abs(d + m) < 0.1 && Math.abs(p + g) < 0.1 && Math.abs(l + f + A - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const b = (l + 1) / 2, y = (f + 1) / 2, M = (A + 1) / 2, T = (h + u) / 4, R = (d + m) / 4, B = (p + g) / 4;
            return b > y && b > M ? b < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(b), n = T / i, r = R / i) : y > M ? y < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(y), i = T / n, r = B / n) : M < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(M), i = R / r, n = B / r), this.set(i, n, r, e), this;
          }
          let x = Math.sqrt((g - p) * (g - p) + (d - m) * (d - m) + (u - h) * (u - h));
          return Math.abs(x) < 1e-3 && (x = 1), this.x = (g - p) / x, this.y = (d - m) / x, this.z = (u - h) / x, this.w = Math.acos((l + f + A - 1) / 2), this;
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
        }
        clamp(t, e) {
          return this.x = Ht(this.x, t.x, e.x), this.y = Ht(this.y, t.y, e.y), this.z = Ht(this.z, t.z, e.z), this.w = Ht(this.w, t.w, e.w), this;
        }
        clampScalar(t, e) {
          return this.x = Ht(this.x, t, e), this.y = Ht(this.y, t, e), this.z = Ht(this.z, t, e), this.w = Ht(this.w, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ht(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Q_ extends Xn {
        constructor(t = 1, e = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = t, this.height = e, this.depth = 1, this.scissor = new jt(0, 0, t, e), this.scissorTest = false, this.viewport = new jt(0, 0, t, e);
          const n = {
            width: t,
            height: e,
            depth: 1
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: Re,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1
          }, i);
          const r = new Pe(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          r.flipY = false, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
          const a = i.count;
          for (let o = 0; o < a; o++) this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = true, this.textures[o].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = i.depthTexture, this.samples = i.samples;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(t) {
          this.textures[0] = t;
        }
        set depthTexture(t) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(t, e, i = 1) {
          if (this.width !== t || this.height !== e || this.depth !== i) {
            this.width = t, this.height = e, this.depth = i;
            for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = t, this.textures[n].image.height = e, this.textures[n].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
          for (let e = 0, i = t.textures.length; e < i; e++) {
            this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = true, this.textures[e].renderTarget = this;
            const n = Object.assign({}, t.textures[e].image);
            this.textures[e].source = new zh(n);
          }
          return this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class In extends Q_ {
        constructor(t = 1, e = 1, i = {}) {
          super(t, e, i), this.isWebGLRenderTarget = true;
        }
      }
      class _p extends Pe {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
          }, this.magFilter = mi, this.minFilter = mi, this.wrapR = _i, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class mp extends Pe {
        constructor(t = null, e = 1, i = 1, n = 1) {
          super(null), this.isData3DTexture = true, this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
          }, this.magFilter = mi, this.minFilter = mi, this.wrapR = _i, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      let ue = class {
        constructor(t = 0, e = 0, i = 0, n = 1) {
          this.isQuaternion = true, this._x = t, this._y = e, this._z = i, this._w = n;
        }
        static slerpFlat(t, e, i, n, r, a, o) {
          let c = i[n + 0], l = i[n + 1], h = i[n + 2], d = i[n + 3];
          const u = r[a + 0], f = r[a + 1], p = r[a + 2], m = r[a + 3];
          if (o === 0) {
            t[e + 0] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = d;
            return;
          }
          if (o === 1) {
            t[e + 0] = u, t[e + 1] = f, t[e + 2] = p, t[e + 3] = m;
            return;
          }
          if (d !== m || c !== u || l !== f || h !== p) {
            let g = 1 - o;
            const A = c * u + l * f + h * p + d * m, x = A >= 0 ? 1 : -1, b = 1 - A * A;
            if (b > Number.EPSILON) {
              const M = Math.sqrt(b), T = Math.atan2(M, A * x);
              g = Math.sin(g * T) / M, o = Math.sin(o * T) / M;
            }
            const y = o * x;
            if (c = c * g + u * y, l = l * g + f * y, h = h * g + p * y, d = d * g + m * y, g === 1 - o) {
              const M = 1 / Math.sqrt(c * c + l * l + h * h + d * d);
              c *= M, l *= M, h *= M, d *= M;
            }
          }
          t[e] = c, t[e + 1] = l, t[e + 2] = h, t[e + 3] = d;
        }
        static multiplyQuaternionsFlat(t, e, i, n, r, a) {
          const o = i[n], c = i[n + 1], l = i[n + 2], h = i[n + 3], d = r[a], u = r[a + 1], f = r[a + 2], p = r[a + 3];
          return t[e] = o * p + h * d + c * f - l * u, t[e + 1] = c * p + h * u + l * d - o * f, t[e + 2] = l * p + h * f + o * u - c * d, t[e + 3] = h * p - o * d - c * u - l * f, t;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          this._w = t, this._onChangeCallback();
        }
        set(t, e, i, n) {
          return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
        }
        setFromEuler(t, e = true) {
          const i = t._x, n = t._y, r = t._z, a = t._order, o = Math.cos, c = Math.sin, l = o(i / 2), h = o(n / 2), d = o(r / 2), u = c(i / 2), f = c(n / 2), p = c(r / 2);
          switch (a) {
            case "XYZ":
              this._x = u * h * d + l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "YXZ":
              this._x = u * h * d + l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d + u * f * p;
              break;
            case "ZXY":
              this._x = u * h * d - l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "ZYX":
              this._x = u * h * d - l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d + u * f * p;
              break;
            case "YZX":
              this._x = u * h * d + l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "XZY":
              this._x = u * h * d - l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d + u * f * p;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
          }
          return e === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const i = e / 2, n = Math.sin(i);
          return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t) {
          const e = t.elements, i = e[0], n = e[4], r = e[8], a = e[1], o = e[5], c = e[9], l = e[2], h = e[6], d = e[10], u = i + o + d;
          if (u > 0) {
            const f = 0.5 / Math.sqrt(u + 1);
            this._w = 0.25 / f, this._x = (h - c) * f, this._y = (r - l) * f, this._z = (a - n) * f;
          } else if (i > o && i > d) {
            const f = 2 * Math.sqrt(1 + i - o - d);
            this._w = (h - c) / f, this._x = 0.25 * f, this._y = (n + a) / f, this._z = (r + l) / f;
          } else if (o > d) {
            const f = 2 * Math.sqrt(1 + o - i - d);
            this._w = (r - l) / f, this._x = (n + a) / f, this._y = 0.25 * f, this._z = (c + h) / f;
          } else {
            const f = 2 * Math.sqrt(1 + d - i - o);
            this._w = (a - n) / f, this._x = (r + l) / f, this._y = (c + h) / f, this._z = 0.25 * f;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let i = t.dot(e) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(Ht(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const i = this.angleTo(t);
          if (i === 0) return this;
          const n = Math.min(1, e / i);
          return this.slerp(t, n), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t) {
          return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t = this.length();
          return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const i = t._x, n = t._y, r = t._z, a = t._w, o = e._x, c = e._y, l = e._z, h = e._w;
          return this._x = i * h + a * o + n * l - r * c, this._y = n * h + a * c + r * o - i * l, this._z = r * h + a * l + i * c - n * o, this._w = a * h - i * o - n * c - r * l, this._onChangeCallback(), this;
        }
        slerp(t, e) {
          if (e === 0) return this;
          if (e === 1) return this.copy(t);
          const i = this._x, n = this._y, r = this._z, a = this._w;
          let o = a * t._w + i * t._x + n * t._y + r * t._z;
          if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this;
          const c = 1 - o * o;
          if (c <= Number.EPSILON) {
            const f = 1 - e;
            return this._w = f * a + e * this._w, this._x = f * i + e * this._x, this._y = f * n + e * this._y, this._z = f * r + e * this._z, this.normalize(), this;
          }
          const l = Math.sqrt(c), h = Math.atan2(l, o), d = Math.sin((1 - e) * h) / l, u = Math.sin(e * h) / l;
          return this._w = a * d + this._w * u, this._x = i * d + this._x * u, this._y = n * d + this._y * u, this._z = r * d + this._z * u, this._onChangeCallback(), this;
        }
        slerpQuaternions(t, e, i) {
          return this.copy(t).slerp(e, i);
        }
        random() {
          const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i);
          return this.set(n * Math.sin(t), n * Math.cos(t), r * Math.sin(e), r * Math.cos(e));
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
        }
        fromArray(t, e = 0) {
          return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
        }
        fromBufferAttribute(t, e) {
          return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }, I = class wp {
        constructor(t = 0, e = 0, i = 0) {
          wp.prototype.isVector3 = true, this.x = t, this.y = e, this.z = i;
        }
        set(t, e, i) {
          return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this;
        }
        multiplyVectors(t, e) {
          return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
        }
        applyEuler(t) {
          return this.applyQuaternion(Yd.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Yd.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x, i = this.y, n = this.z, r = t.elements;
          return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this;
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x, i = this.y, n = this.z, r = t.elements, a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
          return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a, this;
        }
        applyQuaternion(t) {
          const e = this.x, i = this.y, n = this.z, r = t.x, a = t.y, o = t.z, c = t.w, l = 2 * (a * n - o * i), h = 2 * (o * e - r * n), d = 2 * (r * i - a * e);
          return this.x = e + c * l + a * d - o * h, this.y = i + c * h + o * l - r * d, this.z = n + c * d + r * h - a * l, this;
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
        }
        transformDirection(t) {
          const e = this.x, i = this.y, n = this.z, r = t.elements;
          return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize();
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
        }
        clamp(t, e) {
          return this.x = Ht(this.x, t.x, e.x), this.y = Ht(this.y, t.y, e.y), this.z = Ht(this.z, t.z, e.z), this;
        }
        clampScalar(t, e) {
          return this.x = Ht(this.x, t, e), this.y = Ht(this.y, t, e), this.z = Ht(this.z, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ht(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const i = t.x, n = t.y, r = t.z, a = e.x, o = e.y, c = e.z;
          return this.x = n * c - r * o, this.y = r * a - i * c, this.z = i * o - n * a, this;
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (e === 0) return this.set(0, 0, 0);
          const i = t.dot(this) / e;
          return this.copy(t).multiplyScalar(i);
        }
        projectOnPlane(t) {
          return bc.copy(this).projectOnVector(t), this.sub(bc);
        }
        reflect(t) {
          return this.sub(bc.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const i = this.dot(t) / e;
          return Math.acos(Ht(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
          return e * e + i * i + n * n;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, i) {
          const n = Math.sin(e) * t;
          return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, i) {
          return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return this.x = e[12], this.y = e[13], this.z = e[14], this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length();
          return this.x = e, this.y = i, this.z = n, this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, e * 4);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, e * 3);
        }
        setFromEuler(t) {
          return this.x = t._x, this.y = t._y, this.z = t._z, this;
        }
        setFromColor(t) {
          return this.x = t.r, this.y = t.g, this.z = t.b, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, i = Math.sqrt(1 - e * e);
          return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      };
      const bc = new I(), Yd = new ue();
      class cn {
        constructor(t = new I(1 / 0, 1 / 0, 1 / 0), e = new I(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = t, this.max = e;
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e += 3) this.expandByPoint(Gi.fromArray(t, e));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let e = 0, i = t.count; e < i; e++) this.expandByPoint(Gi.fromBufferAttribute(t, e));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const i = Gi.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        setFromObject(t, e = false) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = false) {
          t.updateWorldMatrix(false, false);
          const i = t.geometry;
          if (i !== void 0) {
            const r = i.getAttribute("position");
            if (e === true && r !== void 0 && t.isInstancedMesh !== true) for (let a = 0, o = r.count; a < o; a++) t.isMesh === true ? t.getVertexPosition(a, Gi) : Gi.fromBufferAttribute(r, a), Gi.applyMatrix4(t.matrixWorld), this.expandByPoint(Gi);
            else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), Ca.copy(t.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Ca.copy(i.boundingBox)), Ca.applyMatrix4(t.matrixWorld), this.union(Ca);
          }
          const n = t.children;
          for (let r = 0, a = n.length; r < a; r++) this.expandByObject(n[r], e);
          return this;
        }
        containsPoint(t) {
          return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
        }
        containsBox(t) {
          return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
        }
        getParameter(t, e) {
          return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t) {
          return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
        }
        intersectsSphere(t) {
          return this.clampPoint(t.center, Gi), Gi.distanceToSquared(t.center) <= t.radius * t.radius;
        }
        intersectsPlane(t) {
          let e, i;
          return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return false;
          this.getCenter(bs), Ia.subVectors(this.max, bs), Ir.subVectors(t.a, bs), Mr.subVectors(t.b, bs), Tr.subVectors(t.c, bs), Dn.subVectors(Mr, Ir), Pn.subVectors(Tr, Mr), Jn.subVectors(Ir, Tr);
          let e = [
            0,
            -Dn.z,
            Dn.y,
            0,
            -Pn.z,
            Pn.y,
            0,
            -Jn.z,
            Jn.y,
            Dn.z,
            0,
            -Dn.x,
            Pn.z,
            0,
            -Pn.x,
            Jn.z,
            0,
            -Jn.x,
            -Dn.y,
            Dn.x,
            0,
            -Pn.y,
            Pn.x,
            0,
            -Jn.y,
            Jn.x,
            0
          ];
          return !yc(e, Ir, Mr, Tr, Ia) || (e = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !yc(e, Ir, Mr, Tr, Ia)) ? false : (Ma.crossVectors(Dn, Pn), e = [
            Ma.x,
            Ma.y,
            Ma.z
          ], yc(e, Ir, Mr, Tr, Ia));
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, Gi).distanceTo(t);
        }
        getBoundingSphere(t) {
          return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(Gi).length() * 0.5), t;
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return this.isEmpty() ? this : (un[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), un[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), un[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), un[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), un[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), un[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), un[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), un[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(un), this);
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      const un = [
        new I(),
        new I(),
        new I(),
        new I(),
        new I(),
        new I(),
        new I(),
        new I()
      ], Gi = new I(), Ca = new cn(), Ir = new I(), Mr = new I(), Tr = new I(), Dn = new I(), Pn = new I(), Jn = new I(), bs = new I(), Ia = new I(), Ma = new I(), Zn = new I();
      function yc(s, t, e, i, n) {
        for (let r = 0, a = s.length - 3; r <= a; r += 3) {
          Zn.fromArray(s, r);
          const o = n.x * Math.abs(Zn.x) + n.y * Math.abs(Zn.y) + n.z * Math.abs(Zn.z), c = t.dot(Zn), l = e.dot(Zn), h = i.dot(Zn);
          if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return false;
        }
        return true;
      }
      const O_ = new cn(), ys = new I(), xc = new I();
      class ln {
        constructor(t = new I(), e = -1) {
          this.isSphere = true, this.center = t, this.radius = e;
        }
        set(t, e) {
          return this.center.copy(t), this.radius = e, this;
        }
        setFromPoints(t, e) {
          const i = this.center;
          e !== void 0 ? i.copy(e) : O_.setFromPoints(t).getCenter(i);
          let n = 0;
          for (let r = 0, a = t.length; r < a; r++) n = Math.max(n, i.distanceToSquared(t[r]));
          return this.radius = Math.sqrt(n), this;
        }
        copy(t) {
          return this.center.copy(t.center), this.radius = t.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const i = this.center.distanceToSquared(t);
          return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
        }
        getBoundingBox(t) {
          return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
        }
        applyMatrix4(t) {
          return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
          ys.subVectors(t, this.center);
          const e = ys.lengthSq();
          if (e > this.radius * this.radius) {
            const i = Math.sqrt(e), n = (i - this.radius) * 0.5;
            this.center.addScaledVector(ys, n / i), this.radius += n;
          }
          return this;
        }
        union(t) {
          return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === true ? this.radius = Math.max(this.radius, t.radius) : (xc.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(ys.copy(t.center).add(xc)), this.expandByPoint(ys.copy(t.center).sub(xc))), this);
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const fn = new I(), vc = new I(), Ta = new I(), Fn = new I(), Ec = new I(), Ra = new I(), Sc = new I();
      let fs = class {
        constructor(t = new I(), e = new I(0, 0, -1)) {
          this.origin = t, this.direction = e;
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
        }
        at(t, e) {
          return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, fn)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const i = e.dot(this.direction);
          return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = fn.subVectors(t, this.origin).dot(this.direction);
          return e < 0 ? this.origin.distanceToSquared(t) : (fn.copy(this.origin).addScaledVector(this.direction, e), fn.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, i, n) {
          vc.copy(t).add(e).multiplyScalar(0.5), Ta.copy(e).sub(t).normalize(), Fn.copy(this.origin).sub(vc);
          const r = t.distanceTo(e) * 0.5, a = -this.direction.dot(Ta), o = Fn.dot(this.direction), c = -Fn.dot(Ta), l = Fn.lengthSq(), h = Math.abs(1 - a * a);
          let d, u, f, p;
          if (h > 0) if (d = a * c - o, u = a * o - c, p = r * h, d >= 0) if (u >= -p) if (u <= p) {
            const m = 1 / h;
            d *= m, u *= m, f = d * (d + a * u + 2 * o) + u * (a * d + u + 2 * c) + l;
          } else u = r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          else u = -r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          else u <= -p ? (d = Math.max(0, -(-a * r + o)), u = d > 0 ? -r : Math.min(Math.max(-r, -c), r), f = -d * d + u * (u + 2 * c) + l) : u <= p ? (d = 0, u = Math.min(Math.max(-r, -c), r), f = u * (u + 2 * c) + l) : (d = Math.max(0, -(a * r + o)), u = d > 0 ? r : Math.min(Math.max(-r, -c), r), f = -d * d + u * (u + 2 * c) + l);
          else u = a > 0 ? -r : r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          return i && i.copy(this.origin).addScaledVector(this.direction, d), n && n.copy(vc).addScaledVector(Ta, u), f;
        }
        intersectSphere(t, e) {
          fn.subVectors(t.center, this.origin);
          const i = fn.dot(this.direction), n = fn.dot(fn) - i * i, r = t.radius * t.radius;
          if (n > r) return null;
          const a = Math.sqrt(r - n), o = i - a, c = i + a;
          return c < 0 ? null : o < 0 ? this.at(c, e) : this.at(o, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(t.normal) + t.constant) / e;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, e) {
          const i = this.distanceToPlane(t);
          return i === null ? null : this.at(i, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return e === 0 || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let i, n, r, a, o, c;
          const l = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, u = this.origin;
          return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, a = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, a = (t.min.y - u.y) * h), i > a || r > n || ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), d >= 0 ? (o = (t.min.z - u.z) * d, c = (t.max.z - u.z) * d) : (o = (t.max.z - u.z) * d, c = (t.min.z - u.z) * d), i > c || o > n) || ((o > i || i !== i) && (i = o), (c < n || n !== n) && (n = c), n < 0) ? null : this.at(i >= 0 ? i : n, e);
        }
        intersectsBox(t) {
          return this.intersectBox(t, fn) !== null;
        }
        intersectTriangle(t, e, i, n, r) {
          Ec.subVectors(e, t), Ra.subVectors(i, t), Sc.crossVectors(Ec, Ra);
          let a = this.direction.dot(Sc), o;
          if (a > 0) {
            if (n) return null;
            o = 1;
          } else if (a < 0) o = -1, a = -a;
          else return null;
          Fn.subVectors(this.origin, t);
          const c = o * this.direction.dot(Ra.crossVectors(Fn, Ra));
          if (c < 0) return null;
          const l = o * this.direction.dot(Ec.cross(Fn));
          if (l < 0 || c + l > a) return null;
          const h = -o * Fn.dot(Sc);
          return h < 0 ? null : this.at(h / a, r);
        }
        applyMatrix4(t) {
          return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
        }
        equals(t) {
          return t.origin.equals(this.origin) && t.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      class ft {
        constructor(t, e, i, n, r, a, o, c, l, h, d, u, f, p, m, g) {
          ft.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, e, i, n, r, a, o, c, l, h, d, u, f, p, m, g);
        }
        set(t, e, i, n, r, a, o, c, l, h, d, u, f, p, m, g) {
          const A = this.elements;
          return A[0] = t, A[4] = e, A[8] = i, A[12] = n, A[1] = r, A[5] = a, A[9] = o, A[13] = c, A[2] = l, A[6] = h, A[10] = d, A[14] = u, A[3] = f, A[7] = p, A[11] = m, A[15] = g, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ft().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements, i = t.elements;
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
        }
        copyPosition(t) {
          const e = this.elements, i = t.elements;
          return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t, e, i) {
          return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t, e, i) {
          return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t) {
          const e = this.elements, i = t.elements, n = 1 / Rr.setFromMatrixColumn(t, 0).length(), r = 1 / Rr.setFromMatrixColumn(t, 1).length(), a = 1 / Rr.setFromMatrixColumn(t, 2).length();
          return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromEuler(t) {
          const e = this.elements, i = t.x, n = t.y, r = t.z, a = Math.cos(i), o = Math.sin(i), c = Math.cos(n), l = Math.sin(n), h = Math.cos(r), d = Math.sin(r);
          if (t.order === "XYZ") {
            const u = a * h, f = a * d, p = o * h, m = o * d;
            e[0] = c * h, e[4] = -c * d, e[8] = l, e[1] = f + p * l, e[5] = u - m * l, e[9] = -o * c, e[2] = m - u * l, e[6] = p + f * l, e[10] = a * c;
          } else if (t.order === "YXZ") {
            const u = c * h, f = c * d, p = l * h, m = l * d;
            e[0] = u + m * o, e[4] = p * o - f, e[8] = a * l, e[1] = a * d, e[5] = a * h, e[9] = -o, e[2] = f * o - p, e[6] = m + u * o, e[10] = a * c;
          } else if (t.order === "ZXY") {
            const u = c * h, f = c * d, p = l * h, m = l * d;
            e[0] = u - m * o, e[4] = -a * d, e[8] = p + f * o, e[1] = f + p * o, e[5] = a * h, e[9] = m - u * o, e[2] = -a * l, e[6] = o, e[10] = a * c;
          } else if (t.order === "ZYX") {
            const u = a * h, f = a * d, p = o * h, m = o * d;
            e[0] = c * h, e[4] = p * l - f, e[8] = u * l + m, e[1] = c * d, e[5] = m * l + u, e[9] = f * l - p, e[2] = -l, e[6] = o * c, e[10] = a * c;
          } else if (t.order === "YZX") {
            const u = a * c, f = a * l, p = o * c, m = o * l;
            e[0] = c * h, e[4] = m - u * d, e[8] = p * d + f, e[1] = d, e[5] = a * h, e[9] = -o * h, e[2] = -l * h, e[6] = f * d + p, e[10] = u - m * d;
          } else if (t.order === "XZY") {
            const u = a * c, f = a * l, p = o * c, m = o * l;
            e[0] = c * h, e[4] = -d, e[8] = l * h, e[1] = u * d + m, e[5] = a * h, e[9] = f * d - p, e[2] = p * d - f, e[6] = o * h, e[10] = m * d + u;
          }
          return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromQuaternion(t) {
          return this.compose(z_, t, G_);
        }
        lookAt(t, e, i) {
          const n = this.elements;
          return vi.subVectors(t, e), vi.lengthSq() === 0 && (vi.z = 1), vi.normalize(), Ln.crossVectors(i, vi), Ln.lengthSq() === 0 && (Math.abs(i.z) === 1 ? vi.x += 1e-4 : vi.z += 1e-4, vi.normalize(), Ln.crossVectors(i, vi)), Ln.normalize(), Ba.crossVectors(vi, Ln), n[0] = Ln.x, n[4] = Ba.x, n[8] = vi.x, n[1] = Ln.y, n[5] = Ba.y, n[9] = vi.y, n[2] = Ln.z, n[6] = Ba.z, n[10] = vi.z, this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements, n = e.elements, r = this.elements, a = i[0], o = i[4], c = i[8], l = i[12], h = i[1], d = i[5], u = i[9], f = i[13], p = i[2], m = i[6], g = i[10], A = i[14], x = i[3], b = i[7], y = i[11], M = i[15], T = n[0], R = n[4], B = n[8], S = n[12], E = n[1], P = n[5], G = n[9], H = n[13], Y = n[2], et = n[6], q = n[10], Z = n[14], W = n[3], st = n[7], dt = n[11], Et = n[15];
          return r[0] = a * T + o * E + c * Y + l * W, r[4] = a * R + o * P + c * et + l * st, r[8] = a * B + o * G + c * q + l * dt, r[12] = a * S + o * H + c * Z + l * Et, r[1] = h * T + d * E + u * Y + f * W, r[5] = h * R + d * P + u * et + f * st, r[9] = h * B + d * G + u * q + f * dt, r[13] = h * S + d * H + u * Z + f * Et, r[2] = p * T + m * E + g * Y + A * W, r[6] = p * R + m * P + g * et + A * st, r[10] = p * B + m * G + g * q + A * dt, r[14] = p * S + m * H + g * Z + A * Et, r[3] = x * T + b * E + y * Y + M * W, r[7] = x * R + b * P + y * et + M * st, r[11] = x * B + b * G + y * q + M * dt, r[15] = x * S + b * H + y * Z + M * Et, this;
        }
        multiplyScalar(t) {
          const e = this.elements;
          return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
        }
        determinant() {
          const t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], a = t[1], o = t[5], c = t[9], l = t[13], h = t[2], d = t[6], u = t[10], f = t[14], p = t[3], m = t[7], g = t[11], A = t[15];
          return p * (+r * c * d - n * l * d - r * o * u + i * l * u + n * o * f - i * c * f) + m * (+e * c * f - e * l * u + r * a * u - n * a * f + n * l * h - r * c * h) + g * (+e * l * d - e * o * f - r * a * d + i * a * f + r * o * h - i * l * h) + A * (-n * o * h - e * c * d + e * o * u + n * a * d - i * a * u + i * c * h);
        }
        transpose() {
          const t = this.elements;
          let e;
          return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
        }
        setPosition(t, e, i) {
          const n = this.elements;
          return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this;
        }
        invert() {
          const t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], a = t[4], o = t[5], c = t[6], l = t[7], h = t[8], d = t[9], u = t[10], f = t[11], p = t[12], m = t[13], g = t[14], A = t[15], x = d * g * l - m * u * l + m * c * f - o * g * f - d * c * A + o * u * A, b = p * u * l - h * g * l - p * c * f + a * g * f + h * c * A - a * u * A, y = h * m * l - p * d * l + p * o * f - a * m * f - h * o * A + a * d * A, M = p * d * c - h * m * c - p * o * u + a * m * u + h * o * g - a * d * g, T = e * x + i * b + n * y + r * M;
          if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const R = 1 / T;
          return t[0] = x * R, t[1] = (m * u * r - d * g * r - m * n * f + i * g * f + d * n * A - i * u * A) * R, t[2] = (o * g * r - m * c * r + m * n * l - i * g * l - o * n * A + i * c * A) * R, t[3] = (d * c * r - o * u * r - d * n * l + i * u * l + o * n * f - i * c * f) * R, t[4] = b * R, t[5] = (h * g * r - p * u * r + p * n * f - e * g * f - h * n * A + e * u * A) * R, t[6] = (p * c * r - a * g * r - p * n * l + e * g * l + a * n * A - e * c * A) * R, t[7] = (a * u * r - h * c * r + h * n * l - e * u * l - a * n * f + e * c * f) * R, t[8] = y * R, t[9] = (p * d * r - h * m * r - p * i * f + e * m * f + h * i * A - e * d * A) * R, t[10] = (a * m * r - p * o * r + p * i * l - e * m * l - a * i * A + e * o * A) * R, t[11] = (h * o * r - a * d * r - h * i * l + e * d * l + a * i * f - e * o * f) * R, t[12] = M * R, t[13] = (h * m * n - p * d * n + p * i * u - e * m * u - h * i * g + e * d * g) * R, t[14] = (p * o * n - a * m * n - p * i * c + e * m * c + a * i * g - e * o * g) * R, t[15] = (a * d * n - h * o * n + h * i * c - e * d * c - a * i * u + e * o * u) * R, this;
        }
        scale(t) {
          const e = this.elements, i = t.x, n = t.y, r = t.z;
          return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this;
        }
        getMaxScaleOnAxis() {
          const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, i, n));
        }
        makeTranslation(t, e, i) {
          return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t, e) {
          const i = Math.cos(e), n = Math.sin(e), r = 1 - i, a = t.x, o = t.y, c = t.z, l = r * a, h = r * o;
          return this.set(l * a + i, l * o - n * c, l * c + n * o, 0, l * o + n * c, h * o + i, h * c - n * a, 0, l * c - n * o, h * c + n * a, r * c * c + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(t, e, i) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, i, n, r, a) {
          return this.set(1, i, r, 0, t, 1, a, 0, e, n, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, i) {
          const n = this.elements, r = e._x, a = e._y, o = e._z, c = e._w, l = r + r, h = a + a, d = o + o, u = r * l, f = r * h, p = r * d, m = a * h, g = a * d, A = o * d, x = c * l, b = c * h, y = c * d, M = i.x, T = i.y, R = i.z;
          return n[0] = (1 - (m + A)) * M, n[1] = (f + y) * M, n[2] = (p - b) * M, n[3] = 0, n[4] = (f - y) * T, n[5] = (1 - (u + A)) * T, n[6] = (g + x) * T, n[7] = 0, n[8] = (p + b) * R, n[9] = (g - x) * R, n[10] = (1 - (u + m)) * R, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this;
        }
        decompose(t, e, i) {
          const n = this.elements;
          let r = Rr.set(n[0], n[1], n[2]).length();
          const a = Rr.set(n[4], n[5], n[6]).length(), o = Rr.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Hi.copy(this);
          const l = 1 / r, h = 1 / a, d = 1 / o;
          return Hi.elements[0] *= l, Hi.elements[1] *= l, Hi.elements[2] *= l, Hi.elements[4] *= h, Hi.elements[5] *= h, Hi.elements[6] *= h, Hi.elements[8] *= d, Hi.elements[9] *= d, Hi.elements[10] *= d, e.setFromRotationMatrix(Hi), i.x = r, i.y = a, i.z = o, this;
        }
        makePerspective(t, e, i, n, r, a, o = vn) {
          const c = this.elements, l = 2 * r / (e - t), h = 2 * r / (i - n), d = (e + t) / (e - t), u = (i + n) / (i - n);
          let f, p;
          if (o === vn) f = -(a + r) / (a - r), p = -2 * a * r / (a - r);
          else if (o === Lo) f = -a / (a - r), p = -a * r / (a - r);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
          return c[0] = l, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = h, c[9] = u, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = p, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
        }
        makeOrthographic(t, e, i, n, r, a, o = vn) {
          const c = this.elements, l = 1 / (e - t), h = 1 / (i - n), d = 1 / (a - r), u = (e + t) * l, f = (i + n) * h;
          let p, m;
          if (o === vn) p = (a + r) * d, m = -2 * d;
          else if (o === Lo) p = r * d, m = -1 * d;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
          return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -u, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = m, c[14] = -p, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
        }
        equals(t) {
          const e = this.elements, i = t.elements;
          for (let n = 0; n < 16; n++) if (e[n] !== i[n]) return false;
          return true;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
        }
      }
      const Rr = new I(), Hi = new ft(), z_ = new I(0, 0, 0), G_ = new I(1, 1, 1), Ln = new I(), Ba = new I(), vi = new I(), Kd = new ft(), Jd = new ue();
      class Oe {
        constructor(t = 0, e = 0, i = 0, n = Oe.DEFAULT_ORDER) {
          this.isEuler = true, this._x = t, this._y = e, this._z = i, this._order = n;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          this._order = t, this._onChangeCallback();
        }
        set(t, e, i, n = this._order) {
          return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t, e = this._order, i = true) {
          const n = t.elements, r = n[0], a = n[4], o = n[8], c = n[1], l = n[5], h = n[9], d = n[2], u = n[6], f = n[10];
          switch (e) {
            case "XYZ":
              this._y = Math.asin(Ht(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, l), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-Ht(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-d, r), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(Ht(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, r));
              break;
            case "ZYX":
              this._y = Math.asin(-Ht(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(u, f), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
              break;
            case "YZX":
              this._z = Math.asin(Ht(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(o, f));
              break;
            case "XZY":
              this._z = Math.asin(-Ht(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
          }
          return this._order = e, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, i) {
          return Kd.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Kd, e, i);
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return Jd.setFromEuler(this), this.setFromQuaternion(Jd, t);
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
        }
        fromArray(t) {
          return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Oe.DEFAULT_ORDER = "XYZ";
      class Gh {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = (1 << t | 0) >>> 0;
        }
        enable(t) {
          this.mask |= 1 << t | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= 1 << t | 0;
        }
        disable(t) {
          this.mask &= ~(1 << t | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return (this.mask & t.mask) !== 0;
        }
        isEnabled(t) {
          return (this.mask & (1 << t | 0)) !== 0;
        }
      }
      let H_ = 0;
      const Zd = new I(), Br = new ue(), pn = new ft(), Da = new I(), xs = new I(), V_ = new I(), W_ = new ue(), $d = new I(1, 0, 0), tu = new I(0, 1, 0), eu = new I(0, 0, 1), iu = {
        type: "added"
      }, j_ = {
        type: "removed"
      }, Dr = {
        type: "childadded",
        child: null
      }, Cc = {
        type: "childremoved",
        child: null
      };
      class ce extends Xn {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: H_++
          }), this.uuid = $i(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ce.DEFAULT_UP.clone();
          const t = new I(), e = new Oe(), i = new ue(), n = new I(1, 1, 1);
          function r() {
            i.setFromEuler(e, false);
          }
          function a() {
            e.setFromQuaternion(i, void 0, false);
          }
          e._onChange(r), i._onChange(a), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: t
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: e
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: n
            },
            modelViewMatrix: {
              value: new ft()
            },
            normalMatrix: {
              value: new Ot()
            }
          }), this.matrix = new ft(), this.matrixWorld = new ft(), this.matrixAutoUpdate = ce.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Gh(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, true);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return Br.setFromAxisAngle(t, e), this.quaternion.multiply(Br), this;
        }
        rotateOnWorldAxis(t, e) {
          return Br.setFromAxisAngle(t, e), this.quaternion.premultiply(Br), this;
        }
        rotateX(t) {
          return this.rotateOnAxis($d, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(tu, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(eu, t);
        }
        translateOnAxis(t, e) {
          return Zd.copy(t).applyQuaternion(this.quaternion), this.position.add(Zd.multiplyScalar(e)), this;
        }
        translateX(t) {
          return this.translateOnAxis($d, t);
        }
        translateY(t) {
          return this.translateOnAxis(tu, t);
        }
        translateZ(t) {
          return this.translateOnAxis(eu, t);
        }
        localToWorld(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4(pn.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, i) {
          t.isVector3 ? Da.copy(t) : Da.set(t, e, i);
          const n = this.parent;
          this.updateWorldMatrix(true, false), xs.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? pn.lookAt(xs, Da, this.up) : pn.lookAt(Da, xs, this.up), this.quaternion.setFromRotationMatrix(pn), n && (pn.extractRotation(n.matrixWorld), Br.setFromRotationMatrix(pn), this.quaternion.premultiply(Br.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(iu), Dr.child = t, this.dispatchEvent(Dr), Dr.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const e = this.children.indexOf(t);
          return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(j_), Cc.child = t, this.dispatchEvent(Cc), Cc.child = null), this;
        }
        removeFromParent() {
          const t = this.parent;
          return t !== null && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return this.updateWorldMatrix(true, false), pn.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), pn.multiply(t.parent.matrixWorld)), t.applyMatrix4(pn), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(false, true), t.dispatchEvent(iu), Dr.child = t, this.dispatchEvent(Dr), Dr.child = null, this;
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let i = 0, n = this.children.length; i < n; i++) {
            const a = this.children[i].getObjectByProperty(t, e);
            if (a !== void 0) return a;
          }
        }
        getObjectsByProperty(t, e, i = []) {
          this[t] === e && i.push(this);
          const n = this.children;
          for (let r = 0, a = n.length; r < a; r++) n[r].getObjectsByProperty(t, e, i);
          return i;
        }
        getWorldPosition(t) {
          return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(xs, t, V_), t;
        }
        getWorldScale(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(xs, W_, t), t;
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(t) {
          t(this);
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
        }
        traverseVisible(t) {
          if (this.visible === false) return;
          t(this);
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          e !== null && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
          const e = this.children;
          for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const i = this.parent;
          if (t === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === true) {
            const n = this.children;
            for (let r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(false, true);
          }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string", i = {};
          e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const n = {};
          n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === true && (n.castShadow = true), this.receiveShadow === true && (n.receiveShadow = true), this.visible === false && (n.visible = false), this.frustumCulled === false && (n.frustumCulled = false), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === false && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((o) => ({
            boxInitialized: o.boxInitialized,
            boxMin: o.box.min.toArray(),
            boxMax: o.box.max.toArray(),
            sphereInitialized: o.sphereInitialized,
            sphereRadius: o.sphere.radius,
            sphereCenter: o.sphere.center.toArray()
          })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius
          }), this.boundingBox !== null && (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray()
          }));
          function r(o, c) {
            return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(t)), c.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (n.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(t.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const c = o.shapes;
              if (Array.isArray(c)) for (let l = 0, h = c.length; l < h; l++) {
                const d = c[l];
                r(t.shapes, d);
              }
              else r(t.shapes, c);
            }
          }
          if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const o = [];
            for (let c = 0, l = this.material.length; c < l; c++) o.push(r(t.materials, this.material[c]));
            n.material = o;
          } else n.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            n.children = [];
            for (let o = 0; o < this.children.length; o++) n.children.push(this.children[o].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const c = this.animations[o];
              n.animations.push(r(t.animations, c));
            }
          }
          if (e) {
            const o = a(t.geometries), c = a(t.materials), l = a(t.textures), h = a(t.images), d = a(t.shapes), u = a(t.skeletons), f = a(t.animations), p = a(t.nodes);
            o.length > 0 && (i.geometries = o), c.length > 0 && (i.materials = c), l.length > 0 && (i.textures = l), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), u.length > 0 && (i.skeletons = u), f.length > 0 && (i.animations = f), p.length > 0 && (i.nodes = p);
          }
          return i.object = n, i;
          function a(o) {
            const c = [];
            for (const l in o) {
              const h = o[l];
              delete h.metadata, c.push(h);
            }
            return c;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = true) {
          if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === true) for (let i = 0; i < t.children.length; i++) {
            const n = t.children[i];
            this.add(n.clone());
          }
          return this;
        }
      }
      ce.DEFAULT_UP = new I(0, 1, 0);
      ce.DEFAULT_MATRIX_AUTO_UPDATE = true;
      ce.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const Vi = new I(), An = new I(), Ic = new I(), gn = new I(), Pr = new I(), Fr = new I(), nu = new I(), Mc = new I(), Tc = new I(), Rc = new I(), Bc = new jt(), Dc = new jt(), Pc = new jt();
      let qr = class Xr {
        constructor(t = new I(), e = new I(), i = new I()) {
          this.a = t, this.b = e, this.c = i;
        }
        static getNormal(t, e, i, n) {
          n.subVectors(i, e), Vi.subVectors(t, e), n.cross(Vi);
          const r = n.lengthSq();
          return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }
        static getBarycoord(t, e, i, n, r) {
          Vi.subVectors(n, e), An.subVectors(i, e), Ic.subVectors(t, e);
          const a = Vi.dot(Vi), o = Vi.dot(An), c = Vi.dot(Ic), l = An.dot(An), h = An.dot(Ic), d = a * l - o * o;
          if (d === 0) return r.set(0, 0, 0), null;
          const u = 1 / d, f = (l * c - o * h) * u, p = (a * h - o * c) * u;
          return r.set(1 - f - p, p, f);
        }
        static containsPoint(t, e, i, n) {
          return this.getBarycoord(t, e, i, n, gn) === null ? false : gn.x >= 0 && gn.y >= 0 && gn.x + gn.y <= 1;
        }
        static getInterpolation(t, e, i, n, r, a, o, c) {
          return this.getBarycoord(t, e, i, n, gn) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, gn.x), c.addScaledVector(a, gn.y), c.addScaledVector(o, gn.z), c);
        }
        static getInterpolatedAttribute(t, e, i, n, r, a) {
          return Bc.setScalar(0), Dc.setScalar(0), Pc.setScalar(0), Bc.fromBufferAttribute(t, e), Dc.fromBufferAttribute(t, i), Pc.fromBufferAttribute(t, n), a.setScalar(0), a.addScaledVector(Bc, r.x), a.addScaledVector(Dc, r.y), a.addScaledVector(Pc, r.z), a;
        }
        static isFrontFacing(t, e, i, n) {
          return Vi.subVectors(i, e), An.subVectors(t, e), Vi.cross(An).dot(n) < 0;
        }
        set(t, e, i) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
        }
        setFromPointsAndIndices(t, e, i, n) {
          return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
        }
        setFromAttributeAndIndices(t, e, i, n) {
          return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return Vi.subVectors(this.c, this.b), An.subVectors(this.a, this.b), Vi.cross(An).length() * 0.5;
        }
        getMidpoint(t) {
          return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return Xr.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return Xr.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getInterpolation(t, e, i, n, r) {
          return Xr.getInterpolation(t, this.a, this.b, this.c, e, i, n, r);
        }
        containsPoint(t) {
          return Xr.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return Xr.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const i = this.a, n = this.b, r = this.c;
          let a, o;
          Pr.subVectors(n, i), Fr.subVectors(r, i), Mc.subVectors(t, i);
          const c = Pr.dot(Mc), l = Fr.dot(Mc);
          if (c <= 0 && l <= 0) return e.copy(i);
          Tc.subVectors(t, n);
          const h = Pr.dot(Tc), d = Fr.dot(Tc);
          if (h >= 0 && d <= h) return e.copy(n);
          const u = c * d - h * l;
          if (u <= 0 && c >= 0 && h <= 0) return a = c / (c - h), e.copy(i).addScaledVector(Pr, a);
          Rc.subVectors(t, r);
          const f = Pr.dot(Rc), p = Fr.dot(Rc);
          if (p >= 0 && f <= p) return e.copy(r);
          const m = f * l - c * p;
          if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(i).addScaledVector(Fr, o);
          const g = h * p - f * d;
          if (g <= 0 && d - h >= 0 && f - p >= 0) return nu.subVectors(r, n), o = (d - h) / (d - h + (f - p)), e.copy(n).addScaledVector(nu, o);
          const A = 1 / (g + m + u);
          return a = m * A, o = u * A, e.copy(i).addScaledVector(Pr, a).addScaledVector(Fr, o);
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      };
      const bp = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, kn = {
        h: 0,
        s: 0,
        l: 0
      }, Pa = {
        h: 0,
        s: 0,
        l: 0
      };
      function Fc(s, t, e) {
        return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? s + (t - s) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? s + (t - s) * 6 * (2 / 3 - e) : s;
      }
      class ht {
        constructor(t, e, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i);
        }
        set(t, e, i) {
          if (e === void 0 && i === void 0) {
            const n = t;
            n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
          } else this.setRGB(t, e, i);
          return this;
        }
        setScalar(t) {
          return this.r = t, this.g = t, this.b = t, this;
        }
        setHex(t, e = ne) {
          return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, zt.toWorkingColorSpace(this, e), this;
        }
        setRGB(t, e, i, n = zt.workingColorSpace) {
          return this.r = t, this.g = e, this.b = i, zt.toWorkingColorSpace(this, n), this;
        }
        setHSL(t, e, i, n = zt.workingColorSpace) {
          if (t = Oh(t, 1), e = Ht(e, 0, 1), i = Ht(i, 0, 1), e === 0) this.r = this.g = this.b = i;
          else {
            const r = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - r;
            this.r = Fc(a, r, t + 1 / 3), this.g = Fc(a, r, t), this.b = Fc(a, r, t - 1 / 3);
          }
          return zt.toWorkingColorSpace(this, n), this;
        }
        setStyle(t, e = ne) {
          function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
          }
          let n;
          if (n = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let r;
            const a = n[1], o = n[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                break;
              case "hsl":
              case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const r = n[1], a = r.length;
            if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, e);
            if (a === 6) return this.setHex(parseInt(r, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, e);
          return this;
        }
        setColorName(t, e = ne) {
          const i = bp[t.toLowerCase()];
          return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return this.r = t.r, this.g = t.g, this.b = t.b, this;
        }
        copySRGBToLinear(t) {
          return this.r = En(t.r), this.g = En(t.g), this.b = En(t.b), this;
        }
        copyLinearToSRGB(t) {
          return this.r = is(t.r), this.g = is(t.g), this.b = is(t.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = ne) {
          return zt.fromWorkingColorSpace(oi.copy(this), t), Math.round(Ht(oi.r * 255, 0, 255)) * 65536 + Math.round(Ht(oi.g * 255, 0, 255)) * 256 + Math.round(Ht(oi.b * 255, 0, 255));
        }
        getHexString(t = ne) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = zt.workingColorSpace) {
          zt.fromWorkingColorSpace(oi.copy(this), e);
          const i = oi.r, n = oi.g, r = oi.b, a = Math.max(i, n, r), o = Math.min(i, n, r);
          let c, l;
          const h = (o + a) / 2;
          if (o === a) c = 0, l = 0;
          else {
            const d = a - o;
            switch (l = h <= 0.5 ? d / (a + o) : d / (2 - a - o), a) {
              case i:
                c = (n - r) / d + (n < r ? 6 : 0);
                break;
              case n:
                c = (r - i) / d + 2;
                break;
              case r:
                c = (i - n) / d + 4;
                break;
            }
            c /= 6;
          }
          return t.h = c, t.s = l, t.l = h, t;
        }
        getRGB(t, e = zt.workingColorSpace) {
          return zt.fromWorkingColorSpace(oi.copy(this), e), t.r = oi.r, t.g = oi.g, t.b = oi.b, t;
        }
        getStyle(t = ne) {
          zt.fromWorkingColorSpace(oi.copy(this), t);
          const e = oi.r, i = oi.g, n = oi.b;
          return t !== ne ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
        }
        offsetHSL(t, e, i) {
          return this.getHSL(kn), this.setHSL(kn.h + t, kn.s + e, kn.l + i);
        }
        add(t) {
          return this.r += t.r, this.g += t.g, this.b += t.b, this;
        }
        addColors(t, e) {
          return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
        }
        addScalar(t) {
          return this.r += t, this.g += t, this.b += t, this;
        }
        sub(t) {
          return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
        }
        multiply(t) {
          return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
        }
        multiplyScalar(t) {
          return this.r *= t, this.g *= t, this.b *= t, this;
        }
        lerp(t, e) {
          return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
        }
        lerpColors(t, e, i) {
          return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this;
        }
        lerpHSL(t, e) {
          this.getHSL(kn), t.getHSL(Pa);
          const i = zs(kn.h, Pa.h, e), n = zs(kn.s, Pa.s, e), r = zs(kn.l, Pa.l, e);
          return this.setHSL(i, n, r), this;
        }
        setFromVector3(t) {
          return this.r = t.x, this.g = t.y, this.b = t.z, this;
        }
        applyMatrix3(t) {
          const e = this.r, i = this.g, n = this.b, r = t.elements;
          return this.r = r[0] * e + r[3] * i + r[6] * n, this.g = r[1] * e + r[4] * i + r[7] * n, this.b = r[2] * e + r[5] * i + r[8] * n, this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
        }
        fromBufferAttribute(t, e) {
          return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const oi = new ht();
      ht.NAMES = bp;
      let q_ = 0;
      class Ii extends Xn {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: q_++
          }), this.uuid = $i(), this.name = "", this.type = "Material", this.blending = es, this.side = Cn, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Tl, this.blendDst = Rl, this.blendEquation = hr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ht(0, 0, 0), this.blendAlpha = 0, this.depthFunc = ss, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Hd, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Sr, this.stencilZFail = Sr, this.stencilZPass = Sr, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.allowOverride = true, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (t !== void 0) for (const e in t) {
            const i = t[e];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
              continue;
            }
            const n = this[e];
            if (n === void 0) {
              console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
              continue;
            }
            n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
          }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          e && (t = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== es && (i.blending = this.blending), this.side !== Cn && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== Tl && (i.blendSrc = this.blendSrc), this.blendDst !== Rl && (i.blendDst = this.blendDst), this.blendEquation !== hr && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== ss && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Hd && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Sr && (i.stencilFail = this.stencilFail), this.stencilZFail !== Sr && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Sr && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function n(r) {
            const a = [];
            for (const o in r) {
              const c = r[o];
              delete c.metadata, a.push(c);
            }
            return a;
          }
          if (e) {
            const r = n(t.textures), a = n(t.images);
            r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
          const e = t.clippingPlanes;
          let i = null;
          if (e !== null) {
            const n = e.length;
            i = new Array(n);
            for (let r = 0; r !== n; ++r) i[r] = e[r].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class on extends Ii {
        constructor(t) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new ht(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Oe(), this.combine = qo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
        }
      }
      const Ue = new I(), Fa = new rt();
      let X_ = 0;
      class ri {
        constructor(t, e, i = false) {
          if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, Object.defineProperty(this, "id", {
            value: X_++
          }), this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i, this.usage = rh, this.updateRanges = [], this.gpuType = ii, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        setUsage(t) {
          return this.usage = t, this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({
            start: t,
            count: e
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
        }
        copyAt(t, e, i) {
          t *= this.itemSize, i *= e.itemSize;
          for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (this.itemSize === 2) for (let e = 0, i = this.count; e < i; e++) Fa.fromBufferAttribute(this, e), Fa.applyMatrix3(t), this.setXY(e, Fa.x, Fa.y);
          else if (this.itemSize === 3) for (let e = 0, i = this.count; e < i; e++) Ue.fromBufferAttribute(this, e), Ue.applyMatrix3(t), this.setXYZ(e, Ue.x, Ue.y, Ue.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.count; e < i; e++) Ue.fromBufferAttribute(this, e), Ue.applyMatrix4(t), this.setXYZ(e, Ue.x, Ue.y, Ue.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++) Ue.fromBufferAttribute(this, e), Ue.applyNormalMatrix(t), this.setXYZ(e, Ue.x, Ue.y, Ue.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++) Ue.fromBufferAttribute(this, e), Ue.transformDirection(t), this.setXYZ(e, Ue.x, Ue.y, Ue.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.itemSize + e];
          return this.normalized && (i = Ji(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return this.normalized && (i = Ae(i, this.array)), this.array[t * this.itemSize + e] = i, this;
        }
        getX(t) {
          let e = this.array[t * this.itemSize];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        setX(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.array[t * this.itemSize] = e, this;
        }
        getY(t) {
          let e = this.array[t * this.itemSize + 1];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        setY(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
        }
        getZ(t) {
          let e = this.array[t * this.itemSize + 2];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        setZ(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
        }
        getW(t) {
          let e = this.array[t * this.itemSize + 3];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        setW(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
        }
        setXY(t, e, i) {
          return t *= this.itemSize, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this;
        }
        setXYZ(t, e, i, n) {
          return t *= this.itemSize, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array), n = Ae(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this;
        }
        setXYZW(t, e, i, n, r) {
          return t *= this.itemSize, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array), n = Ae(n, this.array), r = Ae(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this;
        }
        onUpload(t) {
          return this.onUploadCallback = t, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (t.name = this.name), this.usage !== rh && (t.usage = this.usage), t;
        }
      }
      class Jo extends ri {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i);
        }
      }
      class yp extends ri {
        constructor(t, e, i) {
          super(new Uint32Array(t), e, i);
        }
      }
      class le extends ri {
        constructor(t, e, i) {
          super(new Float32Array(t), e, i);
        }
      }
      let Y_ = 0;
      const Bi = new ft(), Lc = new ce(), Lr = new I(), Ei = new cn(), vs = new cn(), Ye = new I();
      class Fe extends Xn {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: Y_++
          }), this.uuid = $i(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return Array.isArray(t) ? this.index = new (gp(t) ? yp : Jo)(t, 1) : this.index = t, this;
        }
        setIndirect(t) {
          return this.indirect = t, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return this.attributes[t] = e, this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return this.attributes[t] !== void 0;
        }
        addGroup(t, e, i = 0) {
          this.groups.push({
            start: t,
            count: e,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          this.drawRange.start = t, this.drawRange.count = e;
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const r = new Ot().getNormalMatrix(t);
            i.applyNormalMatrix(r), i.needsUpdate = true;
          }
          const n = this.attributes.tangent;
          return n !== void 0 && (n.transformDirection(t), n.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t) {
          return Bi.makeRotationFromQuaternion(t), this.applyMatrix4(Bi), this;
        }
        rotateX(t) {
          return Bi.makeRotationX(t), this.applyMatrix4(Bi), this;
        }
        rotateY(t) {
          return Bi.makeRotationY(t), this.applyMatrix4(Bi), this;
        }
        rotateZ(t) {
          return Bi.makeRotationZ(t), this.applyMatrix4(Bi), this;
        }
        translate(t, e, i) {
          return Bi.makeTranslation(t, e, i), this.applyMatrix4(Bi), this;
        }
        scale(t, e, i) {
          return Bi.makeScale(t, e, i), this.applyMatrix4(Bi), this;
        }
        lookAt(t) {
          return Lc.lookAt(t), Lc.updateMatrix(), this.applyMatrix4(Lc.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(Lr).negate(), this.translate(Lr.x, Lr.y, Lr.z), this;
        }
        setFromPoints(t) {
          const e = this.getAttribute("position");
          if (e === void 0) {
            const i = [];
            for (let n = 0, r = t.length; n < r; n++) {
              const a = t[n];
              i.push(a.x, a.y, a.z || 0);
            }
            this.setAttribute("position", new le(i, 3));
          } else {
            const i = Math.min(t.length, e.count);
            for (let n = 0; n < i; n++) {
              const r = t[n];
              e.setXYZ(n, r.x, r.y, r.z || 0);
            }
            t.length > e.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new cn());
          const t = this.attributes.position, e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new I(-1 / 0, -1 / 0, -1 / 0), new I(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), e) for (let i = 0, n = e.length; i < n; i++) {
              const r = e[i];
              Ei.setFromBufferAttribute(r), this.morphTargetsRelative ? (Ye.addVectors(this.boundingBox.min, Ei.min), this.boundingBox.expandByPoint(Ye), Ye.addVectors(this.boundingBox.max, Ei.max), this.boundingBox.expandByPoint(Ye)) : (this.boundingBox.expandByPoint(Ei.min), this.boundingBox.expandByPoint(Ei.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new ln());
          const t = this.attributes.position, e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new I(), 1 / 0);
            return;
          }
          if (t) {
            const i = this.boundingSphere.center;
            if (Ei.setFromBufferAttribute(t), e) for (let r = 0, a = e.length; r < a; r++) {
              const o = e[r];
              vs.setFromBufferAttribute(o), this.morphTargetsRelative ? (Ye.addVectors(Ei.min, vs.min), Ei.expandByPoint(Ye), Ye.addVectors(Ei.max, vs.max), Ei.expandByPoint(Ye)) : (Ei.expandByPoint(vs.min), Ei.expandByPoint(vs.max));
            }
            Ei.getCenter(i);
            let n = 0;
            for (let r = 0, a = t.count; r < a; r++) Ye.fromBufferAttribute(t, r), n = Math.max(n, i.distanceToSquared(Ye));
            if (e) for (let r = 0, a = e.length; r < a; r++) {
              const o = e[r], c = this.morphTargetsRelative;
              for (let l = 0, h = o.count; l < h; l++) Ye.fromBufferAttribute(o, l), c && (Lr.fromBufferAttribute(t, l), Ye.add(Lr)), n = Math.max(n, i.distanceToSquared(Ye));
            }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const t = this.index, e = this.attributes;
          if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = e.position, n = e.normal, r = e.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new ri(new Float32Array(4 * i.count), 4));
          const a = this.getAttribute("tangent"), o = [], c = [];
          for (let B = 0; B < i.count; B++) o[B] = new I(), c[B] = new I();
          const l = new I(), h = new I(), d = new I(), u = new rt(), f = new rt(), p = new rt(), m = new I(), g = new I();
          function A(B, S, E) {
            l.fromBufferAttribute(i, B), h.fromBufferAttribute(i, S), d.fromBufferAttribute(i, E), u.fromBufferAttribute(r, B), f.fromBufferAttribute(r, S), p.fromBufferAttribute(r, E), h.sub(l), d.sub(l), f.sub(u), p.sub(u);
            const P = 1 / (f.x * p.y - p.x * f.y);
            isFinite(P) && (m.copy(h).multiplyScalar(p.y).addScaledVector(d, -f.y).multiplyScalar(P), g.copy(d).multiplyScalar(f.x).addScaledVector(h, -p.x).multiplyScalar(P), o[B].add(m), o[S].add(m), o[E].add(m), c[B].add(g), c[S].add(g), c[E].add(g));
          }
          let x = this.groups;
          x.length === 0 && (x = [
            {
              start: 0,
              count: t.count
            }
          ]);
          for (let B = 0, S = x.length; B < S; ++B) {
            const E = x[B], P = E.start, G = E.count;
            for (let H = P, Y = P + G; H < Y; H += 3) A(t.getX(H + 0), t.getX(H + 1), t.getX(H + 2));
          }
          const b = new I(), y = new I(), M = new I(), T = new I();
          function R(B) {
            M.fromBufferAttribute(n, B), T.copy(M);
            const S = o[B];
            b.copy(S), b.sub(M.multiplyScalar(M.dot(S))).normalize(), y.crossVectors(T, S);
            const P = y.dot(c[B]) < 0 ? -1 : 1;
            a.setXYZW(B, b.x, b.y, b.z, P);
          }
          for (let B = 0, S = x.length; B < S; ++B) {
            const E = x[B], P = E.start, G = E.count;
            for (let H = P, Y = P + G; H < Y; H += 3) R(t.getX(H + 0)), R(t.getX(H + 1)), R(t.getX(H + 2));
          }
        }
        computeVertexNormals() {
          const t = this.index, e = this.getAttribute("position");
          if (e !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new ri(new Float32Array(e.count * 3), 3), this.setAttribute("normal", i);
            else for (let u = 0, f = i.count; u < f; u++) i.setXYZ(u, 0, 0, 0);
            const n = new I(), r = new I(), a = new I(), o = new I(), c = new I(), l = new I(), h = new I(), d = new I();
            if (t) for (let u = 0, f = t.count; u < f; u += 3) {
              const p = t.getX(u + 0), m = t.getX(u + 1), g = t.getX(u + 2);
              n.fromBufferAttribute(e, p), r.fromBufferAttribute(e, m), a.fromBufferAttribute(e, g), h.subVectors(a, r), d.subVectors(n, r), h.cross(d), o.fromBufferAttribute(i, p), c.fromBufferAttribute(i, m), l.fromBufferAttribute(i, g), o.add(h), c.add(h), l.add(h), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, c.x, c.y, c.z), i.setXYZ(g, l.x, l.y, l.z);
            }
            else for (let u = 0, f = e.count; u < f; u += 3) n.fromBufferAttribute(e, u + 0), r.fromBufferAttribute(e, u + 1), a.fromBufferAttribute(e, u + 2), h.subVectors(a, r), d.subVectors(n, r), h.cross(d), i.setXYZ(u + 0, h.x, h.y, h.z), i.setXYZ(u + 1, h.x, h.y, h.z), i.setXYZ(u + 2, h.x, h.y, h.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, i = t.count; e < i; e++) Ye.fromBufferAttribute(t, e), Ye.normalize(), t.setXYZ(e, Ye.x, Ye.y, Ye.z);
        }
        toNonIndexed() {
          function t(o, c) {
            const l = o.array, h = o.itemSize, d = o.normalized, u = new l.constructor(c.length * h);
            let f = 0, p = 0;
            for (let m = 0, g = c.length; m < g; m++) {
              o.isInterleavedBufferAttribute ? f = c[m] * o.data.stride + o.offset : f = c[m] * h;
              for (let A = 0; A < h; A++) u[p++] = l[f++];
            }
            return new ri(u, h, d);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const e = new Fe(), i = this.index.array, n = this.attributes;
          for (const o in n) {
            const c = n[o], l = t(c, i);
            e.setAttribute(o, l);
          }
          const r = this.morphAttributes;
          for (const o in r) {
            const c = [], l = r[o];
            for (let h = 0, d = l.length; h < d; h++) {
              const u = l[h], f = t(u, i);
              c.push(f);
            }
            e.morphAttributes[o] = c;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let o = 0, c = a.length; o < c; o++) {
            const l = a[o];
            e.addGroup(l.start, l.count, l.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const c = this.parameters;
            for (const l in c) c[l] !== void 0 && (t[l] = c[l]);
            return t;
          }
          t.data = {
            attributes: {}
          };
          const e = this.index;
          e !== null && (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array)
          });
          const i = this.attributes;
          for (const c in i) {
            const l = i[c];
            t.data.attributes[c] = l.toJSON(t.data);
          }
          const n = {};
          let r = false;
          for (const c in this.morphAttributes) {
            const l = this.morphAttributes[c], h = [];
            for (let d = 0, u = l.length; d < u; d++) {
              const f = l[d];
              h.push(f.toJSON(t.data));
            }
            h.length > 0 && (n[c] = h, r = true);
          }
          r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
          const a = this.groups;
          a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return o !== null && (t.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
          }), t;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const e = {};
          this.name = t.name;
          const i = t.index;
          i !== null && this.setIndex(i.clone());
          const n = t.attributes;
          for (const l in n) {
            const h = n[l];
            this.setAttribute(l, h.clone(e));
          }
          const r = t.morphAttributes;
          for (const l in r) {
            const h = [], d = r[l];
            for (let u = 0, f = d.length; u < f; u++) h.push(d[u].clone(e));
            this.morphAttributes[l] = h;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const a = t.groups;
          for (let l = 0, h = a.length; l < h; l++) {
            const d = a[l];
            this.addGroup(d.start, d.count, d.materialIndex);
          }
          const o = t.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const c = t.boundingSphere;
          return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const ru = new ft(), $n = new fs(), La = new ln(), su = new I(), ka = new I(), Na = new I(), Ua = new I(), kc = new I(), Qa = new I(), au = new I(), Oa = new I();
      class me extends ce {
        constructor(t = new Fe(), e = new on()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
          return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const n = e[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
        getVertexPosition(t, e) {
          const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, a = i.morphTargetsRelative;
          e.fromBufferAttribute(n, t);
          const o = this.morphTargetInfluences;
          if (r && o) {
            Qa.set(0, 0, 0);
            for (let c = 0, l = r.length; c < l; c++) {
              const h = o[c], d = r[c];
              h !== 0 && (kc.fromBufferAttribute(d, t), a ? Qa.addScaledVector(kc, h) : Qa.addScaledVector(kc.sub(e), h));
            }
            e.add(Qa);
          }
          return e;
        }
        raycast(t, e) {
          const i = this.geometry, n = this.material, r = this.matrixWorld;
          n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), La.copy(i.boundingSphere), La.applyMatrix4(r), $n.copy(t.ray).recast(t.near), !(La.containsPoint($n.origin) === false && ($n.intersectSphere(La, su) === null || $n.origin.distanceToSquared(su) > (t.far - t.near) ** 2)) && (ru.copy(r).invert(), $n.copy(t.ray).applyMatrix4(ru), !(i.boundingBox !== null && $n.intersectsBox(i.boundingBox) === false) && this._computeIntersections(t, e, $n)));
        }
        _computeIntersections(t, e, i) {
          let n;
          const r = this.geometry, a = this.material, o = r.index, c = r.attributes.position, l = r.attributes.uv, h = r.attributes.uv1, d = r.attributes.normal, u = r.groups, f = r.drawRange;
          if (o !== null) if (Array.isArray(a)) for (let p = 0, m = u.length; p < m; p++) {
            const g = u[p], A = a[g.materialIndex], x = Math.max(g.start, f.start), b = Math.min(o.count, Math.min(g.start + g.count, f.start + f.count));
            for (let y = x, M = b; y < M; y += 3) {
              const T = o.getX(y), R = o.getX(y + 1), B = o.getX(y + 2);
              n = za(this, A, t, i, l, h, d, T, R, B), n && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = g.materialIndex, e.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), m = Math.min(o.count, f.start + f.count);
            for (let g = p, A = m; g < A; g += 3) {
              const x = o.getX(g), b = o.getX(g + 1), y = o.getX(g + 2);
              n = za(this, a, t, i, l, h, d, x, b, y), n && (n.faceIndex = Math.floor(g / 3), e.push(n));
            }
          }
          else if (c !== void 0) if (Array.isArray(a)) for (let p = 0, m = u.length; p < m; p++) {
            const g = u[p], A = a[g.materialIndex], x = Math.max(g.start, f.start), b = Math.min(c.count, Math.min(g.start + g.count, f.start + f.count));
            for (let y = x, M = b; y < M; y += 3) {
              const T = y, R = y + 1, B = y + 2;
              n = za(this, A, t, i, l, h, d, T, R, B), n && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = g.materialIndex, e.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), m = Math.min(c.count, f.start + f.count);
            for (let g = p, A = m; g < A; g += 3) {
              const x = g, b = g + 1, y = g + 2;
              n = za(this, a, t, i, l, h, d, x, b, y), n && (n.faceIndex = Math.floor(g / 3), e.push(n));
            }
          }
        }
      }
      function K_(s, t, e, i, n, r, a, o) {
        let c;
        if (t.side === yi ? c = i.intersectTriangle(a, r, n, true, o) : c = i.intersectTriangle(n, r, a, t.side === Cn, o), c === null) return null;
        Oa.copy(o), Oa.applyMatrix4(s.matrixWorld);
        const l = e.ray.origin.distanceTo(Oa);
        return l < e.near || l > e.far ? null : {
          distance: l,
          point: Oa.clone(),
          object: s
        };
      }
      function za(s, t, e, i, n, r, a, o, c, l) {
        s.getVertexPosition(o, ka), s.getVertexPosition(c, Na), s.getVertexPosition(l, Ua);
        const h = K_(s, t, e, i, ka, Na, Ua, au);
        if (h) {
          const d = new I();
          qr.getBarycoord(au, ka, Na, Ua, d), n && (h.uv = qr.getInterpolatedAttribute(n, o, c, l, d, new rt())), r && (h.uv1 = qr.getInterpolatedAttribute(r, o, c, l, d, new rt())), a && (h.normal = qr.getInterpolatedAttribute(a, o, c, l, d, new I()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
          const u = {
            a: o,
            b: c,
            c: l,
            normal: new I(),
            materialIndex: 0
          };
          qr.getNormal(ka, Na, Ua, u.normal), h.face = u, h.barycoord = d;
        }
        return h;
      }
      class ps extends Fe {
        constructor(t = 1, e = 1, i = 1, n = 1, r = 1, a = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
          };
          const o = this;
          n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
          const c = [], l = [], h = [], d = [];
          let u = 0, f = 0;
          p("z", "y", "x", -1, -1, i, e, t, a, r, 0), p("z", "y", "x", 1, -1, i, e, -t, a, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, a, 2), p("x", "z", "y", 1, -1, t, i, -e, n, a, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(c), this.setAttribute("position", new le(l, 3)), this.setAttribute("normal", new le(h, 3)), this.setAttribute("uv", new le(d, 2));
          function p(m, g, A, x, b, y, M, T, R, B, S) {
            const E = y / R, P = M / B, G = y / 2, H = M / 2, Y = T / 2, et = R + 1, q = B + 1;
            let Z = 0, W = 0;
            const st = new I();
            for (let dt = 0; dt < q; dt++) {
              const Et = dt * P - H;
              for (let Pt = 0; Pt < et; Pt++) {
                const Vt = Pt * E - G;
                st[m] = Vt * x, st[g] = Et * b, st[A] = Y, l.push(st.x, st.y, st.z), st[m] = 0, st[g] = 0, st[A] = T > 0 ? 1 : -1, h.push(st.x, st.y, st.z), d.push(Pt / R), d.push(1 - dt / B), Z += 1;
              }
            }
            for (let dt = 0; dt < B; dt++) for (let Et = 0; Et < R; Et++) {
              const Pt = u + Et + et * dt, Vt = u + Et + et * (dt + 1), K = u + (Et + 1) + et * (dt + 1), ot = u + (Et + 1) + et * dt;
              c.push(Pt, Vt, ot), c.push(Vt, K, ot), W += 6;
            }
            o.addGroup(f, W, S), f += W, u += Z;
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new ps(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
        }
      }
      function cs(s) {
        const t = {};
        for (const e in s) {
          t[e] = {};
          for (const i in s[e]) {
            const n = s[e][i];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][i] = null) : t[e][i] = n.clone() : Array.isArray(n) ? t[e][i] = n.slice() : t[e][i] = n;
          }
        }
        return t;
      }
      function Ai(s) {
        const t = {};
        for (let e = 0; e < s.length; e++) {
          const i = cs(s[e]);
          for (const n in i) t[n] = i[n];
        }
        return t;
      }
      function J_(s) {
        const t = [];
        for (let e = 0; e < s.length; e++) t.push(s[e].clone());
        return t;
      }
      function xp(s) {
        const t = s.getRenderTarget();
        return t === null ? s.outputColorSpace : t.isXRRenderTarget === true ? t.texture.colorSpace : zt.workingColorSpace;
      }
      const Zo = {
        clone: cs,
        merge: Ai
      };
      var Z_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, $_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class Ni extends Ii {
        constructor(t) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Z_, this.fragmentShader = $_, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = cs(t.uniforms), this.uniformsGroups = J_(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          e.glslVersion = this.glslVersion, e.uniforms = {};
          for (const n in this.uniforms) {
            const a = this.uniforms[n].value;
            a && a.isTexture ? e.uniforms[n] = {
              type: "t",
              value: a.toJSON(t).uuid
            } : a && a.isColor ? e.uniforms[n] = {
              type: "c",
              value: a.getHex()
            } : a && a.isVector2 ? e.uniforms[n] = {
              type: "v2",
              value: a.toArray()
            } : a && a.isVector3 ? e.uniforms[n] = {
              type: "v3",
              value: a.toArray()
            } : a && a.isVector4 ? e.uniforms[n] = {
              type: "v4",
              value: a.toArray()
            } : a && a.isMatrix3 ? e.uniforms[n] = {
              type: "m3",
              value: a.toArray()
            } : a && a.isMatrix4 ? e.uniforms[n] = {
              type: "m4",
              value: a.toArray()
            } : e.uniforms[n] = {
              value: a
            };
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
          const i = {};
          for (const n in this.extensions) this.extensions[n] === true && (i[n] = true);
          return Object.keys(i).length > 0 && (e.extensions = i), e;
        }
      }
      class ko extends ce {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new ft(), this.projectionMatrix = new ft(), this.projectionMatrixInverse = new ft(), this.coordinateSystem = vn;
        }
        copy(t, e) {
          return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Nn = new I(), ou = new rt(), cu = new rt();
      class Ve extends ko {
        constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t, e) {
          return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
        }
        setFocalLength(t) {
          const e = 0.5 * this.getFilmHeight() / t;
          this.fov = os * 2 * Math.atan(e), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(Os * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / t;
        }
        getEffectiveFOV() {
          return os * 2 * Math.atan(Math.tan(Os * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, e, i) {
          Nn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(Nn.x, Nn.y).multiplyScalar(-t / Nn.z), Nn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Nn.x, Nn.y).multiplyScalar(-t / Nn.z);
        }
        getViewSize(t, e) {
          return this.getViewBounds(t, ou, cu), e.subVectors(cu, ou);
        }
        setViewOffset(t, e, i, n, r, a) {
          this.aspect = t / e, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = t * Math.tan(Os * 0.5 * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, r = -0.5 * n;
          const a = this.view;
          if (this.view !== null && this.view.enabled) {
            const c = a.fullWidth, l = a.fullHeight;
            r += a.offsetX * n / c, e -= a.offsetY * i / l, n *= a.width / c, i *= a.height / l;
          }
          const o = this.filmOffset;
          o !== 0 && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
        }
      }
      const kr = -90, Nr = 1;
      class tm extends ce {
        constructor(t, e, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const n = new Ve(kr, Nr, t, e);
          n.layers = this.layers, this.add(n);
          const r = new Ve(kr, Nr, t, e);
          r.layers = this.layers, this.add(r);
          const a = new Ve(kr, Nr, t, e);
          a.layers = this.layers, this.add(a);
          const o = new Ve(kr, Nr, t, e);
          o.layers = this.layers, this.add(o);
          const c = new Ve(kr, Nr, t, e);
          c.layers = this.layers, this.add(c);
          const l = new Ve(kr, Nr, t, e);
          l.layers = this.layers, this.add(l);
        }
        updateCoordinateSystem() {
          const t = this.coordinateSystem, e = this.children.concat(), [i, n, r, a, o, c] = e;
          for (const l of e) this.remove(l);
          if (t === vn) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
          else if (t === Lo) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
          for (const l of e) this.add(l), l.updateMatrixWorld();
        }
        update(t, e) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: n } = this;
          this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
          const [r, a, o, c, l, h] = this.children, d = t.getRenderTarget(), u = t.getActiveCubeFace(), f = t.getActiveMipmapLevel(), p = t.xr.enabled;
          t.xr.enabled = false;
          const m = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, t.setRenderTarget(i, 0, n), t.render(e, r), t.setRenderTarget(i, 1, n), t.render(e, a), t.setRenderTarget(i, 2, n), t.render(e, o), t.setRenderTarget(i, 3, n), t.render(e, c), t.setRenderTarget(i, 4, n), t.render(e, l), i.texture.generateMipmaps = m, t.setRenderTarget(i, 5, n), t.render(e, h), t.setRenderTarget(d, u, f), t.xr.enabled = p, i.texture.needsPMREMUpdate = true;
        }
      }
      class Hh extends Pe {
        constructor(t = [], e = gr, i, n, r, a, o, c, l, h) {
          super(t, e, i, n, r, a, o, c, l, h), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      class em extends In {
        constructor(t = 1, e = {}) {
          super(t, t, e), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: t,
            height: t,
            depth: 1
          }, n = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new Hh(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : false, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Re;
        }
        fromEquirectangularTexture(t, e) {
          this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, n = new ps(5, 5, 5), r = new Ni({
            name: "CubemapFromEquirect",
            uniforms: cs(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: yi,
            blending: Hn
          });
          r.uniforms.tEquirect.value = e;
          const a = new me(n, r), o = e.minFilter;
          return e.minFilter === Zi && (e.minFilter = Re), new tm(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(t, e = true, i = true, n = true) {
          const r = t.getRenderTarget();
          for (let a = 0; a < 6; a++) t.setRenderTarget(this, a), t.clear(e, i, n);
          t.setRenderTarget(r);
        }
      }
      class ki extends ce {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      const im = {
        type: "move"
      };
      class Nc {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return this._hand === null && (this._hand = new ki(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
            pinching: false
          }), this._hand;
        }
        getTargetRaySpace() {
          return this._targetRay === null && (this._targetRay = new ki(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new I(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new I()), this._targetRay;
        }
        getGripSpace() {
          return this._grip === null && (this._grip = new ki(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new I(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new I()), this._grip;
        }
        dispatchEvent(t) {
          return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
        }
        connect(t) {
          if (t && t.hand) {
            const e = this._hand;
            if (e) for (const i of t.hand.values()) this._getHandJoint(e, i);
          }
          return this.dispatchEvent({
            type: "connected",
            data: t
          }), this;
        }
        disconnect(t) {
          return this.dispatchEvent({
            type: "disconnected",
            data: t
          }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
        }
        update(t, e, i) {
          let n = null, r = null, a = null;
          const o = this._targetRay, c = this._grip, l = this._hand;
          if (t && e.session.visibilityState !== "visible-blurred") {
            if (l && t.hand) {
              a = true;
              for (const m of t.hand.values()) {
                const g = e.getJointPose(m, i), A = this._getHandJoint(l, m);
                g !== null && (A.matrix.fromArray(g.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.matrixWorldNeedsUpdate = true, A.jointRadius = g.radius), A.visible = g !== null;
              }
              const h = l.joints["index-finger-tip"], d = l.joints["thumb-tip"], u = h.position.distanceTo(d.position), f = 0.02, p = 5e-3;
              l.inputState.pinching && u > f + p ? (l.inputState.pinching = false, this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this
              })) : !l.inputState.pinching && u <= f - p && (l.inputState.pinching = true, this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this
              }));
            } else c !== null && t.gripSpace && (r = e.getPose(t.gripSpace, i), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = true, r.linearVelocity ? (c.hasLinearVelocity = true, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = false, r.angularVelocity ? (c.hasAngularVelocity = true, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = false));
            o !== null && (n = e.getPose(t.targetRaySpace, i), n === null && r !== null && (n = r), n !== null && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, n.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = false, n.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(im)));
          }
          return o !== null && (o.visible = n !== null), c !== null && (c.visible = r !== null), l !== null && (l.visible = a !== null), this;
        }
        _getHandJoint(t, e) {
          if (t.joints[e.jointName] === void 0) {
            const i = new ki();
            i.matrixAutoUpdate = false, i.visible = false, t.joints[e.jointName] = i, t.add(i);
          }
          return t.joints[e.jointName];
        }
      }
      class Vh {
        constructor(t, e = 25e-5) {
          this.isFogExp2 = true, this.name = "", this.color = new ht(t), this.density = e;
        }
        clone() {
          return new Vh(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
          };
        }
      }
      class xo extends ce {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Oe(), this.environmentIntensity = 1, this.environmentRotation = new Oe(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(t, e) {
          return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
        }
      }
      class vp {
        constructor(t, e) {
          this.isInterleavedBuffer = true, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = rh, this.updateRanges = [], this.version = 0, this.uuid = $i();
        }
        onUploadCallback() {
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        setUsage(t) {
          return this.usage = t, this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({
            start: t,
            count: e
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
        }
        copyAt(t, e, i) {
          t *= this.stride, i *= e.stride;
          for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $i()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(t) {
          return this.onUploadCallback = t, this;
        }
        toJSON(t) {
          return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $i()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const fi = new I();
      class ea {
        constructor(t, e, i, n = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = n;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.data.count; e < i; e++) fi.fromBufferAttribute(this, e), fi.applyMatrix4(t), this.setXYZ(e, fi.x, fi.y, fi.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++) fi.fromBufferAttribute(this, e), fi.applyNormalMatrix(t), this.setXYZ(e, fi.x, fi.y, fi.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++) fi.fromBufferAttribute(this, e), fi.transformDirection(t), this.setXYZ(e, fi.x, fi.y, fi.z);
          return this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.data.stride + this.offset + e];
          return this.normalized && (i = Ji(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return this.normalized && (i = Ae(i, this.array)), this.data.array[t * this.data.stride + this.offset + e] = i, this;
        }
        setX(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
        }
        setY(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
        }
        setZ(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
        }
        setW(t, e) {
          return this.normalized && (e = Ae(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
        }
        getX(t) {
          let e = this.data.array[t * this.data.stride + this.offset];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        getY(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 1];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        getZ(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 2];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        getW(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 3];
          return this.normalized && (e = Ji(e, this.array)), e;
        }
        setXY(t, e, i) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
        }
        setXYZ(t, e, i, n) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array), n = Ae(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this;
        }
        setXYZW(t, e, i, n, r) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = Ae(e, this.array), i = Ae(i, this.array), n = Ae(n, this.array), r = Ae(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this;
        }
        clone(t) {
          if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
            }
            return new ri(new this.array.constructor(e), this.itemSize, this.normalized);
          } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ea(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(t) {
          if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[n + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: e,
              normalized: this.normalized
            };
          } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      class Ep extends Ii {
        constructor(t) {
          super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new ht(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
        }
      }
      let Ur;
      const Es = new I(), Qr = new I(), Or = new I(), zr = new rt(), Ss = new rt(), Sp = new ft(), Ga = new I(), Cs = new I(), Ha = new I(), lu = new rt(), Uc = new rt(), hu = new rt();
      class nm extends ce {
        constructor(t = new Ep()) {
          if (super(), this.isSprite = true, this.type = "Sprite", Ur === void 0) {
            Ur = new Fe();
            const e = new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1
            ]), i = new vp(e, 5);
            Ur.setIndex([
              0,
              1,
              2,
              0,
              2,
              3
            ]), Ur.setAttribute("position", new ea(i, 3, 0, false)), Ur.setAttribute("uv", new ea(i, 2, 3, false));
          }
          this.geometry = Ur, this.material = t, this.center = new rt(0.5, 0.5);
        }
        raycast(t, e) {
          t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Qr.setFromMatrixScale(this.matrixWorld), Sp.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Or.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && Qr.multiplyScalar(-Or.z);
          const i = this.material.rotation;
          let n, r;
          i !== 0 && (r = Math.cos(i), n = Math.sin(i));
          const a = this.center;
          Va(Ga.set(-0.5, -0.5, 0), Or, a, Qr, n, r), Va(Cs.set(0.5, -0.5, 0), Or, a, Qr, n, r), Va(Ha.set(0.5, 0.5, 0), Or, a, Qr, n, r), lu.set(0, 0), Uc.set(1, 0), hu.set(1, 1);
          let o = t.ray.intersectTriangle(Ga, Cs, Ha, false, Es);
          if (o === null && (Va(Cs.set(-0.5, 0.5, 0), Or, a, Qr, n, r), Uc.set(0, 1), o = t.ray.intersectTriangle(Ga, Ha, Cs, false, Es), o === null)) return;
          const c = t.ray.origin.distanceTo(Es);
          c < t.near || c > t.far || e.push({
            distance: c,
            point: Es.clone(),
            uv: qr.getInterpolation(Es, Ga, Cs, Ha, lu, Uc, hu, new rt()),
            face: null,
            object: this
          });
        }
        copy(t, e) {
          return super.copy(t, e), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
        }
      }
      function Va(s, t, e, i, n, r) {
        zr.subVectors(s, e).addScalar(0.5).multiply(i), n !== void 0 ? (Ss.x = r * zr.x - n * zr.y, Ss.y = n * zr.x + r * zr.y) : Ss.copy(zr), s.copy(t), s.x += Ss.x, s.y += Ss.y, s.applyMatrix4(Sp);
      }
      const du = new I(), uu = new jt(), fu = new jt(), rm = new I(), pu = new ft(), Wa = new I(), Qc = new ln(), Au = new ft(), Oc = new fs();
      class Wh extends me {
        constructor(t, e) {
          super(t, e), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Gd, this.bindMatrix = new ft(), this.bindMatrixInverse = new ft(), this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
          const t = this.geometry;
          this.boundingBox === null && (this.boundingBox = new cn()), this.boundingBox.makeEmpty();
          const e = t.getAttribute("position");
          for (let i = 0; i < e.count; i++) this.getVertexPosition(i, Wa), this.boundingBox.expandByPoint(Wa);
        }
        computeBoundingSphere() {
          const t = this.geometry;
          this.boundingSphere === null && (this.boundingSphere = new ln()), this.boundingSphere.makeEmpty();
          const e = t.getAttribute("position");
          for (let i = 0; i < e.count; i++) this.getVertexPosition(i, Wa), this.boundingSphere.expandByPoint(Wa);
        }
        copy(t, e) {
          return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
        }
        raycast(t, e) {
          const i = this.material, n = this.matrixWorld;
          i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Qc.copy(this.boundingSphere), Qc.applyMatrix4(n), t.ray.intersectsSphere(Qc) !== false && (Au.copy(n).invert(), Oc.copy(t.ray).applyMatrix4(Au), !(this.boundingBox !== null && Oc.intersectsBox(this.boundingBox) === false) && this._computeIntersections(t, e, Oc)));
        }
        getVertexPosition(t, e) {
          return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
        }
        bind(t, e) {
          this.skeleton = t, e === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t = new jt(), e = this.geometry.attributes.skinWeight;
          for (let i = 0, n = e.count; i < n; i++) {
            t.fromBufferAttribute(e, i);
            const r = 1 / t.manhattanLength();
            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w);
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t), this.bindMode === Gd ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === t_ ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(t, e) {
          const i = this.skeleton, n = this.geometry;
          uu.fromBufferAttribute(n.attributes.skinIndex, t), fu.fromBufferAttribute(n.attributes.skinWeight, t), du.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const a = fu.getComponent(r);
            if (a !== 0) {
              const o = uu.getComponent(r);
              pu.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), e.addScaledVector(rm.copy(du).applyMatrix4(pu), a);
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class ia extends ce {
        constructor() {
          super(), this.isBone = true, this.type = "Bone";
        }
      }
      class ga extends Pe {
        constructor(t = null, e = 1, i = 1, n, r, a, o, c, l = mi, h = mi, d, u) {
          super(null, a, o, c, l, h, n, r, d, u), this.isDataTexture = true, this.image = {
            data: t,
            width: e,
            height: i
          }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      const gu = new ft(), sm = new ft();
      class _a {
        constructor(t = [], e = []) {
          this.uuid = $i(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
          const t = this.bones, e = this.boneInverses;
          if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses();
          else if (t.length !== e.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new ft());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const i = new ft();
            this.bones[t] && i.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(i);
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const i = this.bones[t];
            i && i.matrixWorld.copy(this.boneInverses[t]).invert();
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const i = this.bones[t];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
          }
        }
        update() {
          const t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
          for (let r = 0, a = t.length; r < a; r++) {
            const o = t[r] ? t[r].matrixWorld : sm;
            gu.multiplyMatrices(o, e[r]), gu.toArray(i, r * 16);
          }
          n !== null && (n.needsUpdate = true);
        }
        clone() {
          return new _a(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t = Math.sqrt(this.bones.length * 4);
          t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
          const e = new Float32Array(t * t * 4);
          e.set(this.boneMatrices);
          const i = new ga(e, t, t, We, ii);
          return i.needsUpdate = true, this.boneMatrices = e, this.boneTexture = i, this;
        }
        getBoneByName(t) {
          for (let e = 0, i = this.bones.length; e < i; e++) {
            const n = this.bones[e];
            if (n.name === t) return n;
          }
        }
        dispose() {
          this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(t, e) {
          this.uuid = t.uuid;
          for (let i = 0, n = t.bones.length; i < n; i++) {
            const r = t.bones[i];
            let a = e[r];
            a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new ia()), this.bones.push(a), this.boneInverses.push(new ft().fromArray(t.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          t.uuid = this.uuid;
          const e = this.bones, i = this.boneInverses;
          for (let n = 0, r = e.length; n < r; n++) {
            const a = e[n];
            t.bones.push(a.uuid);
            const o = i[n];
            t.boneInverses.push(o.toArray());
          }
          return t;
        }
      }
      class fr extends ri {
        constructor(t, e, i, n = 1) {
          super(t, e, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n;
        }
        copy(t) {
          return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
        }
      }
      const Gr = new ft(), _u = new ft(), ja = [], mu = new cn(), am = new ft(), Is = new me(), Ms = new ln();
      class om extends me {
        constructor(t, e, i) {
          super(t, e), this.isInstancedMesh = true, this.instanceMatrix = new fr(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
          for (let n = 0; n < i; n++) this.setMatrixAt(n, am);
        }
        computeBoundingBox() {
          const t = this.geometry, e = this.count;
          this.boundingBox === null && (this.boundingBox = new cn()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < e; i++) this.getMatrixAt(i, Gr), mu.copy(t.boundingBox).applyMatrix4(Gr), this.boundingBox.union(mu);
        }
        computeBoundingSphere() {
          const t = this.geometry, e = this.count;
          this.boundingSphere === null && (this.boundingSphere = new ln()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
          for (let i = 0; i < e; i++) this.getMatrixAt(i, Gr), Ms.copy(t.boundingSphere).applyMatrix4(Gr), this.boundingSphere.union(Ms);
        }
        copy(t, e) {
          return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, t * 3);
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, t * 16);
        }
        getMorphAt(t, e) {
          const i = e.morphTargetInfluences, n = this.morphTexture.source.data.data, r = i.length + 1, a = t * r + 1;
          for (let o = 0; o < i.length; o++) i[o] = n[a + o];
        }
        raycast(t, e) {
          const i = this.matrixWorld, n = this.count;
          if (Is.geometry = this.geometry, Is.material = this.material, Is.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ms.copy(this.boundingSphere), Ms.applyMatrix4(i), t.ray.intersectsSphere(Ms) !== false)) for (let r = 0; r < n; r++) {
            this.getMatrixAt(r, Gr), _u.multiplyMatrices(i, Gr), Is.matrixWorld = _u, Is.raycast(t, ja);
            for (let a = 0, o = ja.length; a < o; a++) {
              const c = ja[a];
              c.instanceId = r, c.object = this, e.push(c);
            }
            ja.length = 0;
          }
        }
        setColorAt(t, e) {
          this.instanceColor === null && (this.instanceColor = new fr(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), e.toArray(this.instanceColor.array, t * 3);
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, t * 16);
        }
        setMorphAt(t, e) {
          const i = e.morphTargetInfluences, n = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new ga(new Float32Array(n * this.count), n, this.count, xn, ii));
          const r = this.morphTexture.source.data.data;
          let a = 0;
          for (let l = 0; l < i.length; l++) a += i[l];
          const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, c = n * t;
          r[c] = o, r.set(i, c + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
      }
      const zc = new I(), cm = new I(), lm = new Ot();
      class Yi {
        constructor(t = new I(1, 0, 0), e = 0) {
          this.isPlane = true, this.normal = t, this.constant = e;
        }
        set(t, e) {
          return this.normal.copy(t), this.constant = e, this;
        }
        setComponents(t, e, i, n) {
          return this.normal.set(t, e, i), this.constant = n, this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
        }
        setFromCoplanarPoints(t, e, i) {
          const n = zc.subVectors(i, e).cross(cm.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), this.constant = t.constant, this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), this.constant *= t, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
          const i = t.delta(zc), n = this.normal.dot(i);
          if (n === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / n;
          return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(i, r);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
          return e < 0 && i > 0 || i < 0 && e > 0;
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const i = e || lm.getNormalMatrix(t), n = this.coplanarPoint(zc).applyMatrix4(t), r = this.normal.applyMatrix3(i).normalize();
          return this.constant = -n.dot(r), this;
        }
        translate(t) {
          return this.constant -= t.dot(this.normal), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const tr = new ln(), qa = new I();
      class jh {
        constructor(t = new Yi(), e = new Yi(), i = new Yi(), n = new Yi(), r = new Yi(), a = new Yi()) {
          this.planes = [
            t,
            e,
            i,
            n,
            r,
            a
          ];
        }
        set(t, e, i, n, r, a) {
          const o = this.planes;
          return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this;
        }
        copy(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
          return this;
        }
        setFromProjectionMatrix(t, e = vn) {
          const i = this.planes, n = t.elements, r = n[0], a = n[1], o = n[2], c = n[3], l = n[4], h = n[5], d = n[6], u = n[7], f = n[8], p = n[9], m = n[10], g = n[11], A = n[12], x = n[13], b = n[14], y = n[15];
          if (i[0].setComponents(c - r, u - l, g - f, y - A).normalize(), i[1].setComponents(c + r, u + l, g + f, y + A).normalize(), i[2].setComponents(c + a, u + h, g + p, y + x).normalize(), i[3].setComponents(c - a, u - h, g - p, y - x).normalize(), i[4].setComponents(c - o, u - d, g - m, y - b).normalize(), e === vn) i[5].setComponents(c + o, u + d, g + m, y + b).normalize();
          else if (e === Lo) i[5].setComponents(o, d, m, b).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
          return this;
        }
        intersectsObject(t) {
          if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), tr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            const e = t.geometry;
            e.boundingSphere === null && e.computeBoundingSphere(), tr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(tr);
        }
        intersectsSprite(t) {
          return tr.center.set(0, 0, 0), tr.radius = 0.7071067811865476, tr.applyMatrix4(t.matrixWorld), this.intersectsSphere(tr);
        }
        intersectsSphere(t) {
          const e = this.planes, i = t.center, n = -t.radius;
          for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(i) < n) return false;
          return true;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) {
            const n = e[i];
            if (qa.x = n.normal.x > 0 ? t.max.x : t.min.x, qa.y = n.normal.y > 0 ? t.max.y : t.min.y, qa.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(qa) < 0) return false;
          }
          return true;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ma extends Ii {
        constructor(t) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new ht(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
        }
      }
      const No = new I(), Uo = new I(), wu = new ft(), Ts = new fs(), Xa = new ln(), Gc = new I(), bu = new I();
      class ls extends ce {
        constructor(t = new Fe(), e = new ma()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
          return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position, i = [
              0
            ];
            for (let n = 1, r = e.count; n < r; n++) No.fromBufferAttribute(e, n - 1), Uo.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += No.distanceTo(Uo);
            t.setAttribute("lineDistance", new le(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(t, e) {
          const i = this.geometry, n = this.matrixWorld, r = t.params.Line.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), Xa.copy(i.boundingSphere), Xa.applyMatrix4(n), Xa.radius += r, t.ray.intersectsSphere(Xa) === false) return;
          wu.copy(n).invert(), Ts.copy(t.ray).applyMatrix4(wu);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = this.isLineSegments ? 2 : 1, h = i.index, u = i.attributes.position;
          if (h !== null) {
            const f = Math.max(0, a.start), p = Math.min(h.count, a.start + a.count);
            for (let m = f, g = p - 1; m < g; m += l) {
              const A = h.getX(m), x = h.getX(m + 1), b = Ya(this, t, Ts, c, A, x, m);
              b && e.push(b);
            }
            if (this.isLineLoop) {
              const m = h.getX(p - 1), g = h.getX(f), A = Ya(this, t, Ts, c, m, g, p - 1);
              A && e.push(A);
            }
          } else {
            const f = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
            for (let m = f, g = p - 1; m < g; m += l) {
              const A = Ya(this, t, Ts, c, m, m + 1, m);
              A && e.push(A);
            }
            if (this.isLineLoop) {
              const m = Ya(this, t, Ts, c, p - 1, f, p - 1);
              m && e.push(m);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const n = e[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
      }
      function Ya(s, t, e, i, n, r, a) {
        const o = s.geometry.attributes.position;
        if (No.fromBufferAttribute(o, n), Uo.fromBufferAttribute(o, r), e.distanceSqToSegment(No, Uo, Gc, bu) > i) return;
        Gc.applyMatrix4(s.matrixWorld);
        const l = t.ray.origin.distanceTo(Gc);
        if (!(l < t.near || l > t.far)) return {
          distance: l,
          point: bu.clone().applyMatrix4(s.matrixWorld),
          index: a,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: s
        };
      }
      const yu = new I(), xu = new I();
      class Cp extends ls {
        constructor(t, e) {
          super(t, e), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position, i = [];
            for (let n = 0, r = e.count; n < r; n += 2) yu.fromBufferAttribute(e, n), xu.fromBufferAttribute(e, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + yu.distanceTo(xu);
            t.setAttribute("lineDistance", new le(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class hm extends ls {
        constructor(t, e) {
          super(t, e), this.isLineLoop = true, this.type = "LineLoop";
        }
      }
      class Ip extends Ii {
        constructor(t) {
          super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new ht(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
        }
      }
      const vu = new ft(), sh = new fs(), Ka = new ln(), Ja = new I();
      class dm extends ce {
        constructor(t = new Fe(), e = new Ip()) {
          super(), this.isPoints = true, this.type = "Points", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
          return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        raycast(t, e) {
          const i = this.geometry, n = this.matrixWorld, r = t.params.Points.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), Ka.copy(i.boundingSphere), Ka.applyMatrix4(n), Ka.radius += r, t.ray.intersectsSphere(Ka) === false) return;
          vu.copy(n).invert(), sh.copy(t.ray).applyMatrix4(vu);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = i.index, d = i.attributes.position;
          if (l !== null) {
            const u = Math.max(0, a.start), f = Math.min(l.count, a.start + a.count);
            for (let p = u, m = f; p < m; p++) {
              const g = l.getX(p);
              Ja.fromBufferAttribute(d, g), Eu(Ja, g, c, n, t, e, this);
            }
          } else {
            const u = Math.max(0, a.start), f = Math.min(d.count, a.start + a.count);
            for (let p = u, m = f; p < m; p++) Ja.fromBufferAttribute(d, p), Eu(Ja, p, c, n, t, e, this);
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const n = e[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
      }
      function Eu(s, t, e, i, n, r, a) {
        const o = sh.distanceSqToPoint(s);
        if (o < e) {
          const c = new I();
          sh.closestPointToPoint(s, c), c.applyMatrix4(i);
          const l = n.ray.origin.distanceTo(c);
          if (l < n.near || l > n.far) return;
          r.push({
            distance: l,
            distanceToRay: Math.sqrt(o),
            point: c,
            index: t,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a
          });
        }
      }
      class $o extends Pe {
        constructor(t, e, i, n, r, a, o, c, l, h, d, u) {
          super(null, a, o, c, l, h, n, r, d, u), this.isCompressedTexture = true, this.image = {
            width: e,
            height: i
          }, this.mipmaps = t, this.flipY = false, this.generateMipmaps = false;
        }
      }
      class um extends $o {
        constructor(t, e, i, n, r, a) {
          super(t, e, i, r, a), this.isCompressedArrayTexture = true, this.image.depth = n, this.wrapR = _i, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class fm extends $o {
        constructor(t, e, i) {
          super(void 0, t[0].width, t[0].height, e, i, gr), this.isCompressedCubeTexture = true, this.isCubeTexture = true, this.image = t;
        }
      }
      class pm extends Pe {
        constructor(t, e, i, n, r, a, o, c, l) {
          super(t, e, i, n, r, a, o, c, l), this.isCanvasTexture = true, this.needsUpdate = true;
        }
      }
      class Mp extends Pe {
        constructor(t, e, i = _r, n, r, a, o = mi, c = mi, l, h = Xs) {
          if (h !== Xs && h !== Ys) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          super(null, n, r, a, o, c, h, i, l), this.isDepthTexture = true, this.image = {
            width: t,
            height: e
          }, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(t) {
          return super.copy(t), this.source = new zh(Object.assign({}, t.image)), this.compareFunction = t.compareFunction, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
        }
      }
      class Qi {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = false, this.cacheArcLengths = null;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
        }
        getPointAt(t, e) {
          const i = this.getUtoTmapping(t);
          return this.getPoint(i, e);
        }
        getPoints(t = 5) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return e;
        }
        getSpacedPoints(t = 5) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
          return e;
        }
        getLength() {
          const t = this.getLengths();
          return t[t.length - 1];
        }
        getLengths(t = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = false;
          const e = [];
          let i, n = this.getPoint(0), r = 0;
          e.push(0);
          for (let a = 1; a <= t; a++) i = this.getPoint(a / t), r += i.distanceTo(n), e.push(r), n = i;
          return this.cacheArcLengths = e, e;
        }
        updateArcLengths() {
          this.needsUpdate = true, this.getLengths();
        }
        getUtoTmapping(t, e = null) {
          const i = this.getLengths();
          let n = 0;
          const r = i.length;
          let a;
          e ? a = e : a = t * i[r - 1];
          let o = 0, c = r - 1, l;
          for (; o <= c; ) if (n = Math.floor(o + (c - o) / 2), l = i[n] - a, l < 0) o = n + 1;
          else if (l > 0) c = n - 1;
          else {
            c = n;
            break;
          }
          if (n = c, i[n] === a) return n / (r - 1);
          const h = i[n], u = i[n + 1] - h, f = (a - h) / u;
          return (n + f) / (r - 1);
        }
        getTangent(t, e) {
          let n = t - 1e-4, r = t + 1e-4;
          n < 0 && (n = 0), r > 1 && (r = 1);
          const a = this.getPoint(n), o = this.getPoint(r), c = e || (a.isVector2 ? new rt() : new I());
          return c.copy(o).sub(a).normalize(), c;
        }
        getTangentAt(t, e) {
          const i = this.getUtoTmapping(t);
          return this.getTangent(i, e);
        }
        computeFrenetFrames(t, e = false) {
          const i = new I(), n = [], r = [], a = [], o = new I(), c = new ft();
          for (let f = 0; f <= t; f++) {
            const p = f / t;
            n[f] = this.getTangentAt(p, new I());
          }
          r[0] = new I(), a[0] = new I();
          let l = Number.MAX_VALUE;
          const h = Math.abs(n[0].x), d = Math.abs(n[0].y), u = Math.abs(n[0].z);
          h <= l && (l = h, i.set(1, 0, 0)), d <= l && (l = d, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), o.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], o), a[0].crossVectors(n[0], r[0]);
          for (let f = 1; f <= t; f++) {
            if (r[f] = r[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(n[f - 1], n[f]), o.length() > Number.EPSILON) {
              o.normalize();
              const p = Math.acos(Ht(n[f - 1].dot(n[f]), -1, 1));
              r[f].applyMatrix4(c.makeRotationAxis(o, p));
            }
            a[f].crossVectors(n[f], r[f]);
          }
          if (e === true) {
            let f = Math.acos(Ht(r[0].dot(r[t]), -1, 1));
            f /= t, n[0].dot(o.crossVectors(r[0], r[t])) > 0 && (f = -f);
            for (let p = 1; p <= t; p++) r[p].applyMatrix4(c.makeRotationAxis(n[p], f * p)), a[p].crossVectors(n[p], r[p]);
          }
          return {
            tangents: n,
            normals: r,
            binormals: a
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.arcLengthDivisions = t.arcLengthDivisions, this;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
        }
        fromJSON(t) {
          return this.arcLengthDivisions = t.arcLengthDivisions, this;
        }
      }
      class qh extends Qi {
        constructor(t = 0, e = 0, i = 1, n = 1, r = 0, a = Math.PI * 2, o = false, c = 0) {
          super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = c;
        }
        getPoint(t, e = new rt()) {
          const i = e, n = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const a = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += n;
          for (; r > n; ) r -= n;
          r < Number.EPSILON && (a ? r = 0 : r = n), this.aClockwise === true && !a && (r === n ? r = -n : r = r - n);
          const o = this.aStartAngle + t * r;
          let c = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), u = c - this.aX, f = l - this.aY;
            c = u * h - f * d + this.aX, l = u * d + f * h + this.aY;
          }
          return i.set(c, l);
        }
        copy(t) {
          return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
        }
      }
      class Am extends qh {
        constructor(t, e, i, n, r, a) {
          super(t, e, i, i, n, r, a), this.isArcCurve = true, this.type = "ArcCurve";
        }
      }
      function Xh() {
        let s = 0, t = 0, e = 0, i = 0;
        function n(r, a, o, c) {
          s = r, t = o, e = -3 * r + 3 * a - 2 * o - c, i = 2 * r - 2 * a + o + c;
        }
        return {
          initCatmullRom: function(r, a, o, c, l) {
            n(a, o, l * (o - r), l * (c - a));
          },
          initNonuniformCatmullRom: function(r, a, o, c, l, h, d) {
            let u = (a - r) / l - (o - r) / (l + h) + (o - a) / h, f = (o - a) / h - (c - a) / (h + d) + (c - o) / d;
            u *= h, f *= h, n(a, o, u, f);
          },
          calc: function(r) {
            const a = r * r, o = a * r;
            return s + t * r + e * a + i * o;
          }
        };
      }
      const Za = new I(), Hc = new Xh(), Vc = new Xh(), Wc = new Xh();
      class Tp extends Qi {
        constructor(t = [], e = false, i = "centripetal", n = 0.5) {
          super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n;
        }
        getPoint(t, e = new I()) {
          const i = e, n = this.points, r = n.length, a = (r - (this.closed ? 0 : 1)) * t;
          let o = Math.floor(a), c = a - o;
          this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : c === 0 && o === r - 1 && (o = r - 2, c = 1);
          let l, h;
          this.closed || o > 0 ? l = n[(o - 1) % r] : (Za.subVectors(n[0], n[1]).add(n[0]), l = Za);
          const d = n[o % r], u = n[(o + 1) % r];
          if (this.closed || o + 2 < r ? h = n[(o + 2) % r] : (Za.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), h = Za), this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let p = Math.pow(l.distanceToSquared(d), f), m = Math.pow(d.distanceToSquared(u), f), g = Math.pow(u.distanceToSquared(h), f);
            m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Hc.initNonuniformCatmullRom(l.x, d.x, u.x, h.x, p, m, g), Vc.initNonuniformCatmullRom(l.y, d.y, u.y, h.y, p, m, g), Wc.initNonuniformCatmullRom(l.z, d.z, u.z, h.z, p, m, g);
          } else this.curveType === "catmullrom" && (Hc.initCatmullRom(l.x, d.x, u.x, h.x, this.tension), Vc.initCatmullRom(l.y, d.y, u.y, h.y, this.tension), Wc.initCatmullRom(l.z, d.z, u.z, h.z, this.tension));
          return i.set(Hc.calc(c), Vc.calc(c), Wc.calc(c)), i;
        }
        copy(t) {
          super.copy(t), this.points = [];
          for (let e = 0, i = t.points.length; e < i; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
        }
        fromJSON(t) {
          super.fromJSON(t), this.points = [];
          for (let e = 0, i = t.points.length; e < i; e++) {
            const n = t.points[e];
            this.points.push(new I().fromArray(n));
          }
          return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
        }
      }
      function Su(s, t, e, i, n) {
        const r = (i - t) * 0.5, a = (n - e) * 0.5, o = s * s, c = s * o;
        return (2 * e - 2 * i + r + a) * c + (-3 * e + 3 * i - 2 * r - a) * o + r * s + e;
      }
      function gm(s, t) {
        const e = 1 - s;
        return e * e * t;
      }
      function _m(s, t) {
        return 2 * (1 - s) * s * t;
      }
      function mm(s, t) {
        return s * s * t;
      }
      function Gs(s, t, e, i) {
        return gm(s, t) + _m(s, e) + mm(s, i);
      }
      function wm(s, t) {
        const e = 1 - s;
        return e * e * e * t;
      }
      function bm(s, t) {
        const e = 1 - s;
        return 3 * e * e * s * t;
      }
      function ym(s, t) {
        return 3 * (1 - s) * s * s * t;
      }
      function xm(s, t) {
        return s * s * s * t;
      }
      function Hs(s, t, e, i, n) {
        return wm(s, t) + bm(s, e) + ym(s, i) + xm(s, n);
      }
      class Rp extends Qi {
        constructor(t = new rt(), e = new rt(), i = new rt(), n = new rt()) {
          super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
        }
        getPoint(t, e = new rt()) {
          const i = e, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
          return i.set(Hs(t, n.x, r.x, a.x, o.x), Hs(t, n.y, r.y, a.y, o.y)), i;
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
        }
      }
      class vm extends Qi {
        constructor(t = new I(), e = new I(), i = new I(), n = new I()) {
          super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n;
        }
        getPoint(t, e = new I()) {
          const i = e, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
          return i.set(Hs(t, n.x, r.x, a.x, o.x), Hs(t, n.y, r.y, a.y, o.y), Hs(t, n.z, r.z, a.z, o.z)), i;
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
        }
      }
      class Bp extends Qi {
        constructor(t = new rt(), e = new rt()) {
          super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = t, this.v2 = e;
        }
        getPoint(t, e = new rt()) {
          const i = e;
          return t === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e = new rt()) {
          return e.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(t, e) {
          return this.getTangent(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
        }
      }
      class Em extends Qi {
        constructor(t = new I(), e = new I()) {
          super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = t, this.v2 = e;
        }
        getPoint(t, e = new I()) {
          const i = e;
          return t === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
        }
        getPointAt(t, e) {
          return this.getPoint(t, e);
        }
        getTangent(t, e = new I()) {
          return e.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(t, e) {
          return this.getTangent(t, e);
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
        }
      }
      class Dp extends Qi {
        constructor(t = new rt(), e = new rt(), i = new rt()) {
          super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i;
        }
        getPoint(t, e = new rt()) {
          const i = e, n = this.v0, r = this.v1, a = this.v2;
          return i.set(Gs(t, n.x, r.x, a.x), Gs(t, n.y, r.y, a.y)), i;
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
        }
      }
      class Pp extends Qi {
        constructor(t = new I(), e = new I(), i = new I()) {
          super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i;
        }
        getPoint(t, e = new I()) {
          const i = e, n = this.v0, r = this.v1, a = this.v2;
          return i.set(Gs(t, n.x, r.x, a.x), Gs(t, n.y, r.y, a.y), Gs(t, n.z, r.z, a.z)), i;
        }
        copy(t) {
          return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
        }
      }
      class Fp extends Qi {
        constructor(t = []) {
          super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = t;
        }
        getPoint(t, e = new rt()) {
          const i = e, n = this.points, r = (n.length - 1) * t, a = Math.floor(r), o = r - a, c = n[a === 0 ? a : a - 1], l = n[a], h = n[a > n.length - 2 ? n.length - 1 : a + 1], d = n[a > n.length - 3 ? n.length - 1 : a + 2];
          return i.set(Su(o, c.x, l.x, h.x, d.x), Su(o, c.y, l.y, h.y, d.y)), i;
        }
        copy(t) {
          super.copy(t), this.points = [];
          for (let e = 0, i = t.points.length; e < i; e++) {
            const n = t.points[e];
            this.points.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const t = super.toJSON();
          t.points = [];
          for (let e = 0, i = this.points.length; e < i; e++) {
            const n = this.points[e];
            t.points.push(n.toArray());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), this.points = [];
          for (let e = 0, i = t.points.length; e < i; e++) {
            const n = t.points[e];
            this.points.push(new rt().fromArray(n));
          }
          return this;
        }
      }
      var ah = Object.freeze({
        __proto__: null,
        ArcCurve: Am,
        CatmullRomCurve3: Tp,
        CubicBezierCurve: Rp,
        CubicBezierCurve3: vm,
        EllipseCurve: qh,
        LineCurve: Bp,
        LineCurve3: Em,
        QuadraticBezierCurve: Dp,
        QuadraticBezierCurve3: Pp,
        SplineCurve: Fp
      });
      class Sm extends Qi {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        add(t) {
          this.curves.push(t);
        }
        closePath() {
          const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
          if (!t.equals(e)) {
            const i = t.isVector2 === true ? "LineCurve" : "LineCurve3";
            this.curves.push(new ah[i](e, t));
          }
          return this;
        }
        getPoint(t, e) {
          const i = t * this.getLength(), n = this.getCurveLengths();
          let r = 0;
          for (; r < n.length; ) {
            if (n[r] >= i) {
              const a = n[r] - i, o = this.curves[r], c = o.getLength(), l = c === 0 ? 0 : 1 - a / c;
              return o.getPointAt(l, e);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const t = this.getCurveLengths();
          return t[t.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          const t = [];
          let e = 0;
          for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
          return this.cacheLengths = t, t;
        }
        getSpacedPoints(t = 40) {
          const e = [];
          for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
          return this.autoClose && e.push(e[0]), e;
        }
        getPoints(t = 12) {
          const e = [];
          let i;
          for (let n = 0, r = this.curves; n < r.length; n++) {
            const a = r[n], o = a.isEllipseCurve ? t * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? t * a.points.length : t, c = a.getPoints(o);
            for (let l = 0; l < c.length; l++) {
              const h = c[l];
              i && i.equals(h) || (e.push(h), i = h);
            }
          }
          return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
        }
        copy(t) {
          super.copy(t), this.curves = [];
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const n = t.curves[e];
            this.curves.push(n.clone());
          }
          return this.autoClose = t.autoClose, this;
        }
        toJSON() {
          const t = super.toJSON();
          t.autoClose = this.autoClose, t.curves = [];
          for (let e = 0, i = this.curves.length; e < i; e++) {
            const n = this.curves[e];
            t.curves.push(n.toJSON());
          }
          return t;
        }
        fromJSON(t) {
          super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
          for (let e = 0, i = t.curves.length; e < i; e++) {
            const n = t.curves[e];
            this.curves.push(new ah[n.type]().fromJSON(n));
          }
          return this;
        }
      }
      class Cm extends Sm {
        constructor(t) {
          super(), this.type = "Path", this.currentPoint = new rt(), t && this.setFromPoints(t);
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y);
          for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
          return this;
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this;
        }
        lineTo(t, e) {
          const i = new Bp(this.currentPoint.clone(), new rt(t, e));
          return this.curves.push(i), this.currentPoint.set(t, e), this;
        }
        quadraticCurveTo(t, e, i, n) {
          const r = new Dp(this.currentPoint.clone(), new rt(t, e), new rt(i, n));
          return this.curves.push(r), this.currentPoint.set(i, n), this;
        }
        bezierCurveTo(t, e, i, n, r, a) {
          const o = new Rp(this.currentPoint.clone(), new rt(t, e), new rt(i, n), new rt(r, a));
          return this.curves.push(o), this.currentPoint.set(r, a), this;
        }
        splineThru(t) {
          const e = [
            this.currentPoint.clone()
          ].concat(t), i = new Fp(e);
          return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
        }
        arc(t, e, i, n, r, a) {
          const o = this.currentPoint.x, c = this.currentPoint.y;
          return this.absarc(t + o, e + c, i, n, r, a), this;
        }
        absarc(t, e, i, n, r, a) {
          return this.absellipse(t, e, i, i, n, r, a), this;
        }
        ellipse(t, e, i, n, r, a, o, c) {
          const l = this.currentPoint.x, h = this.currentPoint.y;
          return this.absellipse(t + l, e + h, i, n, r, a, o, c), this;
        }
        absellipse(t, e, i, n, r, a, o, c) {
          const l = new qh(t, e, i, n, r, a, o, c);
          if (this.curves.length > 0) {
            const d = l.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
          }
          this.curves.push(l);
          const h = l.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.currentPoint = this.currentPoint.toArray(), t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
        }
      }
      class Yh extends Fe {
        constructor(t = [
          new rt(0, -0.5),
          new rt(0.5, 0),
          new rt(0, 0.5)
        ], e = 12, i = 0, n = Math.PI * 2) {
          super(), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
          }, e = Math.floor(e), n = Ht(n, 0, Math.PI * 2);
          const r = [], a = [], o = [], c = [], l = [], h = 1 / e, d = new I(), u = new rt(), f = new I(), p = new I(), m = new I();
          let g = 0, A = 0;
          for (let x = 0; x <= t.length - 1; x++) switch (x) {
            case 0:
              g = t[x + 1].x - t[x].x, A = t[x + 1].y - t[x].y, f.x = A * 1, f.y = -g, f.z = A * 0, m.copy(f), f.normalize(), c.push(f.x, f.y, f.z);
              break;
            case t.length - 1:
              c.push(m.x, m.y, m.z);
              break;
            default:
              g = t[x + 1].x - t[x].x, A = t[x + 1].y - t[x].y, f.x = A * 1, f.y = -g, f.z = A * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), c.push(f.x, f.y, f.z), m.copy(p);
          }
          for (let x = 0; x <= e; x++) {
            const b = i + x * h * n, y = Math.sin(b), M = Math.cos(b);
            for (let T = 0; T <= t.length - 1; T++) {
              d.x = t[T].x * y, d.y = t[T].y, d.z = t[T].x * M, a.push(d.x, d.y, d.z), u.x = x / e, u.y = T / (t.length - 1), o.push(u.x, u.y);
              const R = c[3 * T + 0] * y, B = c[3 * T + 1], S = c[3 * T + 0] * M;
              l.push(R, B, S);
            }
          }
          for (let x = 0; x < e; x++) for (let b = 0; b < t.length - 1; b++) {
            const y = b + x * t.length, M = y, T = y + t.length, R = y + t.length + 1, B = y + 1;
            r.push(M, T, B), r.push(R, B, T);
          }
          this.setIndex(r), this.setAttribute("position", new le(a, 3)), this.setAttribute("uv", new le(o, 2)), this.setAttribute("normal", new le(l, 3));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new Yh(t.points, t.segments, t.phiStart, t.phiLength);
        }
      }
      class Kh extends Yh {
        constructor(t = 1, e = 1, i = 4, n = 8) {
          const r = new Cm();
          r.absarc(0, -e / 2, t, Math.PI * 1.5, 0), r.absarc(0, e / 2, t, 0, Math.PI * 0.5), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
            radius: t,
            length: e,
            capSegments: i,
            radialSegments: n
          };
        }
        static fromJSON(t) {
          return new Kh(t.radius, t.length, t.capSegments, t.radialSegments);
        }
      }
      function Im(s, t, e = 2) {
        const i = t && t.length, n = i ? t[0] * e : s.length;
        let r = Lp(s, 0, n, e, true);
        const a = [];
        if (!r || r.next === r.prev) return a;
        let o, c, l;
        if (i && (r = Dm(s, t, r, e)), s.length > 80 * e) {
          o = 1 / 0, c = 1 / 0;
          let h = -1 / 0, d = -1 / 0;
          for (let u = e; u < n; u += e) {
            const f = s[u], p = s[u + 1];
            f < o && (o = f), p < c && (c = p), f > h && (h = f), p > d && (d = p);
          }
          l = Math.max(h - o, d - c), l = l !== 0 ? 32767 / l : 0;
        }
        return na(r, a, e, o, c, l, 0), a;
      }
      function Lp(s, t, e, i, n) {
        let r;
        if (n === Hm(s, t, e, i) > 0) for (let a = t; a < e; a += i) r = Cu(a / i | 0, s[a], s[a + 1], r);
        else for (let a = e - i; a >= t; a -= i) r = Cu(a / i | 0, s[a], s[a + 1], r);
        return r && hs(r, r.next) && (sa(r), r = r.next), r;
      }
      function mr(s, t) {
        if (!s) return s;
        t || (t = s);
        let e = s, i;
        do
          if (i = false, !e.steiner && (hs(e, e.next) || Te(e.prev, e, e.next) === 0)) {
            if (sa(e), e = t = e.prev, e === e.next) break;
            i = true;
          } else e = e.next;
        while (i || e !== t);
        return t;
      }
      function na(s, t, e, i, n, r, a) {
        if (!s) return;
        !a && r && Nm(s, i, n, r);
        let o = s;
        for (; s.prev !== s.next; ) {
          const c = s.prev, l = s.next;
          if (r ? Tm(s, i, n, r) : Mm(s)) {
            t.push(c.i, s.i, l.i), sa(s), s = l.next, o = l.next;
            continue;
          }
          if (s = l, s === o) {
            a ? a === 1 ? (s = Rm(mr(s), t), na(s, t, e, i, n, r, 2)) : a === 2 && Bm(s, t, e, i, n, r) : na(mr(s), t, e, i, n, r, 1);
            break;
          }
        }
      }
      function Mm(s) {
        const t = s.prev, e = s, i = s.next;
        if (Te(t, e, i) >= 0) return false;
        const n = t.x, r = e.x, a = i.x, o = t.y, c = e.y, l = i.y, h = Math.min(n, r, a), d = Math.min(o, c, l), u = Math.max(n, r, a), f = Math.max(o, c, l);
        let p = i.next;
        for (; p !== t; ) {
          if (p.x >= h && p.x <= u && p.y >= d && p.y <= f && Fs(n, o, r, c, a, l, p.x, p.y) && Te(p.prev, p, p.next) >= 0) return false;
          p = p.next;
        }
        return true;
      }
      function Tm(s, t, e, i) {
        const n = s.prev, r = s, a = s.next;
        if (Te(n, r, a) >= 0) return false;
        const o = n.x, c = r.x, l = a.x, h = n.y, d = r.y, u = a.y, f = Math.min(o, c, l), p = Math.min(h, d, u), m = Math.max(o, c, l), g = Math.max(h, d, u), A = oh(f, p, t, e, i), x = oh(m, g, t, e, i);
        let b = s.prevZ, y = s.nextZ;
        for (; b && b.z >= A && y && y.z <= x; ) {
          if (b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== n && b !== a && Fs(o, h, c, d, l, u, b.x, b.y) && Te(b.prev, b, b.next) >= 0 || (b = b.prevZ, y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== a && Fs(o, h, c, d, l, u, y.x, y.y) && Te(y.prev, y, y.next) >= 0)) return false;
          y = y.nextZ;
        }
        for (; b && b.z >= A; ) {
          if (b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== n && b !== a && Fs(o, h, c, d, l, u, b.x, b.y) && Te(b.prev, b, b.next) >= 0) return false;
          b = b.prevZ;
        }
        for (; y && y.z <= x; ) {
          if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== a && Fs(o, h, c, d, l, u, y.x, y.y) && Te(y.prev, y, y.next) >= 0) return false;
          y = y.nextZ;
        }
        return true;
      }
      function Rm(s, t) {
        let e = s;
        do {
          const i = e.prev, n = e.next.next;
          !hs(i, n) && Np(i, e, e.next, n) && ra(i, n) && ra(n, i) && (t.push(i.i, e.i, n.i), sa(e), sa(e.next), e = s = n), e = e.next;
        } while (e !== s);
        return mr(e);
      }
      function Bm(s, t, e, i, n, r) {
        let a = s;
        do {
          let o = a.next.next;
          for (; o !== a.prev; ) {
            if (a.i !== o.i && Om(a, o)) {
              let c = Up(a, o);
              a = mr(a, a.next), c = mr(c, c.next), na(a, t, e, i, n, r, 0), na(c, t, e, i, n, r, 0);
              return;
            }
            o = o.next;
          }
          a = a.next;
        } while (a !== s);
      }
      function Dm(s, t, e, i) {
        const n = [];
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r] * i, c = r < a - 1 ? t[r + 1] * i : s.length, l = Lp(s, o, c, i, false);
          l === l.next && (l.steiner = true), n.push(Qm(l));
        }
        n.sort(Pm);
        for (let r = 0; r < n.length; r++) e = Fm(n[r], e);
        return e;
      }
      function Pm(s, t) {
        let e = s.x - t.x;
        if (e === 0 && (e = s.y - t.y, e === 0)) {
          const i = (s.next.y - s.y) / (s.next.x - s.x), n = (t.next.y - t.y) / (t.next.x - t.x);
          e = i - n;
        }
        return e;
      }
      function Fm(s, t) {
        const e = Lm(s, t);
        if (!e) return t;
        const i = Up(e, s);
        return mr(i, i.next), mr(e, e.next);
      }
      function Lm(s, t) {
        let e = t;
        const i = s.x, n = s.y;
        let r = -1 / 0, a;
        if (hs(s, e)) return e;
        do {
          if (hs(s, e.next)) return e.next;
          if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
            const d = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
            if (d <= i && d > r && (r = d, a = e.x < e.next.x ? e : e.next, d === i)) return a;
          }
          e = e.next;
        } while (e !== t);
        if (!a) return null;
        const o = a, c = a.x, l = a.y;
        let h = 1 / 0;
        e = a;
        do {
          if (i >= e.x && e.x >= c && i !== e.x && kp(n < l ? i : r, n, c, l, n < l ? r : i, n, e.x, e.y)) {
            const d = Math.abs(n - e.y) / (i - e.x);
            ra(e, s) && (d < h || d === h && (e.x > a.x || e.x === a.x && km(a, e))) && (a = e, h = d);
          }
          e = e.next;
        } while (e !== o);
        return a;
      }
      function km(s, t) {
        return Te(s.prev, s, t.prev) < 0 && Te(t.next, s, s.next) < 0;
      }
      function Nm(s, t, e, i) {
        let n = s;
        do
          n.z === 0 && (n.z = oh(n.x, n.y, t, e, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
        while (n !== s);
        n.prevZ.nextZ = null, n.prevZ = null, Um(n);
      }
      function Um(s) {
        let t, e = 1;
        do {
          let i = s, n;
          s = null;
          let r = null;
          for (t = 0; i; ) {
            t++;
            let a = i, o = 0;
            for (let l = 0; l < e && (o++, a = a.nextZ, !!a); l++) ;
            let c = e;
            for (; o > 0 || c > 0 && a; ) o !== 0 && (c === 0 || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, c--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
            i = a;
          }
          r.nextZ = null, e *= 2;
        } while (t > 1);
        return s;
      }
      function oh(s, t, e, i, n) {
        return s = (s - e) * n | 0, t = (t - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, s | t << 1;
      }
      function Qm(s) {
        let t = s, e = s;
        do
          (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
        while (t !== s);
        return e;
      }
      function kp(s, t, e, i, n, r, a, o) {
        return (n - a) * (t - o) >= (s - a) * (r - o) && (s - a) * (i - o) >= (e - a) * (t - o) && (e - a) * (r - o) >= (n - a) * (i - o);
      }
      function Fs(s, t, e, i, n, r, a, o) {
        return !(s === a && t === o) && kp(s, t, e, i, n, r, a, o);
      }
      function Om(s, t) {
        return s.next.i !== t.i && s.prev.i !== t.i && !zm(s, t) && (ra(s, t) && ra(t, s) && Gm(s, t) && (Te(s.prev, s, t.prev) || Te(s, t.prev, t)) || hs(s, t) && Te(s.prev, s, s.next) > 0 && Te(t.prev, t, t.next) > 0);
      }
      function Te(s, t, e) {
        return (t.y - s.y) * (e.x - t.x) - (t.x - s.x) * (e.y - t.y);
      }
      function hs(s, t) {
        return s.x === t.x && s.y === t.y;
      }
      function Np(s, t, e, i) {
        const n = to(Te(s, t, e)), r = to(Te(s, t, i)), a = to(Te(e, i, s)), o = to(Te(e, i, t));
        return !!(n !== r && a !== o || n === 0 && $a(s, e, t) || r === 0 && $a(s, i, t) || a === 0 && $a(e, s, i) || o === 0 && $a(e, t, i));
      }
      function $a(s, t, e) {
        return t.x <= Math.max(s.x, e.x) && t.x >= Math.min(s.x, e.x) && t.y <= Math.max(s.y, e.y) && t.y >= Math.min(s.y, e.y);
      }
      function to(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function zm(s, t) {
        let e = s;
        do {
          if (e.i !== s.i && e.next.i !== s.i && e.i !== t.i && e.next.i !== t.i && Np(e, e.next, s, t)) return true;
          e = e.next;
        } while (e !== s);
        return false;
      }
      function ra(s, t) {
        return Te(s.prev, s, s.next) < 0 ? Te(s, t, s.next) >= 0 && Te(s, s.prev, t) >= 0 : Te(s, t, s.prev) < 0 || Te(s, s.next, t) < 0;
      }
      function Gm(s, t) {
        let e = s, i = false;
        const n = (s.x + t.x) / 2, r = (s.y + t.y) / 2;
        do
          e.y > r != e.next.y > r && e.next.y !== e.y && n < (e.next.x - e.x) * (r - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
        while (e !== s);
        return i;
      }
      function Up(s, t) {
        const e = ch(s.i, s.x, s.y), i = ch(t.i, t.x, t.y), n = s.next, r = t.prev;
        return s.next = t, t.prev = s, e.next = n, n.prev = e, i.next = e, e.prev = i, r.next = i, i.prev = r, i;
      }
      function Cu(s, t, e, i) {
        const n = ch(s, t, e);
        return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
      }
      function sa(s) {
        s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function ch(s, t, e) {
        return {
          i: s,
          x: t,
          y: e,
          prev: null,
          next: null,
          z: 0,
          prevZ: null,
          nextZ: null,
          steiner: false
        };
      }
      function Hm(s, t, e, i) {
        let n = 0;
        for (let r = t, a = e - i; r < e; r += i) n += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
        return n;
      }
      class Vm {
        static triangulate(t, e, i = 2) {
          return Im(t, e, i);
        }
      }
      class Jh {
        static area(t) {
          const e = t.length;
          let i = 0;
          for (let n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
          return i * 0.5;
        }
        static isClockWise(t) {
          return Jh.area(t) < 0;
        }
        static triangulateShape(t, e) {
          const i = [], n = [], r = [];
          Iu(t), Mu(i, t);
          let a = t.length;
          e.forEach(Iu);
          for (let c = 0; c < e.length; c++) n.push(a), a += e[c].length, Mu(i, e[c]);
          const o = Vm.triangulate(i, n);
          for (let c = 0; c < o.length; c += 3) r.push(o.slice(c, c + 3));
          return r;
        }
      }
      function Iu(s) {
        const t = s.length;
        t > 2 && s[t - 1].equals(s[0]) && s.pop();
      }
      function Mu(s, t) {
        for (let e = 0; e < t.length; e++) s.push(t[e].x), s.push(t[e].y);
      }
      class vr extends Fe {
        constructor(t = 1, e = 1, i = 1, n = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
          };
          const r = t / 2, a = e / 2, o = Math.floor(i), c = Math.floor(n), l = o + 1, h = c + 1, d = t / o, u = e / c, f = [], p = [], m = [], g = [];
          for (let A = 0; A < h; A++) {
            const x = A * u - a;
            for (let b = 0; b < l; b++) {
              const y = b * d - r;
              p.push(y, -x, 0), m.push(0, 0, 1), g.push(b / o), g.push(1 - A / c);
            }
          }
          for (let A = 0; A < c; A++) for (let x = 0; x < o; x++) {
            const b = x + l * A, y = x + l * (A + 1), M = x + 1 + l * (A + 1), T = x + 1 + l * A;
            f.push(b, y, T), f.push(y, M, T);
          }
          this.setIndex(f), this.setAttribute("position", new le(p, 3)), this.setAttribute("normal", new le(m, 3)), this.setAttribute("uv", new le(g, 2));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new vr(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      class Zh extends Fe {
        constructor(t = 1, e = 32, i = 16, n = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
          }, e = Math.max(3, Math.floor(e)), i = Math.max(2, Math.floor(i));
          const c = Math.min(a + o, Math.PI);
          let l = 0;
          const h = [], d = new I(), u = new I(), f = [], p = [], m = [], g = [];
          for (let A = 0; A <= i; A++) {
            const x = [], b = A / i;
            let y = 0;
            A === 0 && a === 0 ? y = 0.5 / e : A === i && c === Math.PI && (y = -0.5 / e);
            for (let M = 0; M <= e; M++) {
              const T = M / e;
              d.x = -t * Math.cos(n + T * r) * Math.sin(a + b * o), d.y = t * Math.cos(a + b * o), d.z = t * Math.sin(n + T * r) * Math.sin(a + b * o), p.push(d.x, d.y, d.z), u.copy(d).normalize(), m.push(u.x, u.y, u.z), g.push(T + y, 1 - b), x.push(l++);
            }
            h.push(x);
          }
          for (let A = 0; A < i; A++) for (let x = 0; x < e; x++) {
            const b = h[A][x + 1], y = h[A][x], M = h[A + 1][x], T = h[A + 1][x + 1];
            (A !== 0 || a > 0) && f.push(b, y, T), (A !== i - 1 || c < Math.PI) && f.push(y, M, T);
          }
          this.setIndex(f), this.setAttribute("position", new le(p, 3)), this.setAttribute("normal", new le(m, 3)), this.setAttribute("uv", new le(g, 2));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new Zh(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
        }
      }
      class $h extends Fe {
        constructor(t = new Pp(new I(-1, -1, 0), new I(-1, 1, 0), new I(1, 1, 0)), e = 64, i = 1, n = 8, r = false) {
          super(), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
          };
          const a = t.computeFrenetFrames(e, r);
          this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
          const o = new I(), c = new I(), l = new rt();
          let h = new I();
          const d = [], u = [], f = [], p = [];
          m(), this.setIndex(p), this.setAttribute("position", new le(d, 3)), this.setAttribute("normal", new le(u, 3)), this.setAttribute("uv", new le(f, 2));
          function m() {
            for (let b = 0; b < e; b++) g(b);
            g(r === false ? e : 0), x(), A();
          }
          function g(b) {
            h = t.getPointAt(b / e, h);
            const y = a.normals[b], M = a.binormals[b];
            for (let T = 0; T <= n; T++) {
              const R = T / n * Math.PI * 2, B = Math.sin(R), S = -Math.cos(R);
              c.x = S * y.x + B * M.x, c.y = S * y.y + B * M.y, c.z = S * y.z + B * M.z, c.normalize(), u.push(c.x, c.y, c.z), o.x = h.x + i * c.x, o.y = h.y + i * c.y, o.z = h.z + i * c.z, d.push(o.x, o.y, o.z);
            }
          }
          function A() {
            for (let b = 1; b <= e; b++) for (let y = 1; y <= n; y++) {
              const M = (n + 1) * (b - 1) + (y - 1), T = (n + 1) * b + (y - 1), R = (n + 1) * b + y, B = (n + 1) * (b - 1) + y;
              p.push(M, T, B), p.push(T, R, B);
            }
          }
          function x() {
            for (let b = 0; b <= e; b++) for (let y = 0; y <= n; y++) l.x = b / e, l.y = y / n, f.push(l.x, l.y);
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.path = this.parameters.path.toJSON(), t;
        }
        static fromJSON(t) {
          return new $h(new ah[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed);
        }
      }
      class Wm extends Ni {
        constructor(t) {
          super(t), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
        }
      }
      class ci extends Ii {
        constructor(t) {
          super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
          }, this.color = new ht(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ko, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Oe(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.defines = {
            STANDARD: ""
          }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
      }
      class hn extends ci {
        constructor(t) {
          super(), this.isMeshPhysicalMaterial = true, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new rt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
              return Ht(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(e) {
              this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
            }
          }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
            100,
            400
          ], this.iridescenceThicknessMap = null, this.sheenColor = new ht(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ht(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ht(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(t) {
          this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(t) {
          this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(t) {
          this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(t) {
          this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t;
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(t) {
          this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(t) {
          this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
        }
        copy(t) {
          return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [
            ...t.iridescenceThicknessRange
          ], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
        }
      }
      class eo extends Ii {
        constructor(t) {
          super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new ht(16777215), this.specular = new ht(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ko, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Oe(), this.combine = qo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
      }
      class jm extends Ii {
        constructor(t) {
          super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new ht(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ht(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ko, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Oe(), this.combine = qo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
      }
      class qm extends Ii {
        constructor(t) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = s_, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
        }
      }
      class Xm extends Ii {
        constructor(t) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
        }
      }
      function io(s, t) {
        return !s || s.constructor === t ? s : typeof t.BYTES_PER_ELEMENT == "number" ? new t(s) : Array.prototype.slice.call(s);
      }
      function Ym(s) {
        return ArrayBuffer.isView(s) && !(s instanceof DataView);
      }
      function Km(s) {
        function t(n, r) {
          return s[n] - s[r];
        }
        const e = s.length, i = new Array(e);
        for (let n = 0; n !== e; ++n) i[n] = n;
        return i.sort(t), i;
      }
      function Tu(s, t, e) {
        const i = s.length, n = new s.constructor(i);
        for (let r = 0, a = 0; a !== i; ++r) {
          const o = e[r] * t;
          for (let c = 0; c !== t; ++c) n[a++] = s[o + c];
        }
        return n;
      }
      function Qp(s, t, e, i) {
        let n = 1, r = s[0];
        for (; r !== void 0 && r[i] === void 0; ) r = s[n++];
        if (r === void 0) return;
        let a = r[i];
        if (a !== void 0) if (Array.isArray(a)) do
          a = r[i], a !== void 0 && (t.push(r.time), e.push(...a)), r = s[n++];
        while (r !== void 0);
        else if (a.toArray !== void 0) do
          a = r[i], a !== void 0 && (t.push(r.time), a.toArray(e, e.length)), r = s[n++];
        while (r !== void 0);
        else do
          a = r[i], a !== void 0 && (t.push(r.time), e.push(a)), r = s[n++];
        while (r !== void 0);
      }
      class wa {
        constructor(t, e, i, n) {
          this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(t) {
          const e = this.parameterPositions;
          let i = this._cachedIndex, n = e[i], r = e[i - 1];
          t: {
            e: {
              let a;
              i: {
                n: if (!(t < n)) {
                  for (let o = i + 2; ; ) {
                    if (n === void 0) {
                      if (t < r) break n;
                      return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                    }
                    if (i === o) break;
                    if (r = n, n = e[++i], t < n) break e;
                  }
                  a = e.length;
                  break i;
                }
                if (!(t >= r)) {
                  const o = e[1];
                  t < o && (i = 2, r = o);
                  for (let c = i - 2; ; ) {
                    if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === c) break;
                    if (n = r, r = e[--i - 1], t >= r) break e;
                  }
                  a = i, i = 0;
                  break i;
                }
                break t;
              }
              for (; i < a; ) {
                const o = i + a >>> 1;
                t < e[o] ? a = o : i = o + 1;
              }
              if (n = e[i], r = e[i - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === void 0) return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
            }
            this._cachedIndex = i, this.intervalChanged_(i, r, n);
          }
          return this.interpolate_(i, r, t, n);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n;
          for (let a = 0; a !== n; ++a) e[a] = i[r + a];
          return e;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      class Jm extends wa {
        constructor(t, e, i, n) {
          super(t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Kr,
            endingEnd: Kr
          };
        }
        intervalChanged_(t, e, i) {
          const n = this.parameterPositions;
          let r = t - 2, a = t + 1, o = n[r], c = n[a];
          if (o === void 0) switch (this.getSettings_().endingStart) {
            case Jr:
              r = t, o = 2 * e - i;
              break;
            case Po:
              r = n.length - 2, o = e + n[r] - n[r + 1];
              break;
            default:
              r = t, o = i;
          }
          if (c === void 0) switch (this.getSettings_().endingEnd) {
            case Jr:
              a = t, c = 2 * i - e;
              break;
            case Po:
              a = 1, c = i + n[1] - n[0];
              break;
            default:
              a = t - 1, c = e;
          }
          const l = (i - e) * 0.5, h = this.valueSize;
          this._weightPrev = l / (e - o), this._weightNext = l / (c - i), this._offsetPrev = r * h, this._offsetNext = a * h;
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = this._offsetPrev, d = this._offsetNext, u = this._weightPrev, f = this._weightNext, p = (i - e) / (n - e), m = p * p, g = m * p, A = -u * g + 2 * u * m - u * p, x = (1 + u) * g + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1, b = (-1 - f) * g + (1.5 + f) * m + 0.5 * p, y = f * g - f * m;
          for (let M = 0; M !== o; ++M) r[M] = A * a[h + M] + x * a[l + M] + b * a[c + M] + y * a[d + M];
          return r;
        }
      }
      class Op extends wa {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = c - o, h = (i - e) / (n - e), d = 1 - h;
          for (let u = 0; u !== o; ++u) r[u] = a[l + u] * d + a[c + u] * h;
          return r;
        }
      }
      class Zm extends wa {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      }
      class en {
        constructor(t, e, i, n) {
          if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
          this.name = t, this.times = io(e, this.TimeBufferType), this.values = io(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
        }
        static toJSON(t) {
          const e = t.constructor;
          let i;
          if (e.toJSON !== this.toJSON) i = e.toJSON(t);
          else {
            i = {
              name: t.name,
              times: io(t.times, Array),
              values: io(t.values, Array)
            };
            const n = t.getInterpolation();
            n !== t.DefaultInterpolation && (i.interpolation = n);
          }
          return i.type = t.ValueTypeName, i;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new Zm(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
          return new Op(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
          return new Jm(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case Zs:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case $s:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case _c:
              e = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (e === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
            else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return this.createInterpolant = e, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Zs;
            case this.InterpolantFactoryMethodLinear:
              return $s;
            case this.InterpolantFactoryMethodSmooth:
              return _c;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (t !== 0) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
          }
          return this;
        }
        scale(t) {
          if (t !== 1) {
            const e = this.times;
            for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
          }
          return this;
        }
        trim(t, e) {
          const i = this.times, n = i.length;
          let r = 0, a = n - 1;
          for (; r !== n && i[r] < t; ) ++r;
          for (; a !== -1 && i[a] > e; ) --a;
          if (++a, r !== 0 || a !== n) {
            r >= a && (a = Math.max(a, 1), r = a - 1);
            const o = this.getValueSize();
            this.times = i.slice(r, a), this.values = this.values.slice(r * o, a * o);
          }
          return this;
        }
        validate() {
          let t = true;
          const e = this.getValueSize();
          e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
          const i = this.times, n = this.values, r = i.length;
          r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
          let a = null;
          for (let o = 0; o !== r; o++) {
            const c = i[o];
            if (typeof c == "number" && isNaN(c)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), t = false;
              break;
            }
            if (a !== null && a > c) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), t = false;
              break;
            }
            a = c;
          }
          if (n !== void 0 && Ym(n)) for (let o = 0, c = n.length; o !== c; ++o) {
            const l = n[o];
            if (isNaN(l)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), t = false;
              break;
            }
          }
          return t;
        }
        optimize() {
          const t = this.times.slice(), e = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === _c, r = t.length - 1;
          let a = 1;
          for (let o = 1; o < r; ++o) {
            let c = false;
            const l = t[o], h = t[o + 1];
            if (l !== h && (o !== 1 || l !== t[0])) if (n) c = true;
            else {
              const d = o * i, u = d - i, f = d + i;
              for (let p = 0; p !== i; ++p) {
                const m = e[d + p];
                if (m !== e[u + p] || m !== e[f + p]) {
                  c = true;
                  break;
                }
              }
            }
            if (c) {
              if (o !== a) {
                t[a] = t[o];
                const d = o * i, u = a * i;
                for (let f = 0; f !== i; ++f) e[u + f] = e[d + f];
              }
              ++a;
            }
          }
          if (r > 0) {
            t[a] = t[r];
            for (let o = r * i, c = a * i, l = 0; l !== i; ++l) e[c + l] = e[o + l];
            ++a;
          }
          return a !== t.length ? (this.times = t.slice(0, a), this.values = e.slice(0, a * i)) : (this.times = t, this.values = e), this;
        }
        clone() {
          const t = this.times.slice(), e = this.values.slice(), i = this.constructor, n = new i(this.name, t, e);
          return n.createInterpolant = this.createInterpolant, n;
        }
      }
      en.prototype.ValueTypeName = "";
      en.prototype.TimeBufferType = Float32Array;
      en.prototype.ValueBufferType = Float32Array;
      en.prototype.DefaultInterpolation = $s;
      class As extends en {
        constructor(t, e, i) {
          super(t, e, i);
        }
      }
      As.prototype.ValueTypeName = "bool";
      As.prototype.ValueBufferType = Array;
      As.prototype.DefaultInterpolation = Zs;
      As.prototype.InterpolantFactoryMethodLinear = void 0;
      As.prototype.InterpolantFactoryMethodSmooth = void 0;
      class zp extends en {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
      }
      zp.prototype.ValueTypeName = "color";
      class wr extends en {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
      }
      wr.prototype.ValueTypeName = "number";
      class $m extends wa {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (i - e) / (n - e);
          let l = t * o;
          for (let h = l + o; l !== h; l += 4) ue.slerpFlat(r, 0, a, l - o, a, l, c);
          return r;
        }
      }
      class Wn extends en {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        InterpolantFactoryMethodLinear(t) {
          return new $m(this.times, this.values, this.getValueSize(), t);
        }
      }
      Wn.prototype.ValueTypeName = "quaternion";
      Wn.prototype.InterpolantFactoryMethodSmooth = void 0;
      class gs extends en {
        constructor(t, e, i) {
          super(t, e, i);
        }
      }
      gs.prototype.ValueTypeName = "string";
      gs.prototype.ValueBufferType = Array;
      gs.prototype.DefaultInterpolation = Zs;
      gs.prototype.InterpolantFactoryMethodLinear = void 0;
      gs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class br extends en {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
      }
      br.prototype.ValueTypeName = "vector";
      class Qo {
        constructor(t = "", e = -1, i = [], n = Qh) {
          this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = $i(), this.duration < 0 && this.resetDuration();
        }
        static parse(t) {
          const e = [], i = t.tracks, n = 1 / (t.fps || 1);
          for (let a = 0, o = i.length; a !== o; ++a) e.push(ew(i[a]).scale(n));
          const r = new this(t.name, t.duration, e, t.blendMode);
          return r.uuid = t.uuid, r;
        }
        static toJSON(t) {
          const e = [], i = t.tracks, n = {
            name: t.name,
            duration: t.duration,
            tracks: e,
            uuid: t.uuid,
            blendMode: t.blendMode
          };
          for (let r = 0, a = i.length; r !== a; ++r) e.push(en.toJSON(i[r]));
          return n;
        }
        static CreateFromMorphTargetSequence(t, e, i, n) {
          const r = e.length, a = [];
          for (let o = 0; o < r; o++) {
            let c = [], l = [];
            c.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
            const h = Km(c);
            c = Tu(c, 1, h), l = Tu(l, 1, h), !n && c[0] === 0 && (c.push(r), l.push(l[0])), a.push(new wr(".morphTargetInfluences[" + e[o].name + "]", c, l).scale(1 / i));
          }
          return new this(t, -1, a);
        }
        static findByName(t, e) {
          let i = t;
          if (!Array.isArray(t)) {
            const n = t;
            i = n.geometry && n.geometry.animations || n.animations;
          }
          for (let n = 0; n < i.length; n++) if (i[n].name === e) return i[n];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t, e, i) {
          const n = {}, r = /^([\w-]*?)([\d]+)$/;
          for (let o = 0, c = t.length; o < c; o++) {
            const l = t[o], h = l.name.match(r);
            if (h && h.length > 1) {
              const d = h[1];
              let u = n[d];
              u || (n[d] = u = []), u.push(l);
            }
          }
          const a = [];
          for (const o in n) a.push(this.CreateFromMorphTargetSequence(o, n[o], e, i));
          return a;
        }
        static parseAnimation(t, e) {
          if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i = function(d, u, f, p, m) {
            if (f.length !== 0) {
              const g = [], A = [];
              Qp(f, g, A, p), g.length !== 0 && m.push(new d(u, g, A));
            }
          }, n = [], r = t.name || "default", a = t.fps || 30, o = t.blendMode;
          let c = t.length || -1;
          const l = t.hierarchy || [];
          for (let d = 0; d < l.length; d++) {
            const u = l[d].keys;
            if (!(!u || u.length === 0)) if (u[0].morphTargets) {
              const f = {};
              let p;
              for (p = 0; p < u.length; p++) if (u[p].morphTargets) for (let m = 0; m < u[p].morphTargets.length; m++) f[u[p].morphTargets[m]] = -1;
              for (const m in f) {
                const g = [], A = [];
                for (let x = 0; x !== u[p].morphTargets.length; ++x) {
                  const b = u[p];
                  g.push(b.time), A.push(b.morphTarget === m ? 1 : 0);
                }
                n.push(new wr(".morphTargetInfluence[" + m + "]", g, A));
              }
              c = f.length * a;
            } else {
              const f = ".bones[" + e[d].name + "]";
              i(br, f + ".position", u, "pos", n), i(Wn, f + ".quaternion", u, "rot", n), i(br, f + ".scale", u, "scl", n);
            }
          }
          return n.length === 0 ? null : new this(r, c, n, o);
        }
        resetDuration() {
          const t = this.tracks;
          let e = 0;
          for (let i = 0, n = t.length; i !== n; ++i) {
            const r = this.tracks[i];
            e = Math.max(e, r.times[r.times.length - 1]);
          }
          return this.duration = e, this;
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
          return this;
        }
        validate() {
          let t = true;
          for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
          return t;
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
          return this;
        }
        clone() {
          const t = [];
          for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
          return new this.constructor(this.name, this.duration, t, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function tw(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return wr;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return br;
          case "color":
            return zp;
          case "quaternion":
            return Wn;
          case "bool":
          case "boolean":
            return As;
          case "string":
            return gs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function ew(s) {
        if (s.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t = tw(s.type);
        if (s.times === void 0) {
          const e = [], i = [];
          Qp(s.keys, e, i, "value"), s.times = e, s.values = i;
        }
        return t.parse !== void 0 ? t.parse(s) : new t(s.name, s.times, s.values, s.interpolation);
      }
      const Gn = {
        enabled: false,
        files: {},
        add: function(s, t) {
          this.enabled !== false && (this.files[s] = t);
        },
        get: function(s) {
          if (this.enabled !== false) return this.files[s];
        },
        remove: function(s) {
          delete this.files[s];
        },
        clear: function() {
          this.files = {};
        }
      };
      class Gp {
        constructor(t, e, i) {
          const n = this;
          let r = false, a = 0, o = 0, c;
          const l = [];
          this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(h) {
            o++, r === false && n.onStart !== void 0 && n.onStart(h, a, o), r = true;
          }, this.itemEnd = function(h) {
            a++, n.onProgress !== void 0 && n.onProgress(h, a, o), a === o && (r = false, n.onLoad !== void 0 && n.onLoad());
          }, this.itemError = function(h) {
            n.onError !== void 0 && n.onError(h);
          }, this.resolveURL = function(h) {
            return c ? c(h) : h;
          }, this.setURLModifier = function(h) {
            return c = h, this;
          }, this.addHandler = function(h, d) {
            return l.push(h, d), this;
          }, this.removeHandler = function(h) {
            const d = l.indexOf(h);
            return d !== -1 && l.splice(d, 2), this;
          }, this.getHandler = function(h) {
            for (let d = 0, u = l.length; d < u; d += 2) {
              const f = l[d], p = l[d + 1];
              if (f.global && (f.lastIndex = 0), f.test(h)) return p;
            }
            return null;
          };
        }
      }
      const iw = new Gp();
      class Ui {
        constructor(t) {
          this.manager = t !== void 0 ? t : iw, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(t, e) {
          const i = this;
          return new Promise(function(n, r) {
            i.load(t, n, e, r);
          });
        }
        parse() {
        }
        setCrossOrigin(t) {
          return this.crossOrigin = t, this;
        }
        setWithCredentials(t) {
          return this.withCredentials = t, this;
        }
        setPath(t) {
          return this.path = t, this;
        }
        setResourcePath(t) {
          return this.resourcePath = t, this;
        }
        setRequestHeader(t) {
          return this.requestHeader = t, this;
        }
      }
      Ui.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const _n = {};
      class nw extends Error {
        constructor(t, e) {
          super(t), this.response = e;
        }
      }
      class Ar extends Ui {
        constructor(t) {
          super(t), this.mimeType = "", this.responseType = "";
        }
        load(t, e, i, n) {
          t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
          const r = Gn.get(t);
          if (r !== void 0) return this.manager.itemStart(t), setTimeout(() => {
            e && e(r), this.manager.itemEnd(t);
          }, 0), r;
          if (_n[t] !== void 0) {
            _n[t].push({
              onLoad: e,
              onProgress: i,
              onError: n
            });
            return;
          }
          _n[t] = [], _n[t].push({
            onLoad: e,
            onProgress: i,
            onError: n
          });
          const a = new Request(t, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          }), o = this.mimeType, c = this.responseType;
          fetch(a).then((l) => {
            if (l.status === 200 || l.status === 0) {
              if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
              const h = _n[t], d = l.body.getReader(), u = l.headers.get("X-File-Size") || l.headers.get("Content-Length"), f = u ? parseInt(u) : 0, p = f !== 0;
              let m = 0;
              const g = new ReadableStream({
                start(A) {
                  x();
                  function x() {
                    d.read().then(({ done: b, value: y }) => {
                      if (b) A.close();
                      else {
                        m += y.byteLength;
                        const M = new ProgressEvent("progress", {
                          lengthComputable: p,
                          loaded: m,
                          total: f
                        });
                        for (let T = 0, R = h.length; T < R; T++) {
                          const B = h[T];
                          B.onProgress && B.onProgress(M);
                        }
                        A.enqueue(y), x();
                      }
                    }, (b) => {
                      A.error(b);
                    });
                  }
                }
              });
              return new Response(g);
            } else throw new nw(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
          }).then((l) => {
            switch (c) {
              case "arraybuffer":
                return l.arrayBuffer();
              case "blob":
                return l.blob();
              case "document":
                return l.text().then((h) => new DOMParser().parseFromString(h, o));
              case "json":
                return l.json();
              default:
                if (o === "") return l.text();
                {
                  const d = /charset="?([^;"\s]*)"?/i.exec(o), u = d && d[1] ? d[1].toLowerCase() : void 0, f = new TextDecoder(u);
                  return l.arrayBuffer().then((p) => f.decode(p));
                }
            }
          }).then((l) => {
            Gn.add(t, l);
            const h = _n[t];
            delete _n[t];
            for (let d = 0, u = h.length; d < u; d++) {
              const f = h[d];
              f.onLoad && f.onLoad(l);
            }
          }).catch((l) => {
            const h = _n[t];
            if (h === void 0) throw this.manager.itemError(t), l;
            delete _n[t];
            for (let d = 0, u = h.length; d < u; d++) {
              const f = h[d];
              f.onError && f.onError(l);
            }
            this.manager.itemError(t);
          }).finally(() => {
            this.manager.itemEnd(t);
          }), this.manager.itemStart(t);
        }
        setResponseType(t) {
          return this.responseType = t, this;
        }
        setMimeType(t) {
          return this.mimeType = t, this;
        }
      }
      class Hp extends Ui {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
          const r = this, a = Gn.get(t);
          if (a !== void 0) return r.manager.itemStart(t), setTimeout(function() {
            e && e(a), r.manager.itemEnd(t);
          }, 0), a;
          const o = ta("img");
          function c() {
            h(), Gn.add(t, this), e && e(this), r.manager.itemEnd(t);
          }
          function l(d) {
            h(), n && n(d), r.manager.itemError(t), r.manager.itemEnd(t);
          }
          function h() {
            o.removeEventListener("load", c, false), o.removeEventListener("error", l, false);
          }
          return o.addEventListener("load", c, false), o.addEventListener("error", l, false), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o;
        }
      }
      class rw extends Ui {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = new Hh();
          r.colorSpace = ne;
          const a = new Hp(this.manager);
          a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
          let o = 0;
          function c(l) {
            a.load(t[l], function(h) {
              r.images[l] = h, o++, o === 6 && (r.needsUpdate = true, e && e(r));
            }, void 0, n);
          }
          for (let l = 0; l < t.length; ++l) c(l);
          return r;
        }
      }
      class hi extends Ui {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = new Pe(), a = new Hp(this.manager);
          return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(o) {
            r.image = o, r.needsUpdate = true, e !== void 0 && e(r);
          }, i, n), r;
        }
      }
      class tc extends ce {
        constructor(t, e = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new ht(t), this.intensity = e;
        }
        dispose() {
        }
        copy(t, e) {
          return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
        }
      }
      const jc = new ft(), Ru = new I(), Bu = new I();
      class td {
        constructor(t) {
          this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new rt(512, 512), this.map = null, this.mapPass = null, this.matrix = new ft(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new jh(), this._frameExtents = new rt(1, 1), this._viewportCount = 1, this._viewports = [
            new jt(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera, i = this.matrix;
          Ru.setFromMatrixPosition(t.matrixWorld), e.position.copy(Ru), Bu.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Bu), e.updateMatrixWorld(), jc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(jc), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(jc);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
        }
      }
      class sw extends td {
        constructor() {
          super(new Ve(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
        }
        updateMatrices(t) {
          const e = this.camera, i = os * 2 * t.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = t.distance || e.far;
          (i !== e.fov || n !== e.aspect || r !== e.far) && (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t);
        }
        copy(t) {
          return super.copy(t), this.focus = t.focus, this;
        }
      }
      class Vp extends tc {
        constructor(t, e, i = 0, n = Math.PI / 3, r = 0, a = 2) {
          super(t, e), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(ce.DEFAULT_UP), this.updateMatrix(), this.target = new ce(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new sw();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t) {
          this.intensity = t / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
        }
      }
      const Du = new ft(), Rs = new I(), qc = new I();
      class aw extends td {
        constructor() {
          super(new Ve(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new rt(4, 2), this._viewportCount = 6, this._viewports = [
            new jt(2, 1, 1, 1),
            new jt(0, 1, 1, 1),
            new jt(3, 1, 1, 1),
            new jt(1, 1, 1, 1),
            new jt(3, 0, 1, 1),
            new jt(1, 0, 1, 1)
          ], this._cubeDirections = [
            new I(1, 0, 0),
            new I(-1, 0, 0),
            new I(0, 0, 1),
            new I(0, 0, -1),
            new I(0, 1, 0),
            new I(0, -1, 0)
          ], this._cubeUps = [
            new I(0, 1, 0),
            new I(0, 1, 0),
            new I(0, 1, 0),
            new I(0, 1, 0),
            new I(0, 0, 1),
            new I(0, 0, -1)
          ];
        }
        updateMatrices(t, e = 0) {
          const i = this.camera, n = this.matrix, r = t.distance || i.far;
          r !== i.far && (i.far = r, i.updateProjectionMatrix()), Rs.setFromMatrixPosition(t.matrixWorld), i.position.copy(Rs), qc.copy(i.position), qc.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(qc), i.updateMatrixWorld(), n.makeTranslation(-Rs.x, -Rs.y, -Rs.z), Du.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Du);
        }
      }
      class lh extends tc {
        constructor(t, e, i = 0, n = 2) {
          super(t, e), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new aw();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
        }
      }
      class ed extends ko {
        constructor(t = -1, e = 1, i = 1, n = -1, r = 0.1, a = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(t, e) {
          return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
        }
        setViewOffset(t, e, i, n, r, a) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
          let r = i - t, a = i + t, o = n + e, c = n - e;
          if (this.view !== null && this.view.enabled) {
            const l = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += l * this.view.offsetX, a = r + l * this.view.width, o -= h * this.view.offsetY, c = o - h * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
        }
      }
      class ow extends td {
        constructor() {
          super(new ed(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      let ec = class extends tc {
        constructor(t, e) {
          super(t, e), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(ce.DEFAULT_UP), this.updateMatrix(), this.target = new ce(), this.shadow = new ow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
        }
      };
      class id extends tc {
        constructor(t, e) {
          super(t, e), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class ns {
        static extractUrlBase(t) {
          const e = t.lastIndexOf("/");
          return e === -1 ? "./" : t.slice(0, e + 1);
        }
        static resolveURL(t, e) {
          return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
        }
      }
      class cw extends Fe {
        constructor() {
          super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(t) {
          return super.copy(t), this.instanceCount = t.instanceCount, this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = true, t;
        }
      }
      class lw extends Ui {
        constructor(t) {
          super(t), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(t) {
          return this.options = t, this;
        }
        load(t, e, i, n) {
          t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
          const r = this, a = Gn.get(t);
          if (a !== void 0) {
            if (r.manager.itemStart(t), a.then) {
              a.then((l) => {
                e && e(l), r.manager.itemEnd(t);
              }).catch((l) => {
                n && n(l);
              });
              return;
            }
            return setTimeout(function() {
              e && e(a), r.manager.itemEnd(t);
            }, 0), a;
          }
          const o = {};
          o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
          const c = fetch(t, o).then(function(l) {
            return l.blob();
          }).then(function(l) {
            return createImageBitmap(l, Object.assign(r.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(l) {
            return Gn.add(t, l), e && e(l), r.manager.itemEnd(t), l;
          }).catch(function(l) {
            n && n(l), Gn.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
          });
          Gn.add(t, c), r.manager.itemStart(t);
        }
      }
      let no;
      class Wp {
        static getContext() {
          return no === void 0 && (no = new (window.AudioContext || window.webkitAudioContext)()), no;
        }
        static setContext(t) {
          no = t;
        }
      }
      class hw extends Ui {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = this, a = new Ar(this.manager);
          a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(c) {
            try {
              const l = c.slice(0);
              Wp.getContext().decodeAudioData(l, function(d) {
                e(d);
              }).catch(o);
            } catch (l) {
              o(l);
            }
          }, i, n);
          function o(c) {
            n ? n(c) : console.error(c), r.manager.itemError(t);
          }
        }
      }
      class dw extends Ve {
        constructor(t = []) {
          super(), this.isArrayCamera = true, this.cameras = t, this.index = 0;
        }
      }
      class jp {
        constructor(t = true) {
          this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = Pu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e = Pu();
            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
          }
          return t;
        }
      }
      function Pu() {
        return performance.now();
      }
      const er = new I(), Fu = new ue(), uw = new I(), ir = new I();
      class fw extends ce {
        constructor() {
          super(), this.type = "AudioListener", this.context = Wp.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new jp();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(t) {
          return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(t) {
          return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t);
          const e = this.context.listener, i = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(er, Fu, uw), ir.set(0, 0, -1).applyQuaternion(Fu), e.positionX) {
            const n = this.context.currentTime + this.timeDelta;
            e.positionX.linearRampToValueAtTime(er.x, n), e.positionY.linearRampToValueAtTime(er.y, n), e.positionZ.linearRampToValueAtTime(er.z, n), e.forwardX.linearRampToValueAtTime(ir.x, n), e.forwardY.linearRampToValueAtTime(ir.y, n), e.forwardZ.linearRampToValueAtTime(ir.z, n), e.upX.linearRampToValueAtTime(i.x, n), e.upY.linearRampToValueAtTime(i.y, n), e.upZ.linearRampToValueAtTime(i.z, n);
          } else e.setPosition(er.x, er.y, er.z), e.setOrientation(ir.x, ir.y, ir.z, i.x, i.y, i.z);
        }
      }
      let Di = class extends ce {
        constructor(t) {
          super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t, this.connect(), this;
        }
        setMediaElementSource(t) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
        }
        setMediaStreamSource(t) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
        }
        setBuffer(t) {
          return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(t = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + t;
          const e = this.context.createBufferSource();
          return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
        }
        stop(t = 0) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + t), this.source.onended = null), this.isPlaying = false, this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this._connected = true, this;
        }
        disconnect() {
          if (this._connected !== false) {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this._connected = false, this;
          }
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t) {
          return t || (t = []), this._connected === true ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
        }
        setDetune(t) {
          return this.detune = t, this.isPlaying === true && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t) {
          return this.setFilters(t ? [
            t
          ] : []);
        }
        setPlaybackRate(t) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.playbackRate = t, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false, this._progress = 0;
        }
        getLoop() {
          return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }
        setLoop(t) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.loop = t, this.isPlaying === true && (this.source.loop = this.loop), this;
        }
        setLoopStart(t) {
          return this.loopStart = t, this;
        }
        setLoopEnd(t) {
          return this.loopEnd = t, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t) {
          return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
        }
        copy(t, e) {
          return super.copy(t, e), t.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = t.autoplay, this.buffer = t.buffer, this.detune = t.detune, this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this.offset = t.offset, this.duration = t.duration, this.playbackRate = t.playbackRate, this.hasPlaybackControl = t.hasPlaybackControl, this.sourceType = t.sourceType, this.filters = t.filters.slice(), this);
        }
        clone(t) {
          return new this.constructor(this.listener).copy(this, t);
        }
      };
      const nr = new I(), Lu = new ue(), pw = new I(), rr = new I();
      class Xc extends Di {
        constructor(t) {
          super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        connect() {
          return super.connect(), this.panner.connect(this.gain), this;
        }
        disconnect() {
          return super.disconnect(), this.panner.disconnect(this.gain), this;
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(t) {
          return this.panner.refDistance = t, this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(t) {
          return this.panner.rolloffFactor = t, this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(t) {
          return this.panner.distanceModel = t, this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(t) {
          return this.panner.maxDistance = t, this;
        }
        setDirectionalCone(t, e, i) {
          return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this;
        }
        updateMatrixWorld(t) {
          if (super.updateMatrixWorld(t), this.hasPlaybackControl === true && this.isPlaying === false) return;
          this.matrixWorld.decompose(nr, Lu, pw), rr.set(0, 0, 1).applyQuaternion(Lu);
          const e = this.panner;
          if (e.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(nr.x, i), e.positionY.linearRampToValueAtTime(nr.y, i), e.positionZ.linearRampToValueAtTime(nr.z, i), e.orientationX.linearRampToValueAtTime(rr.x, i), e.orientationY.linearRampToValueAtTime(rr.y, i), e.orientationZ.linearRampToValueAtTime(rr.z, i);
          } else e.setPosition(nr.x, nr.y, nr.z), e.setOrientation(rr.x, rr.y, rr.z);
        }
      }
      class Aw {
        constructor(t, e, i) {
          this.binding = t, this.valueSize = i;
          let n, r, a;
          switch (e) {
            case "quaternion":
              n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
              break;
            default:
              n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
          }
          this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(t, e) {
          const i = this.buffer, n = this.valueSize, r = t * n + n;
          let a = this.cumulativeWeight;
          if (a === 0) {
            for (let o = 0; o !== n; ++o) i[r + o] = i[o];
            a = e;
          } else {
            a += e;
            const o = e / a;
            this._mixBufferRegion(i, r, 0, o, n);
          }
          this.cumulativeWeight = a;
        }
        accumulateAdditive(t) {
          const e = this.buffer, i = this.valueSize, n = i * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t;
        }
        apply(t) {
          const e = this.valueSize, i = this.buffer, n = t * e + e, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
            const c = e * this._origIndex;
            this._mixBufferRegion(i, n, c, 1 - r, e);
          }
          a > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
          for (let c = e, l = e + e; c !== l; ++c) if (i[c] !== i[c + e]) {
            o.setValue(i, n);
            break;
          }
        }
        saveOriginalState() {
          const t = this.binding, e = this.buffer, i = this.valueSize, n = i * this._origIndex;
          t.getValue(e, n);
          for (let r = i, a = n; r !== a; ++r) e[r] = e[n + r % i];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const t = this.valueSize * 3;
          this.binding.setValue(this.buffer, t);
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize, e = t + this.valueSize;
          for (let i = t; i < e; i++) this.buffer[i] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i];
        }
        _select(t, e, i, n, r) {
          if (n >= 0.5) for (let a = 0; a !== r; ++a) t[e + a] = t[i + a];
        }
        _slerp(t, e, i, n) {
          ue.slerpFlat(t, e, t, e, t, i, n);
        }
        _slerpAdditive(t, e, i, n, r) {
          const a = this._workIndex * r;
          ue.multiplyQuaternionsFlat(t, a, t, e, t, i), ue.slerpFlat(t, e, t, e, t, a, n);
        }
        _lerp(t, e, i, n, r) {
          const a = 1 - n;
          for (let o = 0; o !== r; ++o) {
            const c = e + o;
            t[c] = t[c] * a + t[i + o] * n;
          }
        }
        _lerpAdditive(t, e, i, n, r) {
          for (let a = 0; a !== r; ++a) {
            const o = e + a;
            t[o] = t[o] + t[i + a] * n;
          }
        }
      }
      const nd = "\\[\\]\\.:\\/", gw = new RegExp("[" + nd + "]", "g"), rd = "[^" + nd + "]", _w = "[^" + nd.replace("\\.", "") + "]", mw = /((?:WC+[\/:])*)/.source.replace("WC", rd), ww = /(WCOD+)?/.source.replace("WCOD", _w), bw = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rd), yw = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rd), xw = new RegExp("^" + mw + ww + bw + yw + "$"), vw = [
        "material",
        "materials",
        "bones",
        "map"
      ];
      class Ew {
        constructor(t, e, i) {
          const n = i || ee.parseTrackName(e);
          this._targetGroup = t, this._bindings = t.subscribe_(e, n);
        }
        getValue(t, e) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
          n !== void 0 && n.getValue(t, e);
        }
        setValue(t, e) {
          const i = this._bindings;
          for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e);
        }
        bind() {
          const t = this._bindings;
          for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind();
        }
        unbind() {
          const t = this._bindings;
          for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind();
        }
      }
      class ee {
        constructor(t, e, i) {
          this.path = e, this.parsedPath = i || ee.parseTrackName(e), this.node = ee.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(t, e, i) {
          return t && t.isAnimationObjectGroup ? new ee.Composite(t, e, i) : new ee(t, e, i);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(gw, "");
        }
        static parseTrackName(t) {
          const e = xw.exec(t);
          if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const i = {
            nodeName: e[2],
            objectName: e[3],
            objectIndex: e[4],
            propertyName: e[5],
            propertyIndex: e[6]
          }, n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (n !== void 0 && n !== -1) {
            const r = i.nodeName.substring(n + 1);
            vw.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r);
          }
          if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
          return i;
        }
        static findNode(t, e) {
          if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
          if (t.skeleton) {
            const i = t.skeleton.getBoneByName(e);
            if (i !== void 0) return i;
          }
          if (t.children) {
            const i = function(r) {
              for (let a = 0; a < r.length; a++) {
                const o = r[a];
                if (o.name === e || o.uuid === e) return o;
                const c = i(o.children);
                if (c) return c;
              }
              return null;
            }, n = i(t.children);
            if (n) return n;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node;
          const e = this.parsedPath, i = e.objectName, n = e.propertyName;
          let r = e.propertyIndex;
          if (t || (t = ee.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return;
          }
          if (i) {
            let l = e.objectIndex;
            switch (i) {
              case "materials":
                if (!t.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!t.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                t = t.skeleton.bones;
                for (let h = 0; h < t.length; h++) if (t[h].name === l) {
                  l = h;
                  break;
                }
                break;
              case "map":
                if ("map" in t) {
                  t = t.map;
                  break;
                }
                if (!t.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!t.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                t = t.material.map;
                break;
              default:
                if (t[i] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                t = t[i];
            }
            if (l !== void 0) {
              if (t[l] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                return;
              }
              t = t[l];
            }
          }
          const a = t[n];
          if (a === void 0) {
            const l = e.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + n + " but it wasn't found.", t);
            return;
          }
          let o = this.Versioning.None;
          this.targetObject = t, t.isMaterial === true ? o = this.Versioning.NeedsUpdate : t.isObject3D === true && (o = this.Versioning.MatrixWorldNeedsUpdate);
          let c = this.BindingType.Direct;
          if (r !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!t.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!t.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              t.morphTargetDictionary[r] !== void 0 && (r = t.morphTargetDictionary[r]);
            }
            c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
          } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      ee.Composite = Ew;
      ee.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      ee.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      ee.prototype.GetterByBindingType = [
        ee.prototype._getValue_direct,
        ee.prototype._getValue_array,
        ee.prototype._getValue_arrayElement,
        ee.prototype._getValue_toArray
      ];
      ee.prototype.SetterByBindingTypeAndVersioning = [
        [
          ee.prototype._setValue_direct,
          ee.prototype._setValue_direct_setNeedsUpdate,
          ee.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          ee.prototype._setValue_array,
          ee.prototype._setValue_array_setNeedsUpdate,
          ee.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          ee.prototype._setValue_arrayElement,
          ee.prototype._setValue_arrayElement_setNeedsUpdate,
          ee.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          ee.prototype._setValue_fromArray,
          ee.prototype._setValue_fromArray_setNeedsUpdate,
          ee.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      class Sw {
        constructor(t, e, i = null, n = e.blendMode) {
          this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
          const r = e.tracks, a = r.length, o = new Array(a), c = {
            endingStart: Kr,
            endingEnd: Kr
          };
          for (let l = 0; l !== a; ++l) {
            const h = r[l].createInterpolant(null);
            o[l] = h, h.settings = c;
          }
          this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = e_, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t) {
          return this._startTime = t, this;
        }
        setLoop(t, e) {
          return this.loop = t, this.repetitions = e, this;
        }
        setEffectiveWeight(t) {
          return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1);
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0);
        }
        crossFadeFrom(t, e, i = false) {
          if (t.fadeOut(e), this.fadeIn(e), i === true) {
            const n = this._clip.duration, r = t._clip.duration, a = r / n, o = n / r;
            t.warp(1, a, e), this.warp(o, 1, e);
          }
          return this;
        }
        crossFadeTo(t, e, i = false) {
          return t.crossFadeFrom(this, e, i);
        }
        stopFading() {
          const t = this._weightInterpolant;
          return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
        }
        setEffectiveTimeScale(t) {
          return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t) {
          return this.timeScale = this._clip.duration / t, this.stopWarping();
        }
        syncWith(t) {
          return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        }
        warp(t, e, i) {
          const n = this._mixer, r = n.time, a = this.timeScale;
          let o = this._timeScaleInterpolant;
          o === null && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
          const c = o.parameterPositions, l = o.sampleValues;
          return c[0] = r, c[1] = r + i, l[0] = t / a, l[1] = e / a, this;
        }
        stopWarping() {
          const t = this._timeScaleInterpolant;
          return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t, e, i, n) {
          if (!this.enabled) {
            this._updateWeight(t);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const c = (t - r) * i;
            c < 0 || i === 0 ? e = 0 : (this._startTime = null, e = i * c);
          }
          e *= this._updateTimeScale(t);
          const a = this._updateTime(e), o = this._updateWeight(t);
          if (o > 0) {
            const c = this._interpolants, l = this._propertyBindings;
            switch (this.blendMode) {
              case n_:
                for (let h = 0, d = c.length; h !== d; ++h) c[h].evaluate(a), l[h].accumulateAdditive(o);
                break;
              case Qh:
              default:
                for (let h = 0, d = c.length; h !== d; ++h) c[h].evaluate(a), l[h].accumulate(n, o);
            }
          }
        }
        _updateWeight(t) {
          let e = 0;
          if (this.enabled) {
            e = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
              const n = i.evaluate(t)[0];
              e *= n, t > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = e, e;
        }
        _updateTimeScale(t) {
          let e = 0;
          if (!this.paused) {
            e = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
              const n = i.evaluate(t)[0];
              e *= n, t > i.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = true : this.timeScale = e);
            }
          }
          return this._effectiveTimeScale = e, e;
        }
        _updateTime(t) {
          const e = this._clip.duration, i = this.loop;
          let n = this.time + t, r = this._loopCount;
          const a = i === i_;
          if (t === 0) return r === -1 ? n : a && (r & 1) === 1 ? e - n : n;
          if (i === Yo) {
            r === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
            t: {
              if (n >= e) n = e;
              else if (n < 0) n = 0;
              else {
                this.time = n;
                break t;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: t < 0 ? -1 : 1
              });
            }
          } else {
            if (r === -1 && (t >= 0 ? (r = 0, this._setEndings(true, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, true, a)), n >= e || n < 0) {
              const o = Math.floor(n / e);
              n -= e * o, r += Math.abs(o);
              const c = this.repetitions - r;
              if (c <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: t > 0 ? 1 : -1
              });
              else {
                if (c === 1) {
                  const l = t < 0;
                  this._setEndings(l, !l, a);
                } else this._setEndings(false, false, a);
                this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: o
                });
              }
            } else this.time = n;
            if (a && (r & 1) === 1) return e - n;
          }
          return n;
        }
        _setEndings(t, e, i) {
          const n = this._interpolantSettings;
          i ? (n.endingStart = Jr, n.endingEnd = Jr) : (t ? n.endingStart = this.zeroSlopeAtStart ? Jr : Kr : n.endingStart = Po, e ? n.endingEnd = this.zeroSlopeAtEnd ? Jr : Kr : n.endingEnd = Po);
        }
        _scheduleFading(t, e, i) {
          const n = this._mixer, r = n.time;
          let a = this._weightInterpolant;
          a === null && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
          const o = a.parameterPositions, c = a.sampleValues;
          return o[0] = r, c[0] = e, o[1] = r + t, c[1] = i, this;
        }
      }
      const Cw = new Float32Array(1);
      class qp extends Xn {
        constructor(t) {
          super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(t, e) {
          const i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, a = t._propertyBindings, o = t._interpolants, c = i.uuid, l = this._bindingsByRootAndName;
          let h = l[c];
          h === void 0 && (h = {}, l[c] = h);
          for (let d = 0; d !== r; ++d) {
            const u = n[d], f = u.name;
            let p = h[f];
            if (p !== void 0) ++p.referenceCount, a[d] = p;
            else {
              if (p = a[d], p !== void 0) {
                p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, c, f));
                continue;
              }
              const m = e && e._propertyBindings[d].binding.parsedPath;
              p = new Aw(ee.create(i, f, m), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, c, f), a[d] = p;
            }
            o[d].resultBuffer = p.buffer;
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (t._cacheIndex === null) {
              const i = (t._localRoot || this._root).uuid, n = t._clip.uuid, r = this._actionsByClip[n];
              this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, i);
            }
            const e = t._propertyBindings;
            for (let i = 0, n = e.length; i !== n; ++i) {
              const r = e[i];
              r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(t);
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings;
            for (let i = 0, n = e.length; i !== n; ++i) {
              const r = e[i];
              --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(t);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(t) {
          const e = t._cacheIndex;
          return e !== null && e < this._nActiveActions;
        }
        _addInactiveAction(t, e, i) {
          const n = this._actions, r = this._actionsByClip;
          let a = r[e];
          if (a === void 0) a = {
            knownActions: [
              t
            ],
            actionByRoot: {}
          }, t._byClipCacheIndex = 0, r[e] = a;
          else {
            const o = a.knownActions;
            t._byClipCacheIndex = o.length, o.push(t);
          }
          t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t;
        }
        _removeInactiveAction(t) {
          const e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
          i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
          const r = t._clip.uuid, a = this._actionsByClip, o = a[r], c = o.knownActions, l = c[c.length - 1], h = t._byClipCacheIndex;
          l._byClipCacheIndex = h, c[h] = l, c.pop(), t._byClipCacheIndex = null;
          const d = o.actionByRoot, u = (t._localRoot || this._root).uuid;
          delete d[u], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(t);
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings;
          for (let i = 0, n = e.length; i !== n; ++i) {
            const r = e[i];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(t) {
          const e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n];
          t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
        }
        _takeBackAction(t) {
          const e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n];
          t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
        }
        _addInactiveBinding(t, e, i) {
          const n = this._bindingsByRootAndName, r = this._bindings;
          let a = n[e];
          a === void 0 && (a = {}, n[e] = a), a[i] = t, t._cacheIndex = r.length, r.push(t);
        }
        _removeInactiveBinding(t) {
          const e = this._bindings, i = t.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, o = a[n], c = e[e.length - 1], l = t._cacheIndex;
          c._cacheIndex = l, e[l] = c, e.pop(), delete o[r], Object.keys(o).length === 0 && delete a[n];
        }
        _lendBinding(t) {
          const e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n];
          t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
        }
        _takeBackBinding(t) {
          const e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n];
          t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r;
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
          let i = t[e];
          return i === void 0 && (i = new Op(new Float32Array(2), new Float32Array(2), 1, Cw), i.__cacheIndex = e, t[e] = i), i;
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
          t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r;
        }
        clipAction(t, e, i) {
          const n = e || this._root, r = n.uuid;
          let a = typeof t == "string" ? Qo.findByName(n, t) : t;
          const o = a !== null ? a.uuid : t, c = this._actionsByClip[o];
          let l = null;
          if (i === void 0 && (a !== null ? i = a.blendMode : i = Qh), c !== void 0) {
            const d = c.actionByRoot[r];
            if (d !== void 0 && d.blendMode === i) return d;
            l = c.knownActions[0], a === null && (a = l._clip);
          }
          if (a === null) return null;
          const h = new Sw(this, a, e, i);
          return this._bindAction(h, l), this._addInactiveAction(h, o, r), h;
        }
        existingAction(t, e) {
          const i = e || this._root, n = i.uuid, r = typeof t == "string" ? Qo.findByName(i, t) : t, a = r ? r.uuid : t, o = this._actionsByClip[a];
          return o !== void 0 && o.actionByRoot[n] || null;
        }
        stopAllAction() {
          const t = this._actions, e = this._nActiveActions;
          for (let i = e - 1; i >= 0; --i) t[i].stop();
          return this;
        }
        update(t) {
          t *= this.timeScale;
          const e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1;
          for (let l = 0; l !== i; ++l) e[l]._update(n, t, r, a);
          const o = this._bindings, c = this._nActiveBindings;
          for (let l = 0; l !== c; ++l) o[l].apply(a);
          return this;
        }
        setTime(t) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
          return this.update(t);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t) {
          const e = this._actions, i = t.uuid, n = this._actionsByClip, r = n[i];
          if (r !== void 0) {
            const a = r.knownActions;
            for (let o = 0, c = a.length; o !== c; ++o) {
              const l = a[o];
              this._deactivateAction(l);
              const h = l._cacheIndex, d = e[e.length - 1];
              l._cacheIndex = null, l._byClipCacheIndex = null, d._cacheIndex = h, e[h] = d, e.pop(), this._removeInactiveBindingsForAction(l);
            }
            delete n[i];
          }
        }
        uncacheRoot(t) {
          const e = t.uuid, i = this._actionsByClip;
          for (const a in i) {
            const o = i[a].actionByRoot, c = o[e];
            c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
          }
          const n = this._bindingsByRootAndName, r = n[e];
          if (r !== void 0) for (const a in r) {
            const o = r[a];
            o.restoreOriginalState(), this._removeInactiveBinding(o);
          }
        }
        uncacheAction(t, e) {
          const i = this.existingAction(t, e);
          i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
        }
      }
      const ku = new ft();
      class Xp {
        constructor(t, e, i = 0, n = 1 / 0) {
          this.ray = new fs(t, e), this.near = i, this.far = n, this.camera = null, this.layers = new Gh(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(t, e) {
          this.ray.set(t, e);
        }
        setFromCamera(t, e) {
          e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
        }
        setFromXRController(t) {
          return ku.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(ku), this;
        }
        intersectObject(t, e = true, i = []) {
          return hh(t, this, i, e), i.sort(Nu), i;
        }
        intersectObjects(t, e = true, i = []) {
          for (let n = 0, r = t.length; n < r; n++) hh(t[n], this, i, e);
          return i.sort(Nu), i;
        }
      }
      function Nu(s, t) {
        return s.distance - t.distance;
      }
      function hh(s, t, e, i) {
        let n = true;
        if (s.layers.test(t.layers) && s.raycast(t, e) === false && (n = false), n === true && i === true) {
          const r = s.children;
          for (let a = 0, o = r.length; a < o; a++) hh(r[a], t, e, true);
        }
      }
      class Uu {
        constructor(t = 1, e = 0, i = 0) {
          this.radius = t, this.phi = e, this.theta = i;
        }
        set(t, e, i) {
          return this.radius = t, this.phi = e, this.theta = i, this;
        }
        copy(t) {
          return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
        }
        makeSafe() {
          return this.phi = Ht(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, i) {
          return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Ht(e / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Un = new I(), ro = new ft(), Yc = new ft();
      class Iw extends Cp {
        constructor(t) {
          const e = Yp(t), i = new Fe(), n = [], r = [], a = new ht(0, 0, 1), o = new ht(0, 1, 0);
          for (let l = 0; l < e.length; l++) {
            const h = e[l];
            h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
          }
          i.setAttribute("position", new le(n, 3)), i.setAttribute("color", new le(r, 3));
          const c = new ma({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(i, c), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(t) {
          const e = this.bones, i = this.geometry, n = i.getAttribute("position");
          Yc.copy(this.root.matrixWorld).invert();
          for (let r = 0, a = 0; r < e.length; r++) {
            const o = e[r];
            o.parent && o.parent.isBone && (ro.multiplyMatrices(Yc, o.matrixWorld), Un.setFromMatrixPosition(ro), n.setXYZ(a, Un.x, Un.y, Un.z), ro.multiplyMatrices(Yc, o.parent.matrixWorld), Un.setFromMatrixPosition(ro), n.setXYZ(a + 1, Un.x, Un.y, Un.z), a += 2);
          }
          i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function Yp(s) {
        const t = [];
        s.isBone === true && t.push(s);
        for (let e = 0; e < s.children.length; e++) t.push(...Yp(s.children[e]));
        return t;
      }
      const Qu = new I(), so = new I(), Ou = new I();
      class Mw extends ce {
        constructor(t, e, i) {
          super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "DirectionalLightHelper", e === void 0 && (e = 1);
          let n = new Fe();
          n.setAttribute("position", new le([
            -e,
            e,
            0,
            e,
            e,
            0,
            e,
            -e,
            0,
            -e,
            -e,
            0,
            -e,
            e,
            0
          ], 3));
          const r = new ma({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new ls(n, r), this.add(this.lightPlane), n = new Fe(), n.setAttribute("position", new le([
            0,
            0,
            0,
            0,
            0,
            1
          ], 3)), this.targetLine = new ls(n, r), this.add(this.targetLine), this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), Qu.setFromMatrixPosition(this.light.matrixWorld), so.setFromMatrixPosition(this.light.target.matrixWorld), Ou.subVectors(so, Qu), this.lightPlane.lookAt(so), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(so), this.targetLine.scale.z = Ou.length();
        }
      }
      class Tw extends Xn {
        constructor(t, e = null) {
          super(), this.object = t, this.domElement = e, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
          }, this.touches = {
            ONE: null,
            TWO: null
          };
        }
        connect(t) {
          if (t === void 0) {
            console.warn("THREE.Controls: connect() now requires an element.");
            return;
          }
          this.domElement !== null && this.disconnect(), this.domElement = t;
        }
        disconnect() {
        }
        dispose() {
        }
        update() {
        }
      }
      function zu(s, t, e, i) {
        const n = Rw(i);
        switch (e) {
          case lp:
            return s * t;
          case dp:
            return s * t;
          case up:
            return s * t * 2;
          case xn:
            return s * t / n.components * n.byteLength;
          case kh:
            return s * t / n.components * n.byteLength;
          case ur:
            return s * t * 2 / n.components * n.byteLength;
          case Nh:
            return s * t * 2 / n.components * n.byteLength;
          case hp:
            return s * t * 3 / n.components * n.byteLength;
          case We:
            return s * t * 4 / n.components * n.byteLength;
          case Uh:
            return s * t * 4 / n.components * n.byteLength;
          case wo:
          case Ns:
            return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case bo:
          case Us:
            return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Ql:
          case Ol:
            return Math.max(s, 16) * Math.max(t, 8) / 4;
          case Io:
          case Mo:
            return Math.max(s, 8) * Math.max(t, 8) / 2;
          case To:
          case Ro:
            return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Bo:
            return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Ks:
            return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case zl:
            return Math.floor((s + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case Gl:
            return Math.floor((s + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case Hl:
            return Math.floor((s + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case Js:
            return Math.floor((s + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case Vl:
            return Math.floor((s + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case Wl:
            return Math.floor((s + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case jl:
            return Math.floor((s + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case ql:
            return Math.floor((s + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case Xl:
            return Math.floor((s + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Yl:
            return Math.floor((s + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case Kl:
            return Math.floor((s + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case Jl:
            return Math.floor((s + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case Zl:
            return Math.floor((s + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case Qs:
          case $l:
          case Do:
            return Math.ceil(s / 4) * Math.ceil(t / 4) * 16;
          case fp:
          case th:
            return Math.ceil(s / 4) * Math.ceil(t / 4) * 8;
          case eh:
          case ih:
            return Math.ceil(s / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${e} format.`);
      }
      function Rw(s) {
        switch (s) {
          case Je:
          case ap:
            return {
              byteLength: 1,
              components: 1
            };
          case js:
          case op:
          case Ci:
            return {
              byteLength: 2,
              components: 1
            };
          case Fh:
          case Lh:
            return {
              byteLength: 2,
              components: 4
            };
          case _r:
          case Ph:
          case ii:
            return {
              byteLength: 4,
              components: 1
            };
          case cp:
            return {
              byteLength: 4,
              components: 3
            };
        }
        throw new Error(`Unknown texture type ${s}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: Dh
        }
      }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Dh);
      function Kp() {
        let s = null, t = false, e = null, i = null;
        function n(r, a) {
          e(r, a), i = s.requestAnimationFrame(n);
        }
        return {
          start: function() {
            t !== true && e !== null && (i = s.requestAnimationFrame(n), t = true);
          },
          stop: function() {
            s.cancelAnimationFrame(i), t = false;
          },
          setAnimationLoop: function(r) {
            e = r;
          },
          setContext: function(r) {
            s = r;
          }
        };
      }
      function Bw(s) {
        const t = /* @__PURE__ */ new WeakMap();
        function e(o, c) {
          const l = o.array, h = o.usage, d = l.byteLength, u = s.createBuffer();
          s.bindBuffer(c, u), s.bufferData(c, l, h), o.onUploadCallback();
          let f;
          if (l instanceof Float32Array) f = s.FLOAT;
          else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
          else if (l instanceof Int16Array) f = s.SHORT;
          else if (l instanceof Uint32Array) f = s.UNSIGNED_INT;
          else if (l instanceof Int32Array) f = s.INT;
          else if (l instanceof Int8Array) f = s.BYTE;
          else if (l instanceof Uint8Array) f = s.UNSIGNED_BYTE;
          else if (l instanceof Uint8ClampedArray) f = s.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
          return {
            buffer: u,
            type: f,
            bytesPerElement: l.BYTES_PER_ELEMENT,
            version: o.version,
            size: d
          };
        }
        function i(o, c, l) {
          const h = c.array, d = c.updateRanges;
          if (s.bindBuffer(l, o), d.length === 0) s.bufferSubData(l, 0, h);
          else {
            d.sort((f, p) => f.start - p.start);
            let u = 0;
            for (let f = 1; f < d.length; f++) {
              const p = d[u], m = d[f];
              m.start <= p.start + p.count + 1 ? p.count = Math.max(p.count, m.start + m.count - p.start) : (++u, d[u] = m);
            }
            d.length = u + 1;
            for (let f = 0, p = d.length; f < p; f++) {
              const m = d[f];
              s.bufferSubData(l, m.start * h.BYTES_PER_ELEMENT, h, m.start, m.count);
            }
            c.clearUpdateRanges();
          }
          c.onUploadCallback();
        }
        function n(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
        }
        function r(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const c = t.get(o);
          c && (s.deleteBuffer(c.buffer), t.delete(o));
        }
        function a(o, c) {
          if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
            const h = t.get(o);
            (!h || h.version < o.version) && t.set(o, {
              buffer: o.buffer,
              type: o.type,
              bytesPerElement: o.elementSize,
              version: o.version
            });
            return;
          }
          const l = t.get(o);
          if (l === void 0) t.set(o, e(o, c));
          else if (l.version < o.version) {
            if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(l.buffer, o, c), l.version = o.version;
          }
        }
        return {
          get: n,
          remove: r,
          update: a
        };
      }
      var Dw = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Pw = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Fw = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Lw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, kw = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Nw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Uw = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Qw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Ow = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, zw = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Gw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Hw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Vw = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Ww = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, jw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, qw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Xw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Yw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Kw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Jw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Zw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, $w = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, tb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, eb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, ib = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, nb = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, rb = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, sb = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, ab = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ob = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, cb = "gl_FragColor = linearToOutputTexel( gl_FragColor );", lb = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, hb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, db = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, ub = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, fb = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, pb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Ab = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, gb = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, _b = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, mb = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, wb = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, bb = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, yb = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, xb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, vb = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Eb = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Sb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Cb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Ib = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Mb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Tb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Rb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Bb = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Db = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Pb = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Fb = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Lb = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, kb = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Nb = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Ub = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Qb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Ob = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, zb = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Gb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Hb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Vb = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Wb = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, jb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, qb = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Xb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Yb = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Kb = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Jb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Zb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, $b = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, ty = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, ey = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, iy = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, ny = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, ry = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, sy = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, ay = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, oy = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, cy = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, ly = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, hy = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, dy = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, uy = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, fy = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, py = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Ay = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, gy = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, _y = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, my = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, wy = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, by = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, yy = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, xy = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, vy = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Ey = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Sy = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Cy = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Iy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, My = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Ty = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Ry = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const By = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Dy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Py = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Fy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Ly = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ky = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Ny = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Uy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Qy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Oy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, zy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Gy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Hy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Vy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Wy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, jy = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qy = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Xy = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Yy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Ky = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Jy = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Zy = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, $y = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, t0 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, e0 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, i0 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, n0 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, r0 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, s0 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, a0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, o0 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, c0 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, l0 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, h0 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Qt = {
        alphahash_fragment: Dw,
        alphahash_pars_fragment: Pw,
        alphamap_fragment: Fw,
        alphamap_pars_fragment: Lw,
        alphatest_fragment: kw,
        alphatest_pars_fragment: Nw,
        aomap_fragment: Uw,
        aomap_pars_fragment: Qw,
        batching_pars_vertex: Ow,
        batching_vertex: zw,
        begin_vertex: Gw,
        beginnormal_vertex: Hw,
        bsdfs: Vw,
        iridescence_fragment: Ww,
        bumpmap_pars_fragment: jw,
        clipping_planes_fragment: qw,
        clipping_planes_pars_fragment: Xw,
        clipping_planes_pars_vertex: Yw,
        clipping_planes_vertex: Kw,
        color_fragment: Jw,
        color_pars_fragment: Zw,
        color_pars_vertex: $w,
        color_vertex: tb,
        common: eb,
        cube_uv_reflection_fragment: ib,
        defaultnormal_vertex: nb,
        displacementmap_pars_vertex: rb,
        displacementmap_vertex: sb,
        emissivemap_fragment: ab,
        emissivemap_pars_fragment: ob,
        colorspace_fragment: cb,
        colorspace_pars_fragment: lb,
        envmap_fragment: hb,
        envmap_common_pars_fragment: db,
        envmap_pars_fragment: ub,
        envmap_pars_vertex: fb,
        envmap_physical_pars_fragment: Eb,
        envmap_vertex: pb,
        fog_vertex: Ab,
        fog_pars_vertex: gb,
        fog_fragment: _b,
        fog_pars_fragment: mb,
        gradientmap_pars_fragment: wb,
        lightmap_pars_fragment: bb,
        lights_lambert_fragment: yb,
        lights_lambert_pars_fragment: xb,
        lights_pars_begin: vb,
        lights_toon_fragment: Sb,
        lights_toon_pars_fragment: Cb,
        lights_phong_fragment: Ib,
        lights_phong_pars_fragment: Mb,
        lights_physical_fragment: Tb,
        lights_physical_pars_fragment: Rb,
        lights_fragment_begin: Bb,
        lights_fragment_maps: Db,
        lights_fragment_end: Pb,
        logdepthbuf_fragment: Fb,
        logdepthbuf_pars_fragment: Lb,
        logdepthbuf_pars_vertex: kb,
        logdepthbuf_vertex: Nb,
        map_fragment: Ub,
        map_pars_fragment: Qb,
        map_particle_fragment: Ob,
        map_particle_pars_fragment: zb,
        metalnessmap_fragment: Gb,
        metalnessmap_pars_fragment: Hb,
        morphinstance_vertex: Vb,
        morphcolor_vertex: Wb,
        morphnormal_vertex: jb,
        morphtarget_pars_vertex: qb,
        morphtarget_vertex: Xb,
        normal_fragment_begin: Yb,
        normal_fragment_maps: Kb,
        normal_pars_fragment: Jb,
        normal_pars_vertex: Zb,
        normal_vertex: $b,
        normalmap_pars_fragment: ty,
        clearcoat_normal_fragment_begin: ey,
        clearcoat_normal_fragment_maps: iy,
        clearcoat_pars_fragment: ny,
        iridescence_pars_fragment: ry,
        opaque_fragment: sy,
        packing: ay,
        premultiplied_alpha_fragment: oy,
        project_vertex: cy,
        dithering_fragment: ly,
        dithering_pars_fragment: hy,
        roughnessmap_fragment: dy,
        roughnessmap_pars_fragment: uy,
        shadowmap_pars_fragment: fy,
        shadowmap_pars_vertex: py,
        shadowmap_vertex: Ay,
        shadowmask_pars_fragment: gy,
        skinbase_vertex: _y,
        skinning_pars_vertex: my,
        skinning_vertex: wy,
        skinnormal_vertex: by,
        specularmap_fragment: yy,
        specularmap_pars_fragment: xy,
        tonemapping_fragment: vy,
        tonemapping_pars_fragment: Ey,
        transmission_fragment: Sy,
        transmission_pars_fragment: Cy,
        uv_pars_fragment: Iy,
        uv_pars_vertex: My,
        uv_vertex: Ty,
        worldpos_vertex: Ry,
        background_vert: By,
        background_frag: Dy,
        backgroundCube_vert: Py,
        backgroundCube_frag: Fy,
        cube_vert: Ly,
        cube_frag: ky,
        depth_vert: Ny,
        depth_frag: Uy,
        distanceRGBA_vert: Qy,
        distanceRGBA_frag: Oy,
        equirect_vert: zy,
        equirect_frag: Gy,
        linedashed_vert: Hy,
        linedashed_frag: Vy,
        meshbasic_vert: Wy,
        meshbasic_frag: jy,
        meshlambert_vert: qy,
        meshlambert_frag: Xy,
        meshmatcap_vert: Yy,
        meshmatcap_frag: Ky,
        meshnormal_vert: Jy,
        meshnormal_frag: Zy,
        meshphong_vert: $y,
        meshphong_frag: t0,
        meshphysical_vert: e0,
        meshphysical_frag: i0,
        meshtoon_vert: n0,
        meshtoon_frag: r0,
        points_vert: s0,
        points_frag: a0,
        shadow_vert: o0,
        shadow_frag: c0,
        sprite_vert: l0,
        sprite_frag: h0
      }, ct = {
        common: {
          diffuse: {
            value: new ht(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Ot()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Ot()
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          },
          specularMapTransform: {
            value: new Ot()
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          envMapRotation: {
            value: new Ot()
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          },
          aoMapTransform: {
            value: new Ot()
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          },
          lightMapTransform: {
            value: new Ot()
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpMapTransform: {
            value: new Ot()
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalMapTransform: {
            value: new Ot()
          },
          normalScale: {
            value: new rt(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementMapTransform: {
            value: new Ot()
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          },
          emissiveMapTransform: {
            value: new Ot()
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          },
          metalnessMapTransform: {
            value: new Ot()
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          },
          roughnessMapTransform: {
            value: new Ot()
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new ht(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new ht(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Ot()
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Ot()
          }
        },
        sprite: {
          diffuse: {
            value: new ht(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new rt(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Ot()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Ot()
          },
          alphaTest: {
            value: 0
          }
        }
      }, sn = {
        basic: {
          uniforms: Ai([
            ct.common,
            ct.specularmap,
            ct.envmap,
            ct.aomap,
            ct.lightmap,
            ct.fog
          ]),
          vertexShader: Qt.meshbasic_vert,
          fragmentShader: Qt.meshbasic_frag
        },
        lambert: {
          uniforms: Ai([
            ct.common,
            ct.specularmap,
            ct.envmap,
            ct.aomap,
            ct.lightmap,
            ct.emissivemap,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            ct.fog,
            ct.lights,
            {
              emissive: {
                value: new ht(0)
              }
            }
          ]),
          vertexShader: Qt.meshlambert_vert,
          fragmentShader: Qt.meshlambert_frag
        },
        phong: {
          uniforms: Ai([
            ct.common,
            ct.specularmap,
            ct.envmap,
            ct.aomap,
            ct.lightmap,
            ct.emissivemap,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            ct.fog,
            ct.lights,
            {
              emissive: {
                value: new ht(0)
              },
              specular: {
                value: new ht(1118481)
              },
              shininess: {
                value: 30
              }
            }
          ]),
          vertexShader: Qt.meshphong_vert,
          fragmentShader: Qt.meshphong_frag
        },
        standard: {
          uniforms: Ai([
            ct.common,
            ct.envmap,
            ct.aomap,
            ct.lightmap,
            ct.emissivemap,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            ct.roughnessmap,
            ct.metalnessmap,
            ct.fog,
            ct.lights,
            {
              emissive: {
                value: new ht(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qt.meshphysical_vert,
          fragmentShader: Qt.meshphysical_frag
        },
        toon: {
          uniforms: Ai([
            ct.common,
            ct.aomap,
            ct.lightmap,
            ct.emissivemap,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            ct.gradientmap,
            ct.fog,
            ct.lights,
            {
              emissive: {
                value: new ht(0)
              }
            }
          ]),
          vertexShader: Qt.meshtoon_vert,
          fragmentShader: Qt.meshtoon_frag
        },
        matcap: {
          uniforms: Ai([
            ct.common,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            ct.fog,
            {
              matcap: {
                value: null
              }
            }
          ]),
          vertexShader: Qt.meshmatcap_vert,
          fragmentShader: Qt.meshmatcap_frag
        },
        points: {
          uniforms: Ai([
            ct.points,
            ct.fog
          ]),
          vertexShader: Qt.points_vert,
          fragmentShader: Qt.points_frag
        },
        dashed: {
          uniforms: Ai([
            ct.common,
            ct.fog,
            {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }
          ]),
          vertexShader: Qt.linedashed_vert,
          fragmentShader: Qt.linedashed_frag
        },
        depth: {
          uniforms: Ai([
            ct.common,
            ct.displacementmap
          ]),
          vertexShader: Qt.depth_vert,
          fragmentShader: Qt.depth_frag
        },
        normal: {
          uniforms: Ai([
            ct.common,
            ct.bumpmap,
            ct.normalmap,
            ct.displacementmap,
            {
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qt.meshnormal_vert,
          fragmentShader: Qt.meshnormal_frag
        },
        sprite: {
          uniforms: Ai([
            ct.sprite,
            ct.fog
          ]),
          vertexShader: Qt.sprite_vert,
          fragmentShader: Qt.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Ot()
            },
            t2D: {
              value: null
            },
            backgroundIntensity: {
              value: 1
            }
          },
          vertexShader: Qt.background_vert,
          fragmentShader: Qt.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            backgroundBlurriness: {
              value: 0
            },
            backgroundIntensity: {
              value: 1
            },
            backgroundRotation: {
              value: new Ot()
            }
          },
          vertexShader: Qt.backgroundCube_vert,
          fragmentShader: Qt.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: {
              value: null
            },
            tFlip: {
              value: -1
            },
            opacity: {
              value: 1
            }
          },
          vertexShader: Qt.cube_vert,
          fragmentShader: Qt.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: Qt.equirect_vert,
          fragmentShader: Qt.equirect_frag
        },
        distanceRGBA: {
          uniforms: Ai([
            ct.common,
            ct.displacementmap,
            {
              referencePosition: {
                value: new I()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }
          ]),
          vertexShader: Qt.distanceRGBA_vert,
          fragmentShader: Qt.distanceRGBA_frag
        },
        shadow: {
          uniforms: Ai([
            ct.lights,
            ct.fog,
            {
              color: {
                value: new ht(0)
              },
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qt.shadow_vert,
          fragmentShader: Qt.shadow_frag
        }
      };
      sn.physical = {
        uniforms: Ai([
          sn.standard.uniforms,
          {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: new Ot()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: new Ot()
            },
            clearcoatNormalScale: {
              value: new rt(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: new Ot()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: new Ot()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: new Ot()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new ht(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: new Ot()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: new Ot()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: new Ot()
            },
            transmissionSamplerSize: {
              value: new rt()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: new Ot()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new ht(0)
            },
            specularColor: {
              value: new ht(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: new Ot()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: new Ot()
            },
            anisotropyVector: {
              value: new rt()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: new Ot()
            }
          }
        ]),
        vertexShader: Qt.meshphysical_vert,
        fragmentShader: Qt.meshphysical_frag
      };
      const ao = {
        r: 0,
        b: 0,
        g: 0
      }, sr = new Oe(), d0 = new ft();
      function u0(s, t, e, i, n, r, a) {
        const o = new ht(0);
        let c = r === true ? 0 : 1, l, h, d = null, u = 0, f = null;
        function p(b) {
          let y = b.isScene === true ? b.background : null;
          return y && y.isTexture && (y = (b.backgroundBlurriness > 0 ? e : t).get(y)), y;
        }
        function m(b) {
          let y = false;
          const M = p(b);
          M === null ? A(o, c) : M && M.isColor && (A(M, 1), y = true);
          const T = s.xr.getEnvironmentBlendMode();
          T === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : T === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || y) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
        }
        function g(b, y) {
          const M = p(y);
          M && (M.isCubeTexture || M.mapping === Xo) ? (h === void 0 && (h = new me(new ps(1, 1, 1), new Ni({
            name: "BackgroundCubeMaterial",
            uniforms: cs(sn.backgroundCube.uniforms),
            vertexShader: sn.backgroundCube.vertexShader,
            fragmentShader: sn.backgroundCube.fragmentShader,
            side: yi,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(T, R, B) {
            this.matrixWorld.copyPosition(B.matrixWorld);
          }, Object.defineProperty(h.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          }), n.update(h)), sr.copy(y.backgroundRotation), sr.x *= -1, sr.y *= -1, sr.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === false && (sr.y *= -1, sr.z *= -1), h.material.uniforms.envMap.value = M, h.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(d0.makeRotationFromEuler(sr)), h.material.toneMapped = zt.getTransfer(M.colorSpace) !== ge, (d !== M || u !== M.version || f !== s.toneMapping) && (h.material.needsUpdate = true, d = M, u = M.version, f = s.toneMapping), h.layers.enableAll(), b.unshift(h, h.geometry, h.material, 0, 0, null)) : M && M.isTexture && (l === void 0 && (l = new me(new vr(2, 2), new Ni({
            name: "BackgroundMaterial",
            uniforms: cs(sn.background.uniforms),
            vertexShader: sn.background.vertexShader,
            fragmentShader: sn.background.fragmentShader,
            side: Cn,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          }), n.update(l)), l.material.uniforms.t2D.value = M, l.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, l.material.toneMapped = zt.getTransfer(M.colorSpace) !== ge, M.matrixAutoUpdate === true && M.updateMatrix(), l.material.uniforms.uvTransform.value.copy(M.matrix), (d !== M || u !== M.version || f !== s.toneMapping) && (l.material.needsUpdate = true, d = M, u = M.version, f = s.toneMapping), l.layers.enableAll(), b.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function A(b, y) {
          b.getRGB(ao, xp(s)), i.buffers.color.setClear(ao.r, ao.g, ao.b, y, a);
        }
        function x() {
          h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), l !== void 0 && (l.geometry.dispose(), l.material.dispose(), l = void 0);
        }
        return {
          getClearColor: function() {
            return o;
          },
          setClearColor: function(b, y = 1) {
            o.set(b), c = y, A(o, c);
          },
          getClearAlpha: function() {
            return c;
          },
          setClearAlpha: function(b) {
            c = b, A(o, c);
          },
          render: m,
          addToRenderList: g,
          dispose: x
        };
      }
      function f0(s, t) {
        const e = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, n = u(null);
        let r = n, a = false;
        function o(E, P, G, H, Y) {
          let et = false;
          const q = d(H, G, P);
          r !== q && (r = q, l(r.object)), et = f(E, H, G, Y), et && p(E, H, G, Y), Y !== null && t.update(Y, s.ELEMENT_ARRAY_BUFFER), (et || a) && (a = false, y(E, P, G, H), Y !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(Y).buffer));
        }
        function c() {
          return s.createVertexArray();
        }
        function l(E) {
          return s.bindVertexArray(E);
        }
        function h(E) {
          return s.deleteVertexArray(E);
        }
        function d(E, P, G) {
          const H = G.wireframe === true;
          let Y = i[E.id];
          Y === void 0 && (Y = {}, i[E.id] = Y);
          let et = Y[P.id];
          et === void 0 && (et = {}, Y[P.id] = et);
          let q = et[H];
          return q === void 0 && (q = u(c()), et[H] = q), q;
        }
        function u(E) {
          const P = [], G = [], H = [];
          for (let Y = 0; Y < e; Y++) P[Y] = 0, G[Y] = 0, H[Y] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: P,
            enabledAttributes: G,
            attributeDivisors: H,
            object: E,
            attributes: {},
            index: null
          };
        }
        function f(E, P, G, H) {
          const Y = r.attributes, et = P.attributes;
          let q = 0;
          const Z = G.getAttributes();
          for (const W in Z) if (Z[W].location >= 0) {
            const dt = Y[W];
            let Et = et[W];
            if (Et === void 0 && (W === "instanceMatrix" && E.instanceMatrix && (Et = E.instanceMatrix), W === "instanceColor" && E.instanceColor && (Et = E.instanceColor)), dt === void 0 || dt.attribute !== Et || Et && dt.data !== Et.data) return true;
            q++;
          }
          return r.attributesNum !== q || r.index !== H;
        }
        function p(E, P, G, H) {
          const Y = {}, et = P.attributes;
          let q = 0;
          const Z = G.getAttributes();
          for (const W in Z) if (Z[W].location >= 0) {
            let dt = et[W];
            dt === void 0 && (W === "instanceMatrix" && E.instanceMatrix && (dt = E.instanceMatrix), W === "instanceColor" && E.instanceColor && (dt = E.instanceColor));
            const Et = {};
            Et.attribute = dt, dt && dt.data && (Et.data = dt.data), Y[W] = Et, q++;
          }
          r.attributes = Y, r.attributesNum = q, r.index = H;
        }
        function m() {
          const E = r.newAttributes;
          for (let P = 0, G = E.length; P < G; P++) E[P] = 0;
        }
        function g(E) {
          A(E, 0);
        }
        function A(E, P) {
          const G = r.newAttributes, H = r.enabledAttributes, Y = r.attributeDivisors;
          G[E] = 1, H[E] === 0 && (s.enableVertexAttribArray(E), H[E] = 1), Y[E] !== P && (s.vertexAttribDivisor(E, P), Y[E] = P);
        }
        function x() {
          const E = r.newAttributes, P = r.enabledAttributes;
          for (let G = 0, H = P.length; G < H; G++) P[G] !== E[G] && (s.disableVertexAttribArray(G), P[G] = 0);
        }
        function b(E, P, G, H, Y, et, q) {
          q === true ? s.vertexAttribIPointer(E, P, G, Y, et) : s.vertexAttribPointer(E, P, G, H, Y, et);
        }
        function y(E, P, G, H) {
          m();
          const Y = H.attributes, et = G.getAttributes(), q = P.defaultAttributeValues;
          for (const Z in et) {
            const W = et[Z];
            if (W.location >= 0) {
              let st = Y[Z];
              if (st === void 0 && (Z === "instanceMatrix" && E.instanceMatrix && (st = E.instanceMatrix), Z === "instanceColor" && E.instanceColor && (st = E.instanceColor)), st !== void 0) {
                const dt = st.normalized, Et = st.itemSize, Pt = t.get(st);
                if (Pt === void 0) continue;
                const Vt = Pt.buffer, K = Pt.type, ot = Pt.bytesPerElement, bt = K === s.INT || K === s.UNSIGNED_INT || st.gpuType === Ph;
                if (st.isInterleavedBufferAttribute) {
                  const lt = st.data, Tt = lt.stride, Zt = st.offset;
                  if (lt.isInstancedInterleavedBuffer) {
                    for (let Ft = 0; Ft < W.locationSize; Ft++) A(W.location + Ft, lt.meshPerAttribute);
                    E.isInstancedMesh !== true && H._maxInstanceCount === void 0 && (H._maxInstanceCount = lt.meshPerAttribute * lt.count);
                  } else for (let Ft = 0; Ft < W.locationSize; Ft++) g(W.location + Ft);
                  s.bindBuffer(s.ARRAY_BUFFER, Vt);
                  for (let Ft = 0; Ft < W.locationSize; Ft++) b(W.location + Ft, Et / W.locationSize, K, dt, Tt * ot, (Zt + Et / W.locationSize * Ft) * ot, bt);
                } else {
                  if (st.isInstancedBufferAttribute) {
                    for (let lt = 0; lt < W.locationSize; lt++) A(W.location + lt, st.meshPerAttribute);
                    E.isInstancedMesh !== true && H._maxInstanceCount === void 0 && (H._maxInstanceCount = st.meshPerAttribute * st.count);
                  } else for (let lt = 0; lt < W.locationSize; lt++) g(W.location + lt);
                  s.bindBuffer(s.ARRAY_BUFFER, Vt);
                  for (let lt = 0; lt < W.locationSize; lt++) b(W.location + lt, Et / W.locationSize, K, dt, Et * ot, Et / W.locationSize * lt * ot, bt);
                }
              } else if (q !== void 0) {
                const dt = q[Z];
                if (dt !== void 0) switch (dt.length) {
                  case 2:
                    s.vertexAttrib2fv(W.location, dt);
                    break;
                  case 3:
                    s.vertexAttrib3fv(W.location, dt);
                    break;
                  case 4:
                    s.vertexAttrib4fv(W.location, dt);
                    break;
                  default:
                    s.vertexAttrib1fv(W.location, dt);
                }
              }
            }
          }
          x();
        }
        function M() {
          B();
          for (const E in i) {
            const P = i[E];
            for (const G in P) {
              const H = P[G];
              for (const Y in H) h(H[Y].object), delete H[Y];
              delete P[G];
            }
            delete i[E];
          }
        }
        function T(E) {
          if (i[E.id] === void 0) return;
          const P = i[E.id];
          for (const G in P) {
            const H = P[G];
            for (const Y in H) h(H[Y].object), delete H[Y];
            delete P[G];
          }
          delete i[E.id];
        }
        function R(E) {
          for (const P in i) {
            const G = i[P];
            if (G[E.id] === void 0) continue;
            const H = G[E.id];
            for (const Y in H) h(H[Y].object), delete H[Y];
            delete G[E.id];
          }
        }
        function B() {
          S(), a = true, r !== n && (r = n, l(r.object));
        }
        function S() {
          n.geometry = null, n.program = null, n.wireframe = false;
        }
        return {
          setup: o,
          reset: B,
          resetDefaultState: S,
          dispose: M,
          releaseStatesOfGeometry: T,
          releaseStatesOfProgram: R,
          initAttributes: m,
          enableAttribute: g,
          disableUnusedAttributes: x
        };
      }
      function p0(s, t, e) {
        let i;
        function n(l) {
          i = l;
        }
        function r(l, h) {
          s.drawArrays(i, l, h), e.update(h, i, 1);
        }
        function a(l, h, d) {
          d !== 0 && (s.drawArraysInstanced(i, l, h, d), e.update(h, i, d));
        }
        function o(l, h, d) {
          if (d === 0) return;
          t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, l, 0, h, 0, d);
          let f = 0;
          for (let p = 0; p < d; p++) f += h[p];
          e.update(f, i, 1);
        }
        function c(l, h, d, u) {
          if (d === 0) return;
          const f = t.get("WEBGL_multi_draw");
          if (f === null) for (let p = 0; p < l.length; p++) a(l[p], h[p], u[p]);
          else {
            f.multiDrawArraysInstancedWEBGL(i, l, 0, h, 0, u, 0, d);
            let p = 0;
            for (let m = 0; m < d; m++) p += h[m] * u[m];
            e.update(p, i, 1);
          }
        }
        this.setMode = n, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c;
      }
      function A0(s, t, e, i) {
        let n;
        function r() {
          if (n !== void 0) return n;
          if (t.has("EXT_texture_filter_anisotropic") === true) {
            const R = t.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function a(R) {
          return !(R !== We && i.convert(R) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(R) {
          const B = R === Ci && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
          return !(R !== Je && i.convert(R) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && R !== ii && !B);
        }
        function c(R) {
          if (R === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0) return "highp";
            R = "mediump";
          }
          return R === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let l = e.precision !== void 0 ? e.precision : "highp";
        const h = c(l);
        h !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", h, "instead."), l = h);
        const d = e.logarithmicDepthBuffer === true, u = e.reverseDepthBuffer === true && t.has("EXT_clip_control"), f = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), p = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), A = s.getParameter(s.MAX_VERTEX_ATTRIBS), x = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), b = s.getParameter(s.MAX_VARYING_VECTORS), y = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), M = p > 0, T = s.getParameter(s.MAX_SAMPLES);
        return {
          isWebGL2: true,
          getMaxAnisotropy: r,
          getMaxPrecision: c,
          textureFormatReadable: a,
          textureTypeReadable: o,
          precision: l,
          logarithmicDepthBuffer: d,
          reverseDepthBuffer: u,
          maxTextures: f,
          maxVertexTextures: p,
          maxTextureSize: m,
          maxCubemapSize: g,
          maxAttributes: A,
          maxVertexUniforms: x,
          maxVaryings: b,
          maxFragmentUniforms: y,
          vertexTextures: M,
          maxSamples: T
        };
      }
      function g0(s) {
        const t = this;
        let e = null, i = 0, n = false, r = false;
        const a = new Yi(), o = new Ot(), c = {
          value: null,
          needsUpdate: false
        };
        this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, u) {
          const f = d.length !== 0 || u || i !== 0 || n;
          return n = u, i = d.length, f;
        }, this.beginShadows = function() {
          r = true, h(null);
        }, this.endShadows = function() {
          r = false;
        }, this.setGlobalState = function(d, u) {
          e = h(d, u, 0);
        }, this.setState = function(d, u, f) {
          const p = d.clippingPlanes, m = d.clipIntersection, g = d.clipShadows, A = s.get(d);
          if (!n || p === null || p.length === 0 || r && !g) r ? h(null) : l();
          else {
            const x = r ? 0 : i, b = x * 4;
            let y = A.clippingState || null;
            c.value = y, y = h(p, u, b, f);
            for (let M = 0; M !== b; ++M) y[M] = e[M];
            A.clippingState = y, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += x;
          }
        };
        function l() {
          c.value !== e && (c.value = e, c.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0;
        }
        function h(d, u, f, p) {
          const m = d !== null ? d.length : 0;
          let g = null;
          if (m !== 0) {
            if (g = c.value, p !== true || g === null) {
              const A = f + m * 4, x = u.matrixWorldInverse;
              o.getNormalMatrix(x), (g === null || g.length < A) && (g = new Float32Array(A));
              for (let b = 0, y = f; b !== m; ++b, y += 4) a.copy(d[b]).applyMatrix4(x, o), a.normal.toArray(g, y), g[y + 3] = a.constant;
            }
            c.value = g, c.needsUpdate = true;
          }
          return t.numPlanes = m, t.numIntersection = 0, g;
        }
      }
      function _0(s) {
        let t = /* @__PURE__ */ new WeakMap();
        function e(a, o) {
          return o === So ? a.mapping = gr : o === Ul && (a.mapping = as), a;
        }
        function i(a) {
          if (a && a.isTexture) {
            const o = a.mapping;
            if (o === So || o === Ul) if (t.has(a)) {
              const c = t.get(a).texture;
              return e(c, a.mapping);
            } else {
              const c = a.image;
              if (c && c.height > 0) {
                const l = new em(c.height);
                return l.fromEquirectangularTexture(s, a), t.set(a, l), a.addEventListener("dispose", n), e(l.texture, a.mapping);
              } else return null;
            }
          }
          return a;
        }
        function n(a) {
          const o = a.target;
          o.removeEventListener("dispose", n);
          const c = t.get(o);
          c !== void 0 && (t.delete(o), c.dispose());
        }
        function r() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: i,
          dispose: r
        };
      }
      const Zr = 4, Gu = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], dr = 20, Kc = new ed(), Hu = new ht();
      let Jc = null, Zc = 0, $c = 0, tl = false;
      const lr = (1 + Math.sqrt(5)) / 2, Hr = 1 / lr, Vu = [
        new I(-lr, Hr, 0),
        new I(lr, Hr, 0),
        new I(-Hr, 0, lr),
        new I(Hr, 0, lr),
        new I(0, lr, -Hr),
        new I(0, lr, Hr),
        new I(-1, 1, -1),
        new I(1, 1, -1),
        new I(-1, 1, 1),
        new I(1, 1, 1)
      ], m0 = new I();
      class Wu {
        constructor(t) {
          this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, i = 0.1, n = 100, r = {}) {
          const { size: a = 256, position: o = m0 } = r;
          Jc = this._renderer.getRenderTarget(), Zc = this._renderer.getActiveCubeFace(), $c = this._renderer.getActiveMipmapLevel(), tl = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(a);
          const c = this._allocateTargets();
          return c.depthBuffer = true, this._sceneToCubeUV(t, i, n, c, o), e > 0 && this._blur(c, 0, 0, e), this._applyPMREM(c), this._cleanup(c), c;
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Xu(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = qu(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(t) {
          this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(Jc, Zc, $c), this._renderer.xr.enabled = tl, t.scissorTest = false, oo(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          t.mapping === gr || t.mapping === as ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Jc = this._renderer.getRenderTarget(), Zc = this._renderer.getActiveCubeFace(), $c = this._renderer.getActiveMipmapLevel(), tl = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
          const i = e || this._allocateTargets();
          return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
            magFilter: Re,
            minFilter: Re,
            generateMipmaps: false,
            type: Ci,
            format: We,
            colorSpace: di,
            depthBuffer: false
          }, n = ju(t, e, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = ju(t, e, i);
            const { _lodMax: r } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = w0(r)), this._blurMaterial = b0(r, t, e);
          }
          return n;
        }
        _compileMaterial(t) {
          const e = new me(this._lodPlanes[0], t);
          this._renderer.compile(e, Kc);
        }
        _sceneToCubeUV(t, e, i, n, r) {
          const c = new Ve(90, 1, e, i), l = [
            1,
            -1,
            1,
            1,
            1,
            1
          ], h = [
            1,
            1,
            1,
            -1,
            -1,
            -1
          ], d = this._renderer, u = d.autoClear, f = d.toneMapping;
          d.getClearColor(Hu), d.toneMapping = Vn, d.autoClear = false;
          const p = new on({
            name: "PMREM.Background",
            side: yi,
            depthWrite: false,
            depthTest: false
          }), m = new me(new ps(), p);
          let g = false;
          const A = t.background;
          A ? A.isColor && (p.color.copy(A), t.background = null, g = true) : (p.color.copy(Hu), g = true);
          for (let x = 0; x < 6; x++) {
            const b = x % 3;
            b === 0 ? (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x + h[x], r.y, r.z)) : b === 1 ? (c.up.set(0, 0, l[x]), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y + h[x], r.z)) : (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y, r.z + h[x]));
            const y = this._cubeSize;
            oo(n, b * y, x > 2 ? y : 0, y, y), d.setRenderTarget(n), g && d.render(m, c), d.render(t, c);
          }
          m.geometry.dispose(), m.material.dispose(), d.toneMapping = f, d.autoClear = u, t.background = A;
        }
        _textureToCubeUV(t, e) {
          const i = this._renderer, n = t.mapping === gr || t.mapping === as;
          n ? (this._cubemapMaterial === null && (this._cubemapMaterial = Xu()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = qu());
          const r = n ? this._cubemapMaterial : this._equirectMaterial, a = new me(this._lodPlanes[0], r), o = r.uniforms;
          o.envMap.value = t;
          const c = this._cubeSize;
          oo(e, 0, 0, 3 * c, 2 * c), i.setRenderTarget(e), i.render(a, Kc);
        }
        _applyPMREM(t) {
          const e = this._renderer, i = e.autoClear;
          e.autoClear = false;
          const n = this._lodPlanes.length;
          for (let r = 1; r < n; r++) {
            const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = Vu[(n - r - 1) % Vu.length];
            this._blur(t, r - 1, r, a, o);
          }
          e.autoClear = i;
        }
        _blur(t, e, i, n, r) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(t, a, e, i, n, "latitudinal", r), this._halfBlur(a, t, i, i, n, "longitudinal", r);
        }
        _halfBlur(t, e, i, n, r, a, o) {
          const c = this._renderer, l = this._blurMaterial;
          a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const h = 3, d = new me(this._lodPlanes[n], l), u = l.uniforms, f = this._sizeLods[i] - 1, p = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * dr - 1), m = r / p, g = isFinite(r) ? 1 + Math.floor(h * m) : dr;
          g > dr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${dr}`);
          const A = [];
          let x = 0;
          for (let R = 0; R < dr; ++R) {
            const B = R / m, S = Math.exp(-B * B / 2);
            A.push(S), R === 0 ? x += S : R < g && (x += 2 * S);
          }
          for (let R = 0; R < A.length; R++) A[R] = A[R] / x;
          u.envMap.value = t.texture, u.samples.value = g, u.weights.value = A, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
          const { _lodMax: b } = this;
          u.dTheta.value = p, u.mipInt.value = b - i;
          const y = this._sizeLods[n], M = 3 * y * (n > b - Zr ? n - b + Zr : 0), T = 4 * (this._cubeSize - y);
          oo(e, M, T, 3 * y, 2 * y), c.setRenderTarget(e), c.render(d, Kc);
        }
      }
      function w0(s) {
        const t = [], e = [], i = [];
        let n = s;
        const r = s - Zr + 1 + Gu.length;
        for (let a = 0; a < r; a++) {
          const o = Math.pow(2, n);
          e.push(o);
          let c = 1 / o;
          a > s - Zr ? c = Gu[a - s + Zr - 1] : a === 0 && (c = 0), i.push(c);
          const l = 1 / (o - 2), h = -l, d = 1 + l, u = [
            h,
            h,
            d,
            h,
            d,
            d,
            h,
            h,
            d,
            d,
            h,
            d
          ], f = 6, p = 6, m = 3, g = 2, A = 1, x = new Float32Array(m * p * f), b = new Float32Array(g * p * f), y = new Float32Array(A * p * f);
          for (let T = 0; T < f; T++) {
            const R = T % 3 * 2 / 3 - 1, B = T > 2 ? 0 : -1, S = [
              R,
              B,
              0,
              R + 2 / 3,
              B,
              0,
              R + 2 / 3,
              B + 1,
              0,
              R,
              B,
              0,
              R + 2 / 3,
              B + 1,
              0,
              R,
              B + 1,
              0
            ];
            x.set(S, m * p * T), b.set(u, g * p * T);
            const E = [
              T,
              T,
              T,
              T,
              T,
              T
            ];
            y.set(E, A * p * T);
          }
          const M = new Fe();
          M.setAttribute("position", new ri(x, m)), M.setAttribute("uv", new ri(b, g)), M.setAttribute("faceIndex", new ri(y, A)), t.push(M), n > Zr && n--;
        }
        return {
          lodPlanes: t,
          sizeLods: e,
          sigmas: i
        };
      }
      function ju(s, t, e) {
        const i = new In(s, t, e);
        return i.texture.mapping = Xo, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
      }
      function oo(s, t, e, i, n) {
        s.viewport.set(t, e, i, n), s.scissor.set(t, e, i, n);
      }
      function b0(s, t, e) {
        const i = new Float32Array(dr), n = new I(0, 1, 0);
        return new Ni({
          name: "SphericalGaussianBlur",
          defines: {
            n: dr,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / e,
            CUBEUV_MAX_MIP: `${s}.0`
          },
          uniforms: {
            envMap: {
              value: null
            },
            samples: {
              value: 1
            },
            weights: {
              value: i
            },
            latitudinal: {
              value: false
            },
            dTheta: {
              value: 0
            },
            mipInt: {
              value: 0
            },
            poleAxis: {
              value: n
            }
          },
          vertexShader: sd(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: Hn,
          depthTest: false,
          depthWrite: false
        });
      }
      function qu() {
        return new Ni({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: sd(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: Hn,
          depthTest: false,
          depthWrite: false
        });
      }
      function Xu() {
        return new Ni({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: sd(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: Hn,
          depthTest: false,
          depthWrite: false
        });
      }
      function sd() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function y0(s) {
        let t = /* @__PURE__ */ new WeakMap(), e = null;
        function i(o) {
          if (o && o.isTexture) {
            const c = o.mapping, l = c === So || c === Ul, h = c === gr || c === as;
            if (l || h) {
              let d = t.get(o);
              const u = d !== void 0 ? d.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== u) return e === null && (e = new Wu(s)), d = l ? e.fromEquirectangular(o, d) : e.fromCubemap(o, d), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), d.texture;
              if (d !== void 0) return d.texture;
              {
                const f = o.image;
                return l && f && f.height > 0 || h && f && n(f) ? (e === null && (e = new Wu(s)), d = l ? e.fromEquirectangular(o) : e.fromCubemap(o), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), o.addEventListener("dispose", r), d.texture) : null;
              }
            }
          }
          return o;
        }
        function n(o) {
          let c = 0;
          const l = 6;
          for (let h = 0; h < l; h++) o[h] !== void 0 && c++;
          return c === l;
        }
        function r(o) {
          const c = o.target;
          c.removeEventListener("dispose", r);
          const l = t.get(c);
          l !== void 0 && (t.delete(c), l.dispose());
        }
        function a() {
          t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
        }
        return {
          get: i,
          dispose: a
        };
      }
      function x0(s) {
        const t = {};
        function e(i) {
          if (t[i] !== void 0) return t[i];
          let n;
          switch (i) {
            case "WEBGL_depth_texture":
              n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n = s.getExtension(i);
          }
          return t[i] = n, n;
        }
        return {
          has: function(i) {
            return e(i) !== null;
          },
          init: function() {
            e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
          },
          get: function(i) {
            const n = e(i);
            return n === null && yo("THREE.WebGLRenderer: " + i + " extension not supported."), n;
          }
        };
      }
      function v0(s, t, e, i) {
        const n = {}, r = /* @__PURE__ */ new WeakMap();
        function a(d) {
          const u = d.target;
          u.index !== null && t.remove(u.index);
          for (const p in u.attributes) t.remove(u.attributes[p]);
          u.removeEventListener("dispose", a), delete n[u.id];
          const f = r.get(u);
          f && (t.remove(f), r.delete(u)), i.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === true && delete u._maxInstanceCount, e.memory.geometries--;
        }
        function o(d, u) {
          return n[u.id] === true || (u.addEventListener("dispose", a), n[u.id] = true, e.memory.geometries++), u;
        }
        function c(d) {
          const u = d.attributes;
          for (const f in u) t.update(u[f], s.ARRAY_BUFFER);
        }
        function l(d) {
          const u = [], f = d.index, p = d.attributes.position;
          let m = 0;
          if (f !== null) {
            const x = f.array;
            m = f.version;
            for (let b = 0, y = x.length; b < y; b += 3) {
              const M = x[b + 0], T = x[b + 1], R = x[b + 2];
              u.push(M, T, T, R, R, M);
            }
          } else if (p !== void 0) {
            const x = p.array;
            m = p.version;
            for (let b = 0, y = x.length / 3 - 1; b < y; b += 3) {
              const M = b + 0, T = b + 1, R = b + 2;
              u.push(M, T, T, R, R, M);
            }
          } else return;
          const g = new (gp(u) ? yp : Jo)(u, 1);
          g.version = m;
          const A = r.get(d);
          A && t.remove(A), r.set(d, g);
        }
        function h(d) {
          const u = r.get(d);
          if (u) {
            const f = d.index;
            f !== null && u.version < f.version && l(d);
          } else l(d);
          return r.get(d);
        }
        return {
          get: o,
          update: c,
          getWireframeAttribute: h
        };
      }
      function E0(s, t, e) {
        let i;
        function n(u) {
          i = u;
        }
        let r, a;
        function o(u) {
          r = u.type, a = u.bytesPerElement;
        }
        function c(u, f) {
          s.drawElements(i, f, r, u * a), e.update(f, i, 1);
        }
        function l(u, f, p) {
          p !== 0 && (s.drawElementsInstanced(i, f, r, u * a, p), e.update(f, i, p));
        }
        function h(u, f, p) {
          if (p === 0) return;
          t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, r, u, 0, p);
          let g = 0;
          for (let A = 0; A < p; A++) g += f[A];
          e.update(g, i, 1);
        }
        function d(u, f, p, m) {
          if (p === 0) return;
          const g = t.get("WEBGL_multi_draw");
          if (g === null) for (let A = 0; A < u.length; A++) l(u[A] / a, f[A], m[A]);
          else {
            g.multiDrawElementsInstancedWEBGL(i, f, 0, r, u, 0, m, 0, p);
            let A = 0;
            for (let x = 0; x < p; x++) A += f[x] * m[x];
            e.update(A, i, 1);
          }
        }
        this.setMode = n, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
      }
      function S0(s) {
        const t = {
          geometries: 0,
          textures: 0
        }, e = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function i(r, a, o) {
          switch (e.calls++, a) {
            case s.TRIANGLES:
              e.triangles += o * (r / 3);
              break;
            case s.LINES:
              e.lines += o * (r / 2);
              break;
            case s.LINE_STRIP:
              e.lines += o * (r - 1);
              break;
            case s.LINE_LOOP:
              e.lines += o * r;
              break;
            case s.POINTS:
              e.points += o * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", a);
              break;
          }
        }
        function n() {
          e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
        }
        return {
          memory: t,
          render: e,
          programs: null,
          autoReset: true,
          reset: n,
          update: i
        };
      }
      function C0(s, t, e) {
        const i = /* @__PURE__ */ new WeakMap(), n = new jt();
        function r(a, o, c) {
          const l = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, d = h !== void 0 ? h.length : 0;
          let u = i.get(o);
          if (u === void 0 || u.count !== d) {
            let S = function() {
              R.dispose(), i.delete(o), o.removeEventListener("dispose", S);
            };
            u !== void 0 && u.texture.dispose();
            const f = o.morphAttributes.position !== void 0, p = o.morphAttributes.normal !== void 0, m = o.morphAttributes.color !== void 0, g = o.morphAttributes.position || [], A = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
            let b = 0;
            f === true && (b = 1), p === true && (b = 2), m === true && (b = 3);
            let y = o.attributes.position.count * b, M = 1;
            y > t.maxTextureSize && (M = Math.ceil(y / t.maxTextureSize), y = t.maxTextureSize);
            const T = new Float32Array(y * M * 4 * d), R = new _p(T, y, M, d);
            R.type = ii, R.needsUpdate = true;
            const B = b * 4;
            for (let E = 0; E < d; E++) {
              const P = g[E], G = A[E], H = x[E], Y = y * M * 4 * E;
              for (let et = 0; et < P.count; et++) {
                const q = et * B;
                f === true && (n.fromBufferAttribute(P, et), T[Y + q + 0] = n.x, T[Y + q + 1] = n.y, T[Y + q + 2] = n.z, T[Y + q + 3] = 0), p === true && (n.fromBufferAttribute(G, et), T[Y + q + 4] = n.x, T[Y + q + 5] = n.y, T[Y + q + 6] = n.z, T[Y + q + 7] = 0), m === true && (n.fromBufferAttribute(H, et), T[Y + q + 8] = n.x, T[Y + q + 9] = n.y, T[Y + q + 10] = n.z, T[Y + q + 11] = H.itemSize === 4 ? n.w : 1);
              }
            }
            u = {
              count: d,
              texture: R,
              size: new rt(y, M)
            }, i.set(o, u), o.addEventListener("dispose", S);
          }
          if (a.isInstancedMesh === true && a.morphTexture !== null) c.getUniforms().setValue(s, "morphTexture", a.morphTexture, e);
          else {
            let f = 0;
            for (let m = 0; m < l.length; m++) f += l[m];
            const p = o.morphTargetsRelative ? 1 : 1 - f;
            c.getUniforms().setValue(s, "morphTargetBaseInfluence", p), c.getUniforms().setValue(s, "morphTargetInfluences", l);
          }
          c.getUniforms().setValue(s, "morphTargetsTexture", u.texture, e), c.getUniforms().setValue(s, "morphTargetsTextureSize", u.size);
        }
        return {
          update: r
        };
      }
      function I0(s, t, e, i) {
        let n = /* @__PURE__ */ new WeakMap();
        function r(c) {
          const l = i.render.frame, h = c.geometry, d = t.get(c, h);
          if (n.get(d) !== l && (t.update(d), n.set(d, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === false && c.addEventListener("dispose", o), n.get(c) !== l && (e.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && e.update(c.instanceColor, s.ARRAY_BUFFER), n.set(c, l))), c.isSkinnedMesh) {
            const u = c.skeleton;
            n.get(u) !== l && (u.update(), n.set(u, l));
          }
          return d;
        }
        function a() {
          n = /* @__PURE__ */ new WeakMap();
        }
        function o(c) {
          const l = c.target;
          l.removeEventListener("dispose", o), e.remove(l.instanceMatrix), l.instanceColor !== null && e.remove(l.instanceColor);
        }
        return {
          update: r,
          dispose: a
        };
      }
      const Jp = new Pe(), Yu = new Mp(1, 1), Zp = new _p(), $p = new mp(), tA = new Hh(), Ku = [], Ju = [], Zu = new Float32Array(16), $u = new Float32Array(9), tf = new Float32Array(4);
      function _s(s, t, e) {
        const i = s[0];
        if (i <= 0 || i > 0) return s;
        const n = t * e;
        let r = Ku[n];
        if (r === void 0 && (r = new Float32Array(n), Ku[n] = r), t !== 0) {
          i.toArray(r, 0);
          for (let a = 1, o = 0; a !== t; ++a) o += e, s[a].toArray(r, o);
        }
        return r;
      }
      function je(s, t) {
        if (s.length !== t.length) return false;
        for (let e = 0, i = s.length; e < i; e++) if (s[e] !== t[e]) return false;
        return true;
      }
      function qe(s, t) {
        for (let e = 0, i = t.length; e < i; e++) s[e] = t[e];
      }
      function ic(s, t) {
        let e = Ju[t];
        e === void 0 && (e = new Int32Array(t), Ju[t] = e);
        for (let i = 0; i !== t; ++i) e[i] = s.allocateTextureUnit();
        return e;
      }
      function M0(s, t) {
        const e = this.cache;
        e[0] !== t && (s.uniform1f(this.addr, t), e[0] = t);
      }
      function T0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (je(e, t)) return;
          s.uniform2fv(this.addr, t), qe(e, t);
        }
      }
      function R0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (s.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
        else {
          if (je(e, t)) return;
          s.uniform3fv(this.addr, t), qe(e, t);
        }
      }
      function B0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (je(e, t)) return;
          s.uniform4fv(this.addr, t), qe(e, t);
        }
      }
      function D0(s, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (je(e, t)) return;
          s.uniformMatrix2fv(this.addr, false, t), qe(e, t);
        } else {
          if (je(e, i)) return;
          tf.set(i), s.uniformMatrix2fv(this.addr, false, tf), qe(e, i);
        }
      }
      function P0(s, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (je(e, t)) return;
          s.uniformMatrix3fv(this.addr, false, t), qe(e, t);
        } else {
          if (je(e, i)) return;
          $u.set(i), s.uniformMatrix3fv(this.addr, false, $u), qe(e, i);
        }
      }
      function F0(s, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (je(e, t)) return;
          s.uniformMatrix4fv(this.addr, false, t), qe(e, t);
        } else {
          if (je(e, i)) return;
          Zu.set(i), s.uniformMatrix4fv(this.addr, false, Zu), qe(e, i);
        }
      }
      function L0(s, t) {
        const e = this.cache;
        e[0] !== t && (s.uniform1i(this.addr, t), e[0] = t);
      }
      function k0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (je(e, t)) return;
          s.uniform2iv(this.addr, t), qe(e, t);
        }
      }
      function N0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
          if (je(e, t)) return;
          s.uniform3iv(this.addr, t), qe(e, t);
        }
      }
      function U0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (je(e, t)) return;
          s.uniform4iv(this.addr, t), qe(e, t);
        }
      }
      function Q0(s, t) {
        const e = this.cache;
        e[0] !== t && (s.uniform1ui(this.addr, t), e[0] = t);
      }
      function O0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (je(e, t)) return;
          s.uniform2uiv(this.addr, t), qe(e, t);
        }
      }
      function z0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
          if (je(e, t)) return;
          s.uniform3uiv(this.addr, t), qe(e, t);
        }
      }
      function G0(s, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (je(e, t)) return;
          s.uniform4uiv(this.addr, t), qe(e, t);
        }
      }
      function H0(s, t, e) {
        const i = this.cache, n = e.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n);
        let r;
        this.type === s.SAMPLER_2D_SHADOW ? (Yu.compareFunction = Ap, r = Yu) : r = Jp, e.setTexture2D(t || r, n);
      }
      function V0(s, t, e) {
        const i = this.cache, n = e.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), e.setTexture3D(t || $p, n);
      }
      function W0(s, t, e) {
        const i = this.cache, n = e.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), e.setTextureCube(t || tA, n);
      }
      function j0(s, t, e) {
        const i = this.cache, n = e.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), e.setTexture2DArray(t || Zp, n);
      }
      function q0(s) {
        switch (s) {
          case 5126:
            return M0;
          case 35664:
            return T0;
          case 35665:
            return R0;
          case 35666:
            return B0;
          case 35674:
            return D0;
          case 35675:
            return P0;
          case 35676:
            return F0;
          case 5124:
          case 35670:
            return L0;
          case 35667:
          case 35671:
            return k0;
          case 35668:
          case 35672:
            return N0;
          case 35669:
          case 35673:
            return U0;
          case 5125:
            return Q0;
          case 36294:
            return O0;
          case 36295:
            return z0;
          case 36296:
            return G0;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return H0;
          case 35679:
          case 36299:
          case 36307:
            return V0;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return W0;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return j0;
        }
      }
      function X0(s, t) {
        s.uniform1fv(this.addr, t);
      }
      function Y0(s, t) {
        const e = _s(t, this.size, 2);
        s.uniform2fv(this.addr, e);
      }
      function K0(s, t) {
        const e = _s(t, this.size, 3);
        s.uniform3fv(this.addr, e);
      }
      function J0(s, t) {
        const e = _s(t, this.size, 4);
        s.uniform4fv(this.addr, e);
      }
      function Z0(s, t) {
        const e = _s(t, this.size, 4);
        s.uniformMatrix2fv(this.addr, false, e);
      }
      function $0(s, t) {
        const e = _s(t, this.size, 9);
        s.uniformMatrix3fv(this.addr, false, e);
      }
      function tx(s, t) {
        const e = _s(t, this.size, 16);
        s.uniformMatrix4fv(this.addr, false, e);
      }
      function ex(s, t) {
        s.uniform1iv(this.addr, t);
      }
      function ix(s, t) {
        s.uniform2iv(this.addr, t);
      }
      function nx(s, t) {
        s.uniform3iv(this.addr, t);
      }
      function rx(s, t) {
        s.uniform4iv(this.addr, t);
      }
      function sx(s, t) {
        s.uniform1uiv(this.addr, t);
      }
      function ax(s, t) {
        s.uniform2uiv(this.addr, t);
      }
      function ox(s, t) {
        s.uniform3uiv(this.addr, t);
      }
      function cx(s, t) {
        s.uniform4uiv(this.addr, t);
      }
      function lx(s, t, e) {
        const i = this.cache, n = t.length, r = ic(e, n);
        je(i, r) || (s.uniform1iv(this.addr, r), qe(i, r));
        for (let a = 0; a !== n; ++a) e.setTexture2D(t[a] || Jp, r[a]);
      }
      function hx(s, t, e) {
        const i = this.cache, n = t.length, r = ic(e, n);
        je(i, r) || (s.uniform1iv(this.addr, r), qe(i, r));
        for (let a = 0; a !== n; ++a) e.setTexture3D(t[a] || $p, r[a]);
      }
      function dx(s, t, e) {
        const i = this.cache, n = t.length, r = ic(e, n);
        je(i, r) || (s.uniform1iv(this.addr, r), qe(i, r));
        for (let a = 0; a !== n; ++a) e.setTextureCube(t[a] || tA, r[a]);
      }
      function ux(s, t, e) {
        const i = this.cache, n = t.length, r = ic(e, n);
        je(i, r) || (s.uniform1iv(this.addr, r), qe(i, r));
        for (let a = 0; a !== n; ++a) e.setTexture2DArray(t[a] || Zp, r[a]);
      }
      function fx(s) {
        switch (s) {
          case 5126:
            return X0;
          case 35664:
            return Y0;
          case 35665:
            return K0;
          case 35666:
            return J0;
          case 35674:
            return Z0;
          case 35675:
            return $0;
          case 35676:
            return tx;
          case 5124:
          case 35670:
            return ex;
          case 35667:
          case 35671:
            return ix;
          case 35668:
          case 35672:
            return nx;
          case 35669:
          case 35673:
            return rx;
          case 5125:
            return sx;
          case 36294:
            return ax;
          case 36295:
            return ox;
          case 36296:
            return cx;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return lx;
          case 35679:
          case 36299:
          case 36307:
            return hx;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return dx;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return ux;
        }
      }
      class px {
        constructor(t, e, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.setValue = q0(e.type);
        }
      }
      class Ax {
        constructor(t, e, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = fx(e.type);
        }
      }
      class gx {
        constructor(t) {
          this.id = t, this.seq = [], this.map = {};
        }
        setValue(t, e, i) {
          const n = this.seq;
          for (let r = 0, a = n.length; r !== a; ++r) {
            const o = n[r];
            o.setValue(t, e[o.id], i);
          }
        }
      }
      const el = /(\w+)(\])?(\[|\.)?/g;
      function ef(s, t) {
        s.seq.push(t), s.map[t.id] = t;
      }
      function _x(s, t, e) {
        const i = s.name, n = i.length;
        for (el.lastIndex = 0; ; ) {
          const r = el.exec(i), a = el.lastIndex;
          let o = r[1];
          const c = r[2] === "]", l = r[3];
          if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === n) {
            ef(e, l === void 0 ? new px(o, s, t) : new Ax(o, s, t));
            break;
          } else {
            let d = e.map[o];
            d === void 0 && (d = new gx(o), ef(e, d)), e = d;
          }
        }
      }
      class vo {
        constructor(t, e) {
          this.seq = [], this.map = {};
          const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
          for (let n = 0; n < i; ++n) {
            const r = t.getActiveUniform(e, n), a = t.getUniformLocation(e, r.name);
            _x(r, a, this);
          }
        }
        setValue(t, e, i, n) {
          const r = this.map[e];
          r !== void 0 && r.setValue(t, i, n);
        }
        setOptional(t, e, i) {
          const n = e[i];
          n !== void 0 && this.setValue(t, i, n);
        }
        static upload(t, e, i, n) {
          for (let r = 0, a = e.length; r !== a; ++r) {
            const o = e[r], c = i[o.id];
            c.needsUpdate !== false && o.setValue(t, c.value, n);
          }
        }
        static seqWithValue(t, e) {
          const i = [];
          for (let n = 0, r = t.length; n !== r; ++n) {
            const a = t[n];
            a.id in e && i.push(a);
          }
          return i;
        }
      }
      function nf(s, t, e) {
        const i = s.createShader(t);
        return s.shaderSource(i, e), s.compileShader(i), i;
      }
      const mx = 37297;
      let wx = 0;
      function bx(s, t) {
        const e = s.split(`
`), i = [], n = Math.max(t - 6, 0), r = Math.min(t + 6, e.length);
        for (let a = n; a < r; a++) {
          const o = a + 1;
          i.push(`${o === t ? ">" : " "} ${o}: ${e[a]}`);
        }
        return i.join(`
`);
      }
      const rf = new Ot();
      function yx(s) {
        zt._getMatrix(rf, zt.workingColorSpace, s);
        const t = `mat3( ${rf.elements.map((e) => e.toFixed(4))} )`;
        switch (zt.getTransfer(s)) {
          case Fo:
            return [
              t,
              "LinearTransferOETF"
            ];
          case ge:
            return [
              t,
              "sRGBTransferOETF"
            ];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [
              t,
              "LinearTransferOETF"
            ];
        }
      }
      function sf(s, t, e) {
        const i = s.getShaderParameter(t, s.COMPILE_STATUS), n = s.getShaderInfoLog(t).trim();
        if (i && n === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(n);
        if (r) {
          const a = parseInt(r[1]);
          return e.toUpperCase() + `

` + n + `

` + bx(s.getShaderSource(t), a);
        } else return n;
      }
      function xx(s, t) {
        const e = yx(t);
        return [
          `vec4 ${s}( vec4 value ) {`,
          `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
          "}"
        ].join(`
`);
      }
      function vx(s, t) {
        let e;
        switch (t) {
          case qg:
            e = "Linear";
            break;
          case Xg:
            e = "Reinhard";
            break;
          case Yg:
            e = "Cineon";
            break;
          case Kg:
            e = "ACESFilmic";
            break;
          case Zg:
            e = "AgX";
            break;
          case $g:
            e = "Neutral";
            break;
          case Jg:
            e = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
        }
        return "vec3 " + s + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
      }
      const co = new I();
      function Ex() {
        zt.getLuminanceCoefficients(co);
        const s = co.x.toFixed(4), t = co.y.toFixed(4), e = co.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${s}, ${t}, ${e} );`,
          "	return dot( weights, rgb );",
          "}"
        ].join(`
`);
      }
      function Sx(s) {
        return [
          s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(Ls).join(`
`);
      }
      function Cx(s) {
        const t = [];
        for (const e in s) {
          const i = s[e];
          i !== false && t.push("#define " + e + " " + i);
        }
        return t.join(`
`);
      }
      function Ix(s, t) {
        const e = {}, i = s.getProgramParameter(t, s.ACTIVE_ATTRIBUTES);
        for (let n = 0; n < i; n++) {
          const r = s.getActiveAttrib(t, n), a = r.name;
          let o = 1;
          r.type === s.FLOAT_MAT2 && (o = 2), r.type === s.FLOAT_MAT3 && (o = 3), r.type === s.FLOAT_MAT4 && (o = 4), e[a] = {
            type: r.type,
            location: s.getAttribLocation(t, a),
            locationSize: o
          };
        }
        return e;
      }
      function Ls(s) {
        return s !== "";
      }
      function af(s, t) {
        const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return s.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function of(s, t) {
        return s.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      const Mx = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function dh(s) {
        return s.replace(Mx, Rx);
      }
      const Tx = /* @__PURE__ */ new Map();
      function Rx(s, t) {
        let e = Qt[t];
        if (e === void 0) {
          const i = Tx.get(t);
          if (i !== void 0) e = Qt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
          else throw new Error("Can not resolve #include <" + t + ">");
        }
        return dh(e);
      }
      const Bx = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function cf(s) {
        return s.replace(Bx, Dx);
      }
      function Dx(s, t, e, i) {
        let n = "";
        for (let r = parseInt(t); r < parseInt(e); r++) n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return n;
      }
      function lf(s) {
        let t = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
        return s.precision === "highp" ? t += `
#define HIGH_PRECISION` : s.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
      }
      function Px(s) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return s.shadowMapType === ip ? t = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === np ? t = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === mn && (t = "SHADOWMAP_TYPE_VSM"), t;
      }
      function Fx(s) {
        let t = "ENVMAP_TYPE_CUBE";
        if (s.envMap) switch (s.envMapMode) {
          case gr:
          case as:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case Xo:
            t = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
        return t;
      }
      function Lx(s) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (s.envMap) switch (s.envMapMode) {
          case as:
            t = "ENVMAP_MODE_REFRACTION";
            break;
        }
        return t;
      }
      function kx(s) {
        let t = "ENVMAP_BLENDING_NONE";
        if (s.envMap) switch (s.combine) {
          case qo:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case Wg:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case jg:
            t = "ENVMAP_BLENDING_ADD";
            break;
        }
        return t;
      }
      function Nx(s) {
        const t = s.envMapCubeUVHeight;
        if (t === null) return null;
        const e = Math.log2(t) - 2, i = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
          texelHeight: i,
          maxMip: e
        };
      }
      function Ux(s, t, e, i) {
        const n = s.getContext(), r = e.defines;
        let a = e.vertexShader, o = e.fragmentShader;
        const c = Px(e), l = Fx(e), h = Lx(e), d = kx(e), u = Nx(e), f = Sx(e), p = Cx(r), m = n.createProgram();
        let g, A, x = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
        e.isRawShaderMaterial ? (g = [
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          p
        ].filter(Ls).join(`
`), g.length > 0 && (g += `
`), A = [
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          p
        ].filter(Ls).join(`
`), A.length > 0 && (A += `
`)) : (g = [
          lf(e),
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          p,
          e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          e.batching ? "#define USE_BATCHING" : "",
          e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
          e.instancing ? "#define USE_INSTANCING" : "",
          e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          e.useFog && e.fog ? "#define USE_FOG" : "",
          e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
          e.map ? "#define USE_MAP" : "",
          e.envMap ? "#define USE_ENVMAP" : "",
          e.envMap ? "#define " + h : "",
          e.lightMap ? "#define USE_LIGHTMAP" : "",
          e.aoMap ? "#define USE_AOMAP" : "",
          e.bumpMap ? "#define USE_BUMPMAP" : "",
          e.normalMap ? "#define USE_NORMALMAP" : "",
          e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          e.anisotropy ? "#define USE_ANISOTROPY" : "",
          e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          e.specularMap ? "#define USE_SPECULARMAP" : "",
          e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          e.metalnessMap ? "#define USE_METALNESSMAP" : "",
          e.alphaMap ? "#define USE_ALPHAMAP" : "",
          e.alphaHash ? "#define USE_ALPHAHASH" : "",
          e.transmission ? "#define USE_TRANSMISSION" : "",
          e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          e.mapUv ? "#define MAP_UV " + e.mapUv : "",
          e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
          e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
          e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
          e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
          e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
          e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
          e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
          e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
          e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
          e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
          e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
          e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
          e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
          e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
          e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
          e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
          e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
          e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
          e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
          e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
          e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
          e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
          e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
          e.vertexColors ? "#define USE_COLOR" : "",
          e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          e.vertexUv1s ? "#define USE_UV1" : "",
          e.vertexUv2s ? "#define USE_UV2" : "",
          e.vertexUv3s ? "#define USE_UV3" : "",
          e.pointsUvs ? "#define USE_POINTS_UV" : "",
          e.flatShading ? "#define FLAT_SHADED" : "",
          e.skinning ? "#define USE_SKINNING" : "",
          e.morphTargets ? "#define USE_MORPHTARGETS" : "",
          e.morphNormals && e.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          e.morphColors ? "#define USE_MORPHCOLORS" : "",
          e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
          e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
          e.doubleSided ? "#define DOUBLE_SIDED" : "",
          e.flipSided ? "#define FLIP_SIDED" : "",
          e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          e.shadowMapEnabled ? "#define " + c : "",
          e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "	uniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "	attribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "	attribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "	attribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`
        ].filter(Ls).join(`
`), A = [
          lf(e),
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          p,
          e.useFog && e.fog ? "#define USE_FOG" : "",
          e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
          e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          e.map ? "#define USE_MAP" : "",
          e.matcap ? "#define USE_MATCAP" : "",
          e.envMap ? "#define USE_ENVMAP" : "",
          e.envMap ? "#define " + l : "",
          e.envMap ? "#define " + h : "",
          e.envMap ? "#define " + d : "",
          u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
          u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
          u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
          e.lightMap ? "#define USE_LIGHTMAP" : "",
          e.aoMap ? "#define USE_AOMAP" : "",
          e.bumpMap ? "#define USE_BUMPMAP" : "",
          e.normalMap ? "#define USE_NORMALMAP" : "",
          e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          e.anisotropy ? "#define USE_ANISOTROPY" : "",
          e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          e.clearcoat ? "#define USE_CLEARCOAT" : "",
          e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          e.dispersion ? "#define USE_DISPERSION" : "",
          e.iridescence ? "#define USE_IRIDESCENCE" : "",
          e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          e.specularMap ? "#define USE_SPECULARMAP" : "",
          e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          e.metalnessMap ? "#define USE_METALNESSMAP" : "",
          e.alphaMap ? "#define USE_ALPHAMAP" : "",
          e.alphaTest ? "#define USE_ALPHATEST" : "",
          e.alphaHash ? "#define USE_ALPHAHASH" : "",
          e.sheen ? "#define USE_SHEEN" : "",
          e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          e.transmission ? "#define USE_TRANSMISSION" : "",
          e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
          e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "",
          e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          e.vertexUv1s ? "#define USE_UV1" : "",
          e.vertexUv2s ? "#define USE_UV2" : "",
          e.vertexUv3s ? "#define USE_UV3" : "",
          e.pointsUvs ? "#define USE_POINTS_UV" : "",
          e.gradientMap ? "#define USE_GRADIENTMAP" : "",
          e.flatShading ? "#define FLAT_SHADED" : "",
          e.doubleSided ? "#define DOUBLE_SIDED" : "",
          e.flipSided ? "#define FLIP_SIDED" : "",
          e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          e.shadowMapEnabled ? "#define " + c : "",
          e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          e.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
          e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          e.toneMapping !== Vn ? "#define TONE_MAPPING" : "",
          e.toneMapping !== Vn ? Qt.tonemapping_pars_fragment : "",
          e.toneMapping !== Vn ? vx("toneMapping", e.toneMapping) : "",
          e.dithering ? "#define DITHERING" : "",
          e.opaque ? "#define OPAQUE" : "",
          Qt.colorspace_pars_fragment,
          xx("linearToOutputTexel", e.outputColorSpace),
          Ex(),
          e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
          `
`
        ].filter(Ls).join(`
`)), a = dh(a), a = af(a, e), a = of(a, e), o = dh(o), o = af(o, e), o = of(o, e), a = cf(a), o = cf(o), e.isRawShaderMaterial !== true && (x = `#version 300 es
`, g = [
          f,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + g, A = [
          "#define varying in",
          e.glslVersion === Vd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
          e.glslVersion === Vd ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + A);
        const b = x + g + a, y = x + A + o, M = nf(n, n.VERTEX_SHADER, b), T = nf(n, n.FRAGMENT_SHADER, y);
        n.attachShader(m, M), n.attachShader(m, T), e.index0AttributeName !== void 0 ? n.bindAttribLocation(m, 0, e.index0AttributeName) : e.morphTargets === true && n.bindAttribLocation(m, 0, "position"), n.linkProgram(m);
        function R(P) {
          if (s.debug.checkShaderErrors) {
            const G = n.getProgramInfoLog(m).trim(), H = n.getShaderInfoLog(M).trim(), Y = n.getShaderInfoLog(T).trim();
            let et = true, q = true;
            if (n.getProgramParameter(m, n.LINK_STATUS) === false) if (et = false, typeof s.debug.onShaderError == "function") s.debug.onShaderError(n, m, M, T);
            else {
              const Z = sf(n, M, "vertex"), W = sf(n, T, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(m, n.VALIDATE_STATUS) + `

Material Name: ` + P.name + `
Material Type: ` + P.type + `

Program Info Log: ` + G + `
` + Z + `
` + W);
            }
            else G !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", G) : (H === "" || Y === "") && (q = false);
            q && (P.diagnostics = {
              runnable: et,
              programLog: G,
              vertexShader: {
                log: H,
                prefix: g
              },
              fragmentShader: {
                log: Y,
                prefix: A
              }
            });
          }
          n.deleteShader(M), n.deleteShader(T), B = new vo(n, m), S = Ix(n, m);
        }
        let B;
        this.getUniforms = function() {
          return B === void 0 && R(this), B;
        };
        let S;
        this.getAttributes = function() {
          return S === void 0 && R(this), S;
        };
        let E = e.rendererExtensionParallelShaderCompile === false;
        return this.isReady = function() {
          return E === false && (E = n.getProgramParameter(m, mx)), E;
        }, this.destroy = function() {
          i.releaseStatesOfProgram(this), n.deleteProgram(m), this.program = void 0;
        }, this.type = e.shaderType, this.name = e.shaderName, this.id = wx++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = M, this.fragmentShader = T, this;
      }
      let Qx = 0;
      class Ox {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(t) {
          const e = t.vertexShader, i = t.fragmentShader, n = this._getShaderStage(e), r = this._getShaderStage(i), a = this._getShaderCacheForMaterial(t);
          return a.has(n) === false && (a.add(n), n.usedTimes++), a.has(r) === false && (a.add(r), r.usedTimes++), this;
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const i of e) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          let i = e.get(t);
          return i === void 0 && (i = /* @__PURE__ */ new Set(), e.set(t, i)), i;
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          let i = e.get(t);
          return i === void 0 && (i = new zx(t), e.set(t, i)), i;
        }
      }
      class zx {
        constructor(t) {
          this.id = Qx++, this.code = t, this.usedTimes = 0;
        }
      }
      function Gx(s, t, e, i, n, r, a) {
        const o = new Gh(), c = new Ox(), l = /* @__PURE__ */ new Set(), h = [], d = n.logarithmicDepthBuffer, u = n.vertexTextures;
        let f = n.precision;
        const p = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function m(S) {
          return l.add(S), S === 0 ? "uv" : `uv${S}`;
        }
        function g(S, E, P, G, H) {
          const Y = G.fog, et = H.geometry, q = S.isMeshStandardMaterial ? G.environment : null, Z = (S.isMeshStandardMaterial ? e : t).get(S.envMap || q), W = Z && Z.mapping === Xo ? Z.image.height : null, st = p[S.type];
          S.precision !== null && (f = n.getMaxPrecision(S.precision), f !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", f, "instead."));
          const dt = et.morphAttributes.position || et.morphAttributes.normal || et.morphAttributes.color, Et = dt !== void 0 ? dt.length : 0;
          let Pt = 0;
          et.morphAttributes.position !== void 0 && (Pt = 1), et.morphAttributes.normal !== void 0 && (Pt = 2), et.morphAttributes.color !== void 0 && (Pt = 3);
          let Vt, K, ot, bt;
          if (st) {
            const pe = sn[st];
            Vt = pe.vertexShader, K = pe.fragmentShader;
          } else Vt = S.vertexShader, K = S.fragmentShader, c.update(S), ot = c.getVertexShaderID(S), bt = c.getFragmentShaderID(S);
          const lt = s.getRenderTarget(), Tt = s.state.buffers.depth.getReversed(), Zt = H.isInstancedMesh === true, Ft = H.isBatchedMesh === true, Se = !!S.map, be = !!S.matcap, Kt = !!Z, L = !!S.aoMap, Mi = !!S.lightMap, re = !!S.bumpMap, $t = !!S.normalMap, It = !!S.displacementMap, xe = !!S.emissiveMap, Ct = !!S.metalnessMap, D = !!S.roughnessMap, v = S.anisotropy > 0, z = S.clearcoat > 0, $ = S.dispersion > 0, it = S.iridescence > 0, J = S.sheen > 0, St = S.transmission > 0, pt = v && !!S.anisotropyMap, wt = z && !!S.clearcoatMap, se = z && !!S.clearcoatNormalMap, at = z && !!S.clearcoatRoughnessMap, yt = it && !!S.iridescenceMap, Lt = it && !!S.iridescenceThicknessMap, Nt = J && !!S.sheenColorMap, xt = J && !!S.sheenRoughnessMap, te = !!S.specularMap, qt = !!S.specularColorMap, ye = !!S.specularIntensityMap, U = St && !!S.transmissionMap, At = St && !!S.thicknessMap, X = !!S.gradientMap, tt = !!S.alphaMap, _t = S.alphaTest > 0, gt = !!S.alphaHash, Wt = !!S.extensions;
          let Be = Vn;
          S.toneMapped && (lt === null || lt.isXRRenderTarget === true) && (Be = s.toneMapping);
          const si = {
            shaderID: st,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: Vt,
            fragmentShader: K,
            defines: S.defines,
            customVertexShaderID: ot,
            customFragmentShaderID: bt,
            isRawShaderMaterial: S.isRawShaderMaterial === true,
            glslVersion: S.glslVersion,
            precision: f,
            batching: Ft,
            batchingColor: Ft && H._colorsTexture !== null,
            instancing: Zt,
            instancingColor: Zt && H.instanceColor !== null,
            instancingMorph: Zt && H.morphTexture !== null,
            supportsVertexTextures: u,
            outputColorSpace: lt === null ? s.outputColorSpace : lt.isXRRenderTarget === true ? lt.texture.colorSpace : di,
            alphaToCoverage: !!S.alphaToCoverage,
            map: Se,
            matcap: be,
            envMap: Kt,
            envMapMode: Kt && Z.mapping,
            envMapCubeUVHeight: W,
            aoMap: L,
            lightMap: Mi,
            bumpMap: re,
            normalMap: $t,
            displacementMap: u && It,
            emissiveMap: xe,
            normalMapObjectSpace: $t && S.normalMapType === o_,
            normalMapTangentSpace: $t && S.normalMapType === Ko,
            metalnessMap: Ct,
            roughnessMap: D,
            anisotropy: v,
            anisotropyMap: pt,
            clearcoat: z,
            clearcoatMap: wt,
            clearcoatNormalMap: se,
            clearcoatRoughnessMap: at,
            dispersion: $,
            iridescence: it,
            iridescenceMap: yt,
            iridescenceThicknessMap: Lt,
            sheen: J,
            sheenColorMap: Nt,
            sheenRoughnessMap: xt,
            specularMap: te,
            specularColorMap: qt,
            specularIntensityMap: ye,
            transmission: St,
            transmissionMap: U,
            thicknessMap: At,
            gradientMap: X,
            opaque: S.transparent === false && S.blending === es && S.alphaToCoverage === false,
            alphaMap: tt,
            alphaTest: _t,
            alphaHash: gt,
            combine: S.combine,
            mapUv: Se && m(S.map.channel),
            aoMapUv: L && m(S.aoMap.channel),
            lightMapUv: Mi && m(S.lightMap.channel),
            bumpMapUv: re && m(S.bumpMap.channel),
            normalMapUv: $t && m(S.normalMap.channel),
            displacementMapUv: It && m(S.displacementMap.channel),
            emissiveMapUv: xe && m(S.emissiveMap.channel),
            metalnessMapUv: Ct && m(S.metalnessMap.channel),
            roughnessMapUv: D && m(S.roughnessMap.channel),
            anisotropyMapUv: pt && m(S.anisotropyMap.channel),
            clearcoatMapUv: wt && m(S.clearcoatMap.channel),
            clearcoatNormalMapUv: se && m(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: at && m(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: yt && m(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: Lt && m(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: Nt && m(S.sheenColorMap.channel),
            sheenRoughnessMapUv: xt && m(S.sheenRoughnessMap.channel),
            specularMapUv: te && m(S.specularMap.channel),
            specularColorMapUv: qt && m(S.specularColorMap.channel),
            specularIntensityMapUv: ye && m(S.specularIntensityMap.channel),
            transmissionMapUv: U && m(S.transmissionMap.channel),
            thicknessMapUv: At && m(S.thicknessMap.channel),
            alphaMapUv: tt && m(S.alphaMap.channel),
            vertexTangents: !!et.attributes.tangent && ($t || v),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === true && !!et.attributes.color && et.attributes.color.itemSize === 4,
            pointsUvs: H.isPoints === true && !!et.attributes.uv && (Se || tt),
            fog: !!Y,
            useFog: S.fog === true,
            fogExp2: !!Y && Y.isFogExp2,
            flatShading: S.flatShading === true,
            sizeAttenuation: S.sizeAttenuation === true,
            logarithmicDepthBuffer: d,
            reverseDepthBuffer: Tt,
            skinning: H.isSkinnedMesh === true,
            morphTargets: et.morphAttributes.position !== void 0,
            morphNormals: et.morphAttributes.normal !== void 0,
            morphColors: et.morphAttributes.color !== void 0,
            morphTargetsCount: Et,
            morphTextureStride: Pt,
            numDirLights: E.directional.length,
            numPointLights: E.point.length,
            numSpotLights: E.spot.length,
            numSpotLightMaps: E.spotLightMap.length,
            numRectAreaLights: E.rectArea.length,
            numHemiLights: E.hemi.length,
            numDirLightShadows: E.directionalShadowMap.length,
            numPointLightShadows: E.pointShadowMap.length,
            numSpotLightShadows: E.spotShadowMap.length,
            numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
            numLightProbes: E.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: s.shadowMap.enabled && P.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: Be,
            decodeVideoTexture: Se && S.map.isVideoTexture === true && zt.getTransfer(S.map.colorSpace) === ge,
            decodeVideoTextureEmissive: xe && S.emissiveMap.isVideoTexture === true && zt.getTransfer(S.emissiveMap.colorSpace) === ge,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === Ki,
            flipSided: S.side === yi,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionClipCullDistance: Wt && S.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Wt && S.extensions.multiDraw === true || Ft) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: S.customProgramCacheKey()
          };
          return si.vertexUv1s = l.has(1), si.vertexUv2s = l.has(2), si.vertexUv3s = l.has(3), l.clear(), si;
        }
        function A(S) {
          const E = [];
          if (S.shaderID ? E.push(S.shaderID) : (E.push(S.customVertexShaderID), E.push(S.customFragmentShaderID)), S.defines !== void 0) for (const P in S.defines) E.push(P), E.push(S.defines[P]);
          return S.isRawShaderMaterial === false && (x(E, S), b(E, S), E.push(s.outputColorSpace)), E.push(S.customProgramCacheKey), E.join();
        }
        function x(S, E) {
          S.push(E.precision), S.push(E.outputColorSpace), S.push(E.envMapMode), S.push(E.envMapCubeUVHeight), S.push(E.mapUv), S.push(E.alphaMapUv), S.push(E.lightMapUv), S.push(E.aoMapUv), S.push(E.bumpMapUv), S.push(E.normalMapUv), S.push(E.displacementMapUv), S.push(E.emissiveMapUv), S.push(E.metalnessMapUv), S.push(E.roughnessMapUv), S.push(E.anisotropyMapUv), S.push(E.clearcoatMapUv), S.push(E.clearcoatNormalMapUv), S.push(E.clearcoatRoughnessMapUv), S.push(E.iridescenceMapUv), S.push(E.iridescenceThicknessMapUv), S.push(E.sheenColorMapUv), S.push(E.sheenRoughnessMapUv), S.push(E.specularMapUv), S.push(E.specularColorMapUv), S.push(E.specularIntensityMapUv), S.push(E.transmissionMapUv), S.push(E.thicknessMapUv), S.push(E.combine), S.push(E.fogExp2), S.push(E.sizeAttenuation), S.push(E.morphTargetsCount), S.push(E.morphAttributeCount), S.push(E.numDirLights), S.push(E.numPointLights), S.push(E.numSpotLights), S.push(E.numSpotLightMaps), S.push(E.numHemiLights), S.push(E.numRectAreaLights), S.push(E.numDirLightShadows), S.push(E.numPointLightShadows), S.push(E.numSpotLightShadows), S.push(E.numSpotLightShadowsWithMaps), S.push(E.numLightProbes), S.push(E.shadowMapType), S.push(E.toneMapping), S.push(E.numClippingPlanes), S.push(E.numClipIntersection), S.push(E.depthPacking);
        }
        function b(S, E) {
          o.disableAll(), E.supportsVertexTextures && o.enable(0), E.instancing && o.enable(1), E.instancingColor && o.enable(2), E.instancingMorph && o.enable(3), E.matcap && o.enable(4), E.envMap && o.enable(5), E.normalMapObjectSpace && o.enable(6), E.normalMapTangentSpace && o.enable(7), E.clearcoat && o.enable(8), E.iridescence && o.enable(9), E.alphaTest && o.enable(10), E.vertexColors && o.enable(11), E.vertexAlphas && o.enable(12), E.vertexUv1s && o.enable(13), E.vertexUv2s && o.enable(14), E.vertexUv3s && o.enable(15), E.vertexTangents && o.enable(16), E.anisotropy && o.enable(17), E.alphaHash && o.enable(18), E.batching && o.enable(19), E.dispersion && o.enable(20), E.batchingColor && o.enable(21), S.push(o.mask), o.disableAll(), E.fog && o.enable(0), E.useFog && o.enable(1), E.flatShading && o.enable(2), E.logarithmicDepthBuffer && o.enable(3), E.reverseDepthBuffer && o.enable(4), E.skinning && o.enable(5), E.morphTargets && o.enable(6), E.morphNormals && o.enable(7), E.morphColors && o.enable(8), E.premultipliedAlpha && o.enable(9), E.shadowMapEnabled && o.enable(10), E.doubleSided && o.enable(11), E.flipSided && o.enable(12), E.useDepthPacking && o.enable(13), E.dithering && o.enable(14), E.transmission && o.enable(15), E.sheen && o.enable(16), E.opaque && o.enable(17), E.pointsUvs && o.enable(18), E.decodeVideoTexture && o.enable(19), E.decodeVideoTextureEmissive && o.enable(20), E.alphaToCoverage && o.enable(21), S.push(o.mask);
        }
        function y(S) {
          const E = p[S.type];
          let P;
          if (E) {
            const G = sn[E];
            P = Zo.clone(G.uniforms);
          } else P = S.uniforms;
          return P;
        }
        function M(S, E) {
          let P;
          for (let G = 0, H = h.length; G < H; G++) {
            const Y = h[G];
            if (Y.cacheKey === E) {
              P = Y, ++P.usedTimes;
              break;
            }
          }
          return P === void 0 && (P = new Ux(s, E, S, r), h.push(P)), P;
        }
        function T(S) {
          if (--S.usedTimes === 0) {
            const E = h.indexOf(S);
            h[E] = h[h.length - 1], h.pop(), S.destroy();
          }
        }
        function R(S) {
          c.remove(S);
        }
        function B() {
          c.dispose();
        }
        return {
          getParameters: g,
          getProgramCacheKey: A,
          getUniforms: y,
          acquireProgram: M,
          releaseProgram: T,
          releaseShaderCache: R,
          programs: h,
          dispose: B
        };
      }
      function Hx() {
        let s = /* @__PURE__ */ new WeakMap();
        function t(a) {
          return s.has(a);
        }
        function e(a) {
          let o = s.get(a);
          return o === void 0 && (o = {}, s.set(a, o)), o;
        }
        function i(a) {
          s.delete(a);
        }
        function n(a, o, c) {
          s.get(a)[o] = c;
        }
        function r() {
          s = /* @__PURE__ */ new WeakMap();
        }
        return {
          has: t,
          get: e,
          remove: i,
          update: n,
          dispose: r
        };
      }
      function Vx(s, t) {
        return s.groupOrder !== t.groupOrder ? s.groupOrder - t.groupOrder : s.renderOrder !== t.renderOrder ? s.renderOrder - t.renderOrder : s.material.id !== t.material.id ? s.material.id - t.material.id : s.z !== t.z ? s.z - t.z : s.id - t.id;
      }
      function hf(s, t) {
        return s.groupOrder !== t.groupOrder ? s.groupOrder - t.groupOrder : s.renderOrder !== t.renderOrder ? s.renderOrder - t.renderOrder : s.z !== t.z ? t.z - s.z : s.id - t.id;
      }
      function df() {
        const s = [];
        let t = 0;
        const e = [], i = [], n = [];
        function r() {
          t = 0, e.length = 0, i.length = 0, n.length = 0;
        }
        function a(d, u, f, p, m, g) {
          let A = s[t];
          return A === void 0 ? (A = {
            id: d.id,
            object: d,
            geometry: u,
            material: f,
            groupOrder: p,
            renderOrder: d.renderOrder,
            z: m,
            group: g
          }, s[t] = A) : (A.id = d.id, A.object = d, A.geometry = u, A.material = f, A.groupOrder = p, A.renderOrder = d.renderOrder, A.z = m, A.group = g), t++, A;
        }
        function o(d, u, f, p, m, g) {
          const A = a(d, u, f, p, m, g);
          f.transmission > 0 ? i.push(A) : f.transparent === true ? n.push(A) : e.push(A);
        }
        function c(d, u, f, p, m, g) {
          const A = a(d, u, f, p, m, g);
          f.transmission > 0 ? i.unshift(A) : f.transparent === true ? n.unshift(A) : e.unshift(A);
        }
        function l(d, u) {
          e.length > 1 && e.sort(d || Vx), i.length > 1 && i.sort(u || hf), n.length > 1 && n.sort(u || hf);
        }
        function h() {
          for (let d = t, u = s.length; d < u; d++) {
            const f = s[d];
            if (f.id === null) break;
            f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
          }
        }
        return {
          opaque: e,
          transmissive: i,
          transparent: n,
          init: r,
          push: o,
          unshift: c,
          finish: h,
          sort: l
        };
      }
      function Wx() {
        let s = /* @__PURE__ */ new WeakMap();
        function t(i, n) {
          const r = s.get(i);
          let a;
          return r === void 0 ? (a = new df(), s.set(i, [
            a
          ])) : n >= r.length ? (a = new df(), r.push(a)) : a = r[n], a;
        }
        function e() {
          s = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: t,
          dispose: e
        };
      }
      function jx() {
        const s = {};
        return {
          get: function(t) {
            if (s[t.id] !== void 0) return s[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = {
                  direction: new I(),
                  color: new ht()
                };
                break;
              case "SpotLight":
                e = {
                  position: new I(),
                  direction: new I(),
                  color: new ht(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                e = {
                  position: new I(),
                  color: new ht(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                e = {
                  direction: new I(),
                  skyColor: new ht(),
                  groundColor: new ht()
                };
                break;
              case "RectAreaLight":
                e = {
                  color: new ht(),
                  position: new I(),
                  halfWidth: new I(),
                  halfHeight: new I()
                };
                break;
            }
            return s[t.id] = e, e;
          }
        };
      }
      function qx() {
        const s = {};
        return {
          get: function(t) {
            if (s[t.id] !== void 0) return s[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new rt()
                };
                break;
              case "SpotLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new rt()
                };
                break;
              case "PointLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new rt(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            return s[t.id] = e, e;
          }
        };
      }
      let Xx = 0;
      function Yx(s, t) {
        return (t.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (s.map ? 1 : 0);
      }
      function Kx(s) {
        const t = new jx(), e = qx(), i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
          },
          ambient: [
            0,
            0,
            0
          ],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
        };
        for (let l = 0; l < 9; l++) i.probe.push(new I());
        const n = new I(), r = new ft(), a = new ft();
        function o(l) {
          let h = 0, d = 0, u = 0;
          for (let S = 0; S < 9; S++) i.probe[S].set(0, 0, 0);
          let f = 0, p = 0, m = 0, g = 0, A = 0, x = 0, b = 0, y = 0, M = 0, T = 0, R = 0;
          l.sort(Yx);
          for (let S = 0, E = l.length; S < E; S++) {
            const P = l[S], G = P.color, H = P.intensity, Y = P.distance, et = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
            if (P.isAmbientLight) h += G.r * H, d += G.g * H, u += G.b * H;
            else if (P.isLightProbe) {
              for (let q = 0; q < 9; q++) i.probe[q].addScaledVector(P.sh.coefficients[q], H);
              R++;
            } else if (P.isDirectionalLight) {
              const q = t.get(P);
              if (q.color.copy(P.color).multiplyScalar(P.intensity), P.castShadow) {
                const Z = P.shadow, W = e.get(P);
                W.shadowIntensity = Z.intensity, W.shadowBias = Z.bias, W.shadowNormalBias = Z.normalBias, W.shadowRadius = Z.radius, W.shadowMapSize = Z.mapSize, i.directionalShadow[f] = W, i.directionalShadowMap[f] = et, i.directionalShadowMatrix[f] = P.shadow.matrix, x++;
              }
              i.directional[f] = q, f++;
            } else if (P.isSpotLight) {
              const q = t.get(P);
              q.position.setFromMatrixPosition(P.matrixWorld), q.color.copy(G).multiplyScalar(H), q.distance = Y, q.coneCos = Math.cos(P.angle), q.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), q.decay = P.decay, i.spot[m] = q;
              const Z = P.shadow;
              if (P.map && (i.spotLightMap[M] = P.map, M++, Z.updateMatrices(P), P.castShadow && T++), i.spotLightMatrix[m] = Z.matrix, P.castShadow) {
                const W = e.get(P);
                W.shadowIntensity = Z.intensity, W.shadowBias = Z.bias, W.shadowNormalBias = Z.normalBias, W.shadowRadius = Z.radius, W.shadowMapSize = Z.mapSize, i.spotShadow[m] = W, i.spotShadowMap[m] = et, y++;
              }
              m++;
            } else if (P.isRectAreaLight) {
              const q = t.get(P);
              q.color.copy(G).multiplyScalar(H), q.halfWidth.set(P.width * 0.5, 0, 0), q.halfHeight.set(0, P.height * 0.5, 0), i.rectArea[g] = q, g++;
            } else if (P.isPointLight) {
              const q = t.get(P);
              if (q.color.copy(P.color).multiplyScalar(P.intensity), q.distance = P.distance, q.decay = P.decay, P.castShadow) {
                const Z = P.shadow, W = e.get(P);
                W.shadowIntensity = Z.intensity, W.shadowBias = Z.bias, W.shadowNormalBias = Z.normalBias, W.shadowRadius = Z.radius, W.shadowMapSize = Z.mapSize, W.shadowCameraNear = Z.camera.near, W.shadowCameraFar = Z.camera.far, i.pointShadow[p] = W, i.pointShadowMap[p] = et, i.pointShadowMatrix[p] = P.shadow.matrix, b++;
              }
              i.point[p] = q, p++;
            } else if (P.isHemisphereLight) {
              const q = t.get(P);
              q.skyColor.copy(P.color).multiplyScalar(H), q.groundColor.copy(P.groundColor).multiplyScalar(H), i.hemi[A] = q, A++;
            }
          }
          g > 0 && (s.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = ct.LTC_FLOAT_1, i.rectAreaLTC2 = ct.LTC_FLOAT_2) : (i.rectAreaLTC1 = ct.LTC_HALF_1, i.rectAreaLTC2 = ct.LTC_HALF_2)), i.ambient[0] = h, i.ambient[1] = d, i.ambient[2] = u;
          const B = i.hash;
          (B.directionalLength !== f || B.pointLength !== p || B.spotLength !== m || B.rectAreaLength !== g || B.hemiLength !== A || B.numDirectionalShadows !== x || B.numPointShadows !== b || B.numSpotShadows !== y || B.numSpotMaps !== M || B.numLightProbes !== R) && (i.directional.length = f, i.spot.length = m, i.rectArea.length = g, i.point.length = p, i.hemi.length = A, i.directionalShadow.length = x, i.directionalShadowMap.length = x, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = y, i.spotShadowMap.length = y, i.directionalShadowMatrix.length = x, i.pointShadowMatrix.length = b, i.spotLightMatrix.length = y + M - T, i.spotLightMap.length = M, i.numSpotLightShadowsWithMaps = T, i.numLightProbes = R, B.directionalLength = f, B.pointLength = p, B.spotLength = m, B.rectAreaLength = g, B.hemiLength = A, B.numDirectionalShadows = x, B.numPointShadows = b, B.numSpotShadows = y, B.numSpotMaps = M, B.numLightProbes = R, i.version = Xx++);
        }
        function c(l, h) {
          let d = 0, u = 0, f = 0, p = 0, m = 0;
          const g = h.matrixWorldInverse;
          for (let A = 0, x = l.length; A < x; A++) {
            const b = l[A];
            if (b.isDirectionalLight) {
              const y = i.directional[d];
              y.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), y.direction.sub(n), y.direction.transformDirection(g), d++;
            } else if (b.isSpotLight) {
              const y = i.spot[f];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), y.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), y.direction.sub(n), y.direction.transformDirection(g), f++;
            } else if (b.isRectAreaLight) {
              const y = i.rectArea[p];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), a.identity(), r.copy(b.matrixWorld), r.premultiply(g), a.extractRotation(r), y.halfWidth.set(b.width * 0.5, 0, 0), y.halfHeight.set(0, b.height * 0.5, 0), y.halfWidth.applyMatrix4(a), y.halfHeight.applyMatrix4(a), p++;
            } else if (b.isPointLight) {
              const y = i.point[u];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), u++;
            } else if (b.isHemisphereLight) {
              const y = i.hemi[m];
              y.direction.setFromMatrixPosition(b.matrixWorld), y.direction.transformDirection(g), m++;
            }
          }
        }
        return {
          setup: o,
          setupView: c,
          state: i
        };
      }
      function uf(s) {
        const t = new Kx(s), e = [], i = [];
        function n(h) {
          l.camera = h, e.length = 0, i.length = 0;
        }
        function r(h) {
          e.push(h);
        }
        function a(h) {
          i.push(h);
        }
        function o() {
          t.setup(e);
        }
        function c(h) {
          t.setupView(e, h);
        }
        const l = {
          lightsArray: e,
          shadowsArray: i,
          camera: null,
          lights: t,
          transmissionRenderTarget: {}
        };
        return {
          init: n,
          state: l,
          setupLights: o,
          setupLightsView: c,
          pushLight: r,
          pushShadow: a
        };
      }
      function Jx(s) {
        let t = /* @__PURE__ */ new WeakMap();
        function e(n, r = 0) {
          const a = t.get(n);
          let o;
          return a === void 0 ? (o = new uf(s), t.set(n, [
            o
          ])) : r >= a.length ? (o = new uf(s), a.push(o)) : o = a[r], o;
        }
        function i() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: e,
          dispose: i
        };
      }
      const Zx = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, $x = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function tv(s, t, e) {
        let i = new jh();
        const n = new rt(), r = new rt(), a = new jt(), o = new qm({
          depthPacking: a_
        }), c = new Xm(), l = {}, h = e.maxTextureSize, d = {
          [Cn]: yi,
          [yi]: Cn,
          [Ki]: Ki
        }, u = new Ni({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new rt()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: Zx,
          fragmentShader: $x
        }), f = u.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const p = new Fe();
        p.setAttribute("position", new ri(new Float32Array([
          -1,
          -1,
          0.5,
          3,
          -1,
          0.5,
          -1,
          3,
          0.5
        ]), 3));
        const m = new me(p, u), g = this;
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = ip;
        let A = this.type;
        this.render = function(T, R, B) {
          if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || T.length === 0) return;
          const S = s.getRenderTarget(), E = s.getActiveCubeFace(), P = s.getActiveMipmapLevel(), G = s.state;
          G.setBlending(Hn), G.buffers.color.setClear(1, 1, 1, 1), G.buffers.depth.setTest(true), G.setScissorTest(false);
          const H = A !== mn && this.type === mn, Y = A === mn && this.type !== mn;
          for (let et = 0, q = T.length; et < q; et++) {
            const Z = T[et], W = Z.shadow;
            if (W === void 0) {
              console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
              continue;
            }
            if (W.autoUpdate === false && W.needsUpdate === false) continue;
            n.copy(W.mapSize);
            const st = W.getFrameExtents();
            if (n.multiply(st), r.copy(W.mapSize), (n.x > h || n.y > h) && (n.x > h && (r.x = Math.floor(h / st.x), n.x = r.x * st.x, W.mapSize.x = r.x), n.y > h && (r.y = Math.floor(h / st.y), n.y = r.y * st.y, W.mapSize.y = r.y)), W.map === null || H === true || Y === true) {
              const Et = this.type !== mn ? {
                minFilter: mi,
                magFilter: mi
              } : {};
              W.map !== null && W.map.dispose(), W.map = new In(n.x, n.y, Et), W.map.texture.name = Z.name + ".shadowMap", W.camera.updateProjectionMatrix();
            }
            s.setRenderTarget(W.map), s.clear();
            const dt = W.getViewportCount();
            for (let Et = 0; Et < dt; Et++) {
              const Pt = W.getViewport(Et);
              a.set(r.x * Pt.x, r.y * Pt.y, r.x * Pt.z, r.y * Pt.w), G.viewport(a), W.updateMatrices(Z, Et), i = W.getFrustum(), y(R, B, W.camera, Z, this.type);
            }
            W.isPointLightShadow !== true && this.type === mn && x(W, B), W.needsUpdate = false;
          }
          A = this.type, g.needsUpdate = false, s.setRenderTarget(S, E, P);
        };
        function x(T, R) {
          const B = t.update(m);
          u.defines.VSM_SAMPLES !== T.blurSamples && (u.defines.VSM_SAMPLES = T.blurSamples, f.defines.VSM_SAMPLES = T.blurSamples, u.needsUpdate = true, f.needsUpdate = true), T.mapPass === null && (T.mapPass = new In(n.x, n.y)), u.uniforms.shadow_pass.value = T.map.texture, u.uniforms.resolution.value = T.mapSize, u.uniforms.radius.value = T.radius, s.setRenderTarget(T.mapPass), s.clear(), s.renderBufferDirect(R, null, B, u, m, null), f.uniforms.shadow_pass.value = T.mapPass.texture, f.uniforms.resolution.value = T.mapSize, f.uniforms.radius.value = T.radius, s.setRenderTarget(T.map), s.clear(), s.renderBufferDirect(R, null, B, f, m, null);
        }
        function b(T, R, B, S) {
          let E = null;
          const P = B.isPointLight === true ? T.customDistanceMaterial : T.customDepthMaterial;
          if (P !== void 0) E = P;
          else if (E = B.isPointLight === true ? c : o, s.localClippingEnabled && R.clipShadows === true && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
            const G = E.uuid, H = R.uuid;
            let Y = l[G];
            Y === void 0 && (Y = {}, l[G] = Y);
            let et = Y[H];
            et === void 0 && (et = E.clone(), Y[H] = et, R.addEventListener("dispose", M)), E = et;
          }
          if (E.visible = R.visible, E.wireframe = R.wireframe, S === mn ? E.side = R.shadowSide !== null ? R.shadowSide : R.side : E.side = R.shadowSide !== null ? R.shadowSide : d[R.side], E.alphaMap = R.alphaMap, E.alphaTest = R.alphaTest, E.map = R.map, E.clipShadows = R.clipShadows, E.clippingPlanes = R.clippingPlanes, E.clipIntersection = R.clipIntersection, E.displacementMap = R.displacementMap, E.displacementScale = R.displacementScale, E.displacementBias = R.displacementBias, E.wireframeLinewidth = R.wireframeLinewidth, E.linewidth = R.linewidth, B.isPointLight === true && E.isMeshDistanceMaterial === true) {
            const G = s.properties.get(E);
            G.light = B;
          }
          return E;
        }
        function y(T, R, B, S, E) {
          if (T.visible === false) return;
          if (T.layers.test(R.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && E === mn) && (!T.frustumCulled || i.intersectsObject(T))) {
            T.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, T.matrixWorld);
            const H = t.update(T), Y = T.material;
            if (Array.isArray(Y)) {
              const et = H.groups;
              for (let q = 0, Z = et.length; q < Z; q++) {
                const W = et[q], st = Y[W.materialIndex];
                if (st && st.visible) {
                  const dt = b(T, st, S, E);
                  T.onBeforeShadow(s, T, R, B, H, dt, W), s.renderBufferDirect(B, null, H, dt, T, W), T.onAfterShadow(s, T, R, B, H, dt, W);
                }
              }
            } else if (Y.visible) {
              const et = b(T, Y, S, E);
              T.onBeforeShadow(s, T, R, B, H, et, null), s.renderBufferDirect(B, null, H, et, T, null), T.onAfterShadow(s, T, R, B, H, et, null);
            }
          }
          const G = T.children;
          for (let H = 0, Y = G.length; H < Y; H++) y(G[H], R, B, S, E);
        }
        function M(T) {
          T.target.removeEventListener("dispose", M);
          for (const B in l) {
            const S = l[B], E = T.target.uuid;
            E in S && (S[E].dispose(), delete S[E]);
          }
        }
      }
      const ev = {
        [Bl]: Dl,
        [Pl]: kl,
        [Fl]: Nl,
        [ss]: Ll,
        [Dl]: Bl,
        [kl]: Pl,
        [Nl]: Fl,
        [Ll]: ss
      };
      function iv(s, t) {
        function e() {
          let U = false;
          const At = new jt();
          let X = null;
          const tt = new jt(0, 0, 0, 0);
          return {
            setMask: function(_t) {
              X !== _t && !U && (s.colorMask(_t, _t, _t, _t), X = _t);
            },
            setLocked: function(_t) {
              U = _t;
            },
            setClear: function(_t, gt, Wt, Be, si) {
              si === true && (_t *= Be, gt *= Be, Wt *= Be), At.set(_t, gt, Wt, Be), tt.equals(At) === false && (s.clearColor(_t, gt, Wt, Be), tt.copy(At));
            },
            reset: function() {
              U = false, X = null, tt.set(-1, 0, 0, 0);
            }
          };
        }
        function i() {
          let U = false, At = false, X = null, tt = null, _t = null;
          return {
            setReversed: function(gt) {
              if (At !== gt) {
                const Wt = t.get("EXT_clip_control");
                gt ? Wt.clipControlEXT(Wt.LOWER_LEFT_EXT, Wt.ZERO_TO_ONE_EXT) : Wt.clipControlEXT(Wt.LOWER_LEFT_EXT, Wt.NEGATIVE_ONE_TO_ONE_EXT), At = gt;
                const Be = _t;
                _t = null, this.setClear(Be);
              }
            },
            getReversed: function() {
              return At;
            },
            setTest: function(gt) {
              gt ? lt(s.DEPTH_TEST) : Tt(s.DEPTH_TEST);
            },
            setMask: function(gt) {
              X !== gt && !U && (s.depthMask(gt), X = gt);
            },
            setFunc: function(gt) {
              if (At && (gt = ev[gt]), tt !== gt) {
                switch (gt) {
                  case Bl:
                    s.depthFunc(s.NEVER);
                    break;
                  case Dl:
                    s.depthFunc(s.ALWAYS);
                    break;
                  case Pl:
                    s.depthFunc(s.LESS);
                    break;
                  case ss:
                    s.depthFunc(s.LEQUAL);
                    break;
                  case Fl:
                    s.depthFunc(s.EQUAL);
                    break;
                  case Ll:
                    s.depthFunc(s.GEQUAL);
                    break;
                  case kl:
                    s.depthFunc(s.GREATER);
                    break;
                  case Nl:
                    s.depthFunc(s.NOTEQUAL);
                    break;
                  default:
                    s.depthFunc(s.LEQUAL);
                }
                tt = gt;
              }
            },
            setLocked: function(gt) {
              U = gt;
            },
            setClear: function(gt) {
              _t !== gt && (At && (gt = 1 - gt), s.clearDepth(gt), _t = gt);
            },
            reset: function() {
              U = false, X = null, tt = null, _t = null, At = false;
            }
          };
        }
        function n() {
          let U = false, At = null, X = null, tt = null, _t = null, gt = null, Wt = null, Be = null, si = null;
          return {
            setTest: function(pe) {
              U || (pe ? lt(s.STENCIL_TEST) : Tt(s.STENCIL_TEST));
            },
            setMask: function(pe) {
              At !== pe && !U && (s.stencilMask(pe), At = pe);
            },
            setFunc: function(pe, Oi, dn) {
              (X !== pe || tt !== Oi || _t !== dn) && (s.stencilFunc(pe, Oi, dn), X = pe, tt = Oi, _t = dn);
            },
            setOp: function(pe, Oi, dn) {
              (gt !== pe || Wt !== Oi || Be !== dn) && (s.stencilOp(pe, Oi, dn), gt = pe, Wt = Oi, Be = dn);
            },
            setLocked: function(pe) {
              U = pe;
            },
            setClear: function(pe) {
              si !== pe && (s.clearStencil(pe), si = pe);
            },
            reset: function() {
              U = false, At = null, X = null, tt = null, _t = null, gt = null, Wt = null, Be = null, si = null;
            }
          };
        }
        const r = new e(), a = new i(), o = new n(), c = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
        let h = {}, d = {}, u = /* @__PURE__ */ new WeakMap(), f = [], p = null, m = false, g = null, A = null, x = null, b = null, y = null, M = null, T = null, R = new ht(0, 0, 0), B = 0, S = false, E = null, P = null, G = null, H = null, Y = null;
        const et = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let q = false, Z = 0;
        const W = s.getParameter(s.VERSION);
        W.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(W)[1]), q = Z >= 1) : W.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(W)[1]), q = Z >= 2);
        let st = null, dt = {};
        const Et = s.getParameter(s.SCISSOR_BOX), Pt = s.getParameter(s.VIEWPORT), Vt = new jt().fromArray(Et), K = new jt().fromArray(Pt);
        function ot(U, At, X, tt) {
          const _t = new Uint8Array(4), gt = s.createTexture();
          s.bindTexture(U, gt), s.texParameteri(U, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(U, s.TEXTURE_MAG_FILTER, s.NEAREST);
          for (let Wt = 0; Wt < X; Wt++) U === s.TEXTURE_3D || U === s.TEXTURE_2D_ARRAY ? s.texImage3D(At, 0, s.RGBA, 1, 1, tt, 0, s.RGBA, s.UNSIGNED_BYTE, _t) : s.texImage2D(At + Wt, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, _t);
          return gt;
        }
        const bt = {};
        bt[s.TEXTURE_2D] = ot(s.TEXTURE_2D, s.TEXTURE_2D, 1), bt[s.TEXTURE_CUBE_MAP] = ot(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), bt[s.TEXTURE_2D_ARRAY] = ot(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), bt[s.TEXTURE_3D] = ot(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), lt(s.DEPTH_TEST), a.setFunc(ss), re(false), $t(Ud), lt(s.CULL_FACE), L(Hn);
        function lt(U) {
          h[U] !== true && (s.enable(U), h[U] = true);
        }
        function Tt(U) {
          h[U] !== false && (s.disable(U), h[U] = false);
        }
        function Zt(U, At) {
          return d[U] !== At ? (s.bindFramebuffer(U, At), d[U] = At, U === s.DRAW_FRAMEBUFFER && (d[s.FRAMEBUFFER] = At), U === s.FRAMEBUFFER && (d[s.DRAW_FRAMEBUFFER] = At), true) : false;
        }
        function Ft(U, At) {
          let X = f, tt = false;
          if (U) {
            X = u.get(At), X === void 0 && (X = [], u.set(At, X));
            const _t = U.textures;
            if (X.length !== _t.length || X[0] !== s.COLOR_ATTACHMENT0) {
              for (let gt = 0, Wt = _t.length; gt < Wt; gt++) X[gt] = s.COLOR_ATTACHMENT0 + gt;
              X.length = _t.length, tt = true;
            }
          } else X[0] !== s.BACK && (X[0] = s.BACK, tt = true);
          tt && s.drawBuffers(X);
        }
        function Se(U) {
          return p !== U ? (s.useProgram(U), p = U, true) : false;
        }
        const be = {
          [hr]: s.FUNC_ADD,
          [Mg]: s.FUNC_SUBTRACT,
          [Tg]: s.FUNC_REVERSE_SUBTRACT
        };
        be[Rg] = s.MIN, be[Bg] = s.MAX;
        const Kt = {
          [Dg]: s.ZERO,
          [Pg]: s.ONE,
          [Fg]: s.SRC_COLOR,
          [Tl]: s.SRC_ALPHA,
          [Og]: s.SRC_ALPHA_SATURATE,
          [Ug]: s.DST_COLOR,
          [kg]: s.DST_ALPHA,
          [Lg]: s.ONE_MINUS_SRC_COLOR,
          [Rl]: s.ONE_MINUS_SRC_ALPHA,
          [Qg]: s.ONE_MINUS_DST_COLOR,
          [Ng]: s.ONE_MINUS_DST_ALPHA,
          [zg]: s.CONSTANT_COLOR,
          [Gg]: s.ONE_MINUS_CONSTANT_COLOR,
          [Hg]: s.CONSTANT_ALPHA,
          [Vg]: s.ONE_MINUS_CONSTANT_ALPHA
        };
        function L(U, At, X, tt, _t, gt, Wt, Be, si, pe) {
          if (U === Hn) {
            m === true && (Tt(s.BLEND), m = false);
            return;
          }
          if (m === false && (lt(s.BLEND), m = true), U !== Ig) {
            if (U !== g || pe !== S) {
              if ((A !== hr || y !== hr) && (s.blendEquation(s.FUNC_ADD), A = hr, y = hr), pe) switch (U) {
                case es:
                  s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                  break;
                case Qd:
                  s.blendFunc(s.ONE, s.ONE);
                  break;
                case Od:
                  s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                  break;
                case zd:
                  s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", U);
                  break;
              }
              else switch (U) {
                case es:
                  s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                  break;
                case Qd:
                  s.blendFunc(s.SRC_ALPHA, s.ONE);
                  break;
                case Od:
                  s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                  break;
                case zd:
                  s.blendFunc(s.ZERO, s.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", U);
                  break;
              }
              x = null, b = null, M = null, T = null, R.set(0, 0, 0), B = 0, g = U, S = pe;
            }
            return;
          }
          _t = _t || At, gt = gt || X, Wt = Wt || tt, (At !== A || _t !== y) && (s.blendEquationSeparate(be[At], be[_t]), A = At, y = _t), (X !== x || tt !== b || gt !== M || Wt !== T) && (s.blendFuncSeparate(Kt[X], Kt[tt], Kt[gt], Kt[Wt]), x = X, b = tt, M = gt, T = Wt), (Be.equals(R) === false || si !== B) && (s.blendColor(Be.r, Be.g, Be.b, si), R.copy(Be), B = si), g = U, S = false;
        }
        function Mi(U, At) {
          U.side === Ki ? Tt(s.CULL_FACE) : lt(s.CULL_FACE);
          let X = U.side === yi;
          At && (X = !X), re(X), U.blending === es && U.transparent === false ? L(Hn) : L(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.blendColor, U.blendAlpha, U.premultipliedAlpha), a.setFunc(U.depthFunc), a.setTest(U.depthTest), a.setMask(U.depthWrite), r.setMask(U.colorWrite);
          const tt = U.stencilWrite;
          o.setTest(tt), tt && (o.setMask(U.stencilWriteMask), o.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), o.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), xe(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === true ? lt(s.SAMPLE_ALPHA_TO_COVERAGE) : Tt(s.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function re(U) {
          E !== U && (U ? s.frontFace(s.CW) : s.frontFace(s.CCW), E = U);
        }
        function $t(U) {
          U !== Sg ? (lt(s.CULL_FACE), U !== P && (U === Ud ? s.cullFace(s.BACK) : U === Cg ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Tt(s.CULL_FACE), P = U;
        }
        function It(U) {
          U !== G && (q && s.lineWidth(U), G = U);
        }
        function xe(U, At, X) {
          U ? (lt(s.POLYGON_OFFSET_FILL), (H !== At || Y !== X) && (s.polygonOffset(At, X), H = At, Y = X)) : Tt(s.POLYGON_OFFSET_FILL);
        }
        function Ct(U) {
          U ? lt(s.SCISSOR_TEST) : Tt(s.SCISSOR_TEST);
        }
        function D(U) {
          U === void 0 && (U = s.TEXTURE0 + et - 1), st !== U && (s.activeTexture(U), st = U);
        }
        function v(U, At, X) {
          X === void 0 && (st === null ? X = s.TEXTURE0 + et - 1 : X = st);
          let tt = dt[X];
          tt === void 0 && (tt = {
            type: void 0,
            texture: void 0
          }, dt[X] = tt), (tt.type !== U || tt.texture !== At) && (st !== X && (s.activeTexture(X), st = X), s.bindTexture(U, At || bt[U]), tt.type = U, tt.texture = At);
        }
        function z() {
          const U = dt[st];
          U !== void 0 && U.type !== void 0 && (s.bindTexture(U.type, null), U.type = void 0, U.texture = void 0);
        }
        function $() {
          try {
            s.compressedTexImage2D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function it() {
          try {
            s.compressedTexImage3D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function J() {
          try {
            s.texSubImage2D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function St() {
          try {
            s.texSubImage3D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function pt() {
          try {
            s.compressedTexSubImage2D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function wt() {
          try {
            s.compressedTexSubImage3D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function se() {
          try {
            s.texStorage2D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function at() {
          try {
            s.texStorage3D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function yt() {
          try {
            s.texImage2D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function Lt() {
          try {
            s.texImage3D(...arguments);
          } catch (U) {
            console.error("THREE.WebGLState:", U);
          }
        }
        function Nt(U) {
          Vt.equals(U) === false && (s.scissor(U.x, U.y, U.z, U.w), Vt.copy(U));
        }
        function xt(U) {
          K.equals(U) === false && (s.viewport(U.x, U.y, U.z, U.w), K.copy(U));
        }
        function te(U, At) {
          let X = l.get(At);
          X === void 0 && (X = /* @__PURE__ */ new WeakMap(), l.set(At, X));
          let tt = X.get(U);
          tt === void 0 && (tt = s.getUniformBlockIndex(At, U.name), X.set(U, tt));
        }
        function qt(U, At) {
          const tt = l.get(At).get(U);
          c.get(At) !== tt && (s.uniformBlockBinding(At, tt, U.__bindingPointIndex), c.set(At, tt));
        }
        function ye() {
          s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(true, true, true, true), s.clearColor(0, 0, 0, 0), s.depthMask(true), s.depthFunc(s.LESS), a.setReversed(false), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), h = {}, st = null, dt = {}, d = {}, u = /* @__PURE__ */ new WeakMap(), f = [], p = null, m = false, g = null, A = null, x = null, b = null, y = null, M = null, T = null, R = new ht(0, 0, 0), B = 0, S = false, E = null, P = null, G = null, H = null, Y = null, Vt.set(0, 0, s.canvas.width, s.canvas.height), K.set(0, 0, s.canvas.width, s.canvas.height), r.reset(), a.reset(), o.reset();
        }
        return {
          buffers: {
            color: r,
            depth: a,
            stencil: o
          },
          enable: lt,
          disable: Tt,
          bindFramebuffer: Zt,
          drawBuffers: Ft,
          useProgram: Se,
          setBlending: L,
          setMaterial: Mi,
          setFlipSided: re,
          setCullFace: $t,
          setLineWidth: It,
          setPolygonOffset: xe,
          setScissorTest: Ct,
          activeTexture: D,
          bindTexture: v,
          unbindTexture: z,
          compressedTexImage2D: $,
          compressedTexImage3D: it,
          texImage2D: yt,
          texImage3D: Lt,
          updateUBOMapping: te,
          uniformBlockBinding: qt,
          texStorage2D: se,
          texStorage3D: at,
          texSubImage2D: J,
          texSubImage3D: St,
          compressedTexSubImage2D: pt,
          compressedTexSubImage3D: wt,
          scissor: Nt,
          viewport: xt,
          reset: ye
        };
      }
      function nv(s, t, e, i, n, r, a) {
        const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), l = new rt(), h = /* @__PURE__ */ new WeakMap();
        let d;
        const u = /* @__PURE__ */ new WeakMap();
        let f = false;
        try {
          f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {
        }
        function p(D, v) {
          return f ? new OffscreenCanvas(D, v) : ta("canvas");
        }
        function m(D, v, z) {
          let $ = 1;
          const it = Ct(D);
          if ((it.width > z || it.height > z) && ($ = z / Math.max(it.width, it.height)), $ < 1) if (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && D instanceof ImageBitmap || typeof VideoFrame < "u" && D instanceof VideoFrame) {
            const J = Math.floor($ * it.width), St = Math.floor($ * it.height);
            d === void 0 && (d = p(J, St));
            const pt = v ? p(J, St) : d;
            return pt.width = J, pt.height = St, pt.getContext("2d").drawImage(D, 0, 0, J, St), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + it.width + "x" + it.height + ") to (" + J + "x" + St + ")."), pt;
          } else return "data" in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + it.width + "x" + it.height + ")."), D;
          return D;
        }
        function g(D) {
          return D.generateMipmaps;
        }
        function A(D) {
          s.generateMipmap(D);
        }
        function x(D) {
          return D.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : D.isWebGL3DRenderTarget ? s.TEXTURE_3D : D.isWebGLArrayRenderTarget || D.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
        }
        function b(D, v, z, $, it = false) {
          if (D !== null) {
            if (s[D] !== void 0) return s[D];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'");
          }
          let J = v;
          if (v === s.RED && (z === s.FLOAT && (J = s.R32F), z === s.HALF_FLOAT && (J = s.R16F), z === s.UNSIGNED_BYTE && (J = s.R8)), v === s.RED_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.R8UI), z === s.UNSIGNED_SHORT && (J = s.R16UI), z === s.UNSIGNED_INT && (J = s.R32UI), z === s.BYTE && (J = s.R8I), z === s.SHORT && (J = s.R16I), z === s.INT && (J = s.R32I)), v === s.RG && (z === s.FLOAT && (J = s.RG32F), z === s.HALF_FLOAT && (J = s.RG16F), z === s.UNSIGNED_BYTE && (J = s.RG8)), v === s.RG_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RG8UI), z === s.UNSIGNED_SHORT && (J = s.RG16UI), z === s.UNSIGNED_INT && (J = s.RG32UI), z === s.BYTE && (J = s.RG8I), z === s.SHORT && (J = s.RG16I), z === s.INT && (J = s.RG32I)), v === s.RGB_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RGB8UI), z === s.UNSIGNED_SHORT && (J = s.RGB16UI), z === s.UNSIGNED_INT && (J = s.RGB32UI), z === s.BYTE && (J = s.RGB8I), z === s.SHORT && (J = s.RGB16I), z === s.INT && (J = s.RGB32I)), v === s.RGBA_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RGBA8UI), z === s.UNSIGNED_SHORT && (J = s.RGBA16UI), z === s.UNSIGNED_INT && (J = s.RGBA32UI), z === s.BYTE && (J = s.RGBA8I), z === s.SHORT && (J = s.RGBA16I), z === s.INT && (J = s.RGBA32I)), v === s.RGB && z === s.UNSIGNED_INT_5_9_9_9_REV && (J = s.RGB9_E5), v === s.RGBA) {
            const St = it ? Fo : zt.getTransfer($);
            z === s.FLOAT && (J = s.RGBA32F), z === s.HALF_FLOAT && (J = s.RGBA16F), z === s.UNSIGNED_BYTE && (J = St === ge ? s.SRGB8_ALPHA8 : s.RGBA8), z === s.UNSIGNED_SHORT_4_4_4_4 && (J = s.RGBA4), z === s.UNSIGNED_SHORT_5_5_5_1 && (J = s.RGB5_A1);
          }
          return (J === s.R16F || J === s.R32F || J === s.RG16F || J === s.RG32F || J === s.RGBA16F || J === s.RGBA32F) && t.get("EXT_color_buffer_float"), J;
        }
        function y(D, v) {
          let z;
          return D ? v === null || v === _r || v === qs ? z = s.DEPTH24_STENCIL8 : v === ii ? z = s.DEPTH32F_STENCIL8 : v === js && (z = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : v === null || v === _r || v === qs ? z = s.DEPTH_COMPONENT24 : v === ii ? z = s.DEPTH_COMPONENT32F : v === js && (z = s.DEPTH_COMPONENT16), z;
        }
        function M(D, v) {
          return g(D) === true || D.isFramebufferTexture && D.minFilter !== mi && D.minFilter !== Re ? Math.log2(Math.max(v.width, v.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? v.mipmaps.length : 1;
        }
        function T(D) {
          const v = D.target;
          v.removeEventListener("dispose", T), B(v), v.isVideoTexture && h.delete(v);
        }
        function R(D) {
          const v = D.target;
          v.removeEventListener("dispose", R), E(v);
        }
        function B(D) {
          const v = i.get(D);
          if (v.__webglInit === void 0) return;
          const z = D.source, $ = u.get(z);
          if ($) {
            const it = $[v.__cacheKey];
            it.usedTimes--, it.usedTimes === 0 && S(D), Object.keys($).length === 0 && u.delete(z);
          }
          i.remove(D);
        }
        function S(D) {
          const v = i.get(D);
          s.deleteTexture(v.__webglTexture);
          const z = D.source, $ = u.get(z);
          delete $[v.__cacheKey], a.memory.textures--;
        }
        function E(D) {
          const v = i.get(D);
          if (D.depthTexture && (D.depthTexture.dispose(), i.remove(D.depthTexture)), D.isWebGLCubeRenderTarget) for (let $ = 0; $ < 6; $++) {
            if (Array.isArray(v.__webglFramebuffer[$])) for (let it = 0; it < v.__webglFramebuffer[$].length; it++) s.deleteFramebuffer(v.__webglFramebuffer[$][it]);
            else s.deleteFramebuffer(v.__webglFramebuffer[$]);
            v.__webglDepthbuffer && s.deleteRenderbuffer(v.__webglDepthbuffer[$]);
          }
          else {
            if (Array.isArray(v.__webglFramebuffer)) for (let $ = 0; $ < v.__webglFramebuffer.length; $++) s.deleteFramebuffer(v.__webglFramebuffer[$]);
            else s.deleteFramebuffer(v.__webglFramebuffer);
            if (v.__webglDepthbuffer && s.deleteRenderbuffer(v.__webglDepthbuffer), v.__webglMultisampledFramebuffer && s.deleteFramebuffer(v.__webglMultisampledFramebuffer), v.__webglColorRenderbuffer) for (let $ = 0; $ < v.__webglColorRenderbuffer.length; $++) v.__webglColorRenderbuffer[$] && s.deleteRenderbuffer(v.__webglColorRenderbuffer[$]);
            v.__webglDepthRenderbuffer && s.deleteRenderbuffer(v.__webglDepthRenderbuffer);
          }
          const z = D.textures;
          for (let $ = 0, it = z.length; $ < it; $++) {
            const J = i.get(z[$]);
            J.__webglTexture && (s.deleteTexture(J.__webglTexture), a.memory.textures--), i.remove(z[$]);
          }
          i.remove(D);
        }
        let P = 0;
        function G() {
          P = 0;
        }
        function H() {
          const D = P;
          return D >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + n.maxTextures), P += 1, D;
        }
        function Y(D) {
          const v = [];
          return v.push(D.wrapS), v.push(D.wrapT), v.push(D.wrapR || 0), v.push(D.magFilter), v.push(D.minFilter), v.push(D.anisotropy), v.push(D.internalFormat), v.push(D.format), v.push(D.type), v.push(D.generateMipmaps), v.push(D.premultiplyAlpha), v.push(D.flipY), v.push(D.unpackAlignment), v.push(D.colorSpace), v.join();
        }
        function et(D, v) {
          const z = i.get(D);
          if (D.isVideoTexture && It(D), D.isRenderTargetTexture === false && D.version > 0 && z.__version !== D.version) {
            const $ = D.image;
            if ($ === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if ($.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              K(z, D, v);
              return;
            }
          }
          e.bindTexture(s.TEXTURE_2D, z.__webglTexture, s.TEXTURE0 + v);
        }
        function q(D, v) {
          const z = i.get(D);
          if (D.version > 0 && z.__version !== D.version) {
            K(z, D, v);
            return;
          }
          e.bindTexture(s.TEXTURE_2D_ARRAY, z.__webglTexture, s.TEXTURE0 + v);
        }
        function Z(D, v) {
          const z = i.get(D);
          if (D.version > 0 && z.__version !== D.version) {
            K(z, D, v);
            return;
          }
          e.bindTexture(s.TEXTURE_3D, z.__webglTexture, s.TEXTURE0 + v);
        }
        function W(D, v) {
          const z = i.get(D);
          if (D.version > 0 && z.__version !== D.version) {
            ot(z, D, v);
            return;
          }
          e.bindTexture(s.TEXTURE_CUBE_MAP, z.__webglTexture, s.TEXTURE0 + v);
        }
        const st = {
          [ni]: s.REPEAT,
          [_i]: s.CLAMP_TO_EDGE,
          [Co]: s.MIRRORED_REPEAT
        }, dt = {
          [mi]: s.NEAREST,
          [sp]: s.NEAREST_MIPMAP_NEAREST,
          [Ps]: s.NEAREST_MIPMAP_LINEAR,
          [Re]: s.LINEAR,
          [mo]: s.LINEAR_MIPMAP_NEAREST,
          [Zi]: s.LINEAR_MIPMAP_LINEAR
        }, Et = {
          [c_]: s.NEVER,
          [p_]: s.ALWAYS,
          [l_]: s.LESS,
          [Ap]: s.LEQUAL,
          [h_]: s.EQUAL,
          [f_]: s.GEQUAL,
          [d_]: s.GREATER,
          [u_]: s.NOTEQUAL
        };
        function Pt(D, v) {
          if (v.type === ii && t.has("OES_texture_float_linear") === false && (v.magFilter === Re || v.magFilter === mo || v.magFilter === Ps || v.magFilter === Zi || v.minFilter === Re || v.minFilter === mo || v.minFilter === Ps || v.minFilter === Zi) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(D, s.TEXTURE_WRAP_S, st[v.wrapS]), s.texParameteri(D, s.TEXTURE_WRAP_T, st[v.wrapT]), (D === s.TEXTURE_3D || D === s.TEXTURE_2D_ARRAY) && s.texParameteri(D, s.TEXTURE_WRAP_R, st[v.wrapR]), s.texParameteri(D, s.TEXTURE_MAG_FILTER, dt[v.magFilter]), s.texParameteri(D, s.TEXTURE_MIN_FILTER, dt[v.minFilter]), v.compareFunction && (s.texParameteri(D, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(D, s.TEXTURE_COMPARE_FUNC, Et[v.compareFunction])), t.has("EXT_texture_filter_anisotropic") === true) {
            if (v.magFilter === mi || v.minFilter !== Ps && v.minFilter !== Zi || v.type === ii && t.has("OES_texture_float_linear") === false) return;
            if (v.anisotropy > 1 || i.get(v).__currentAnisotropy) {
              const z = t.get("EXT_texture_filter_anisotropic");
              s.texParameterf(D, z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(v.anisotropy, n.getMaxAnisotropy())), i.get(v).__currentAnisotropy = v.anisotropy;
            }
          }
        }
        function Vt(D, v) {
          let z = false;
          D.__webglInit === void 0 && (D.__webglInit = true, v.addEventListener("dispose", T));
          const $ = v.source;
          let it = u.get($);
          it === void 0 && (it = {}, u.set($, it));
          const J = Y(v);
          if (J !== D.__cacheKey) {
            it[J] === void 0 && (it[J] = {
              texture: s.createTexture(),
              usedTimes: 0
            }, a.memory.textures++, z = true), it[J].usedTimes++;
            const St = it[D.__cacheKey];
            St !== void 0 && (it[D.__cacheKey].usedTimes--, St.usedTimes === 0 && S(v)), D.__cacheKey = J, D.__webglTexture = it[J].texture;
          }
          return z;
        }
        function K(D, v, z) {
          let $ = s.TEXTURE_2D;
          (v.isDataArrayTexture || v.isCompressedArrayTexture) && ($ = s.TEXTURE_2D_ARRAY), v.isData3DTexture && ($ = s.TEXTURE_3D);
          const it = Vt(D, v), J = v.source;
          e.bindTexture($, D.__webglTexture, s.TEXTURE0 + z);
          const St = i.get(J);
          if (J.version !== St.__version || it === true) {
            e.activeTexture(s.TEXTURE0 + z);
            const pt = zt.getPrimaries(zt.workingColorSpace), wt = v.colorSpace === an ? null : zt.getPrimaries(v.colorSpace), se = v.colorSpace === an || pt === wt ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, v.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, v.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, se);
            let at = m(v.image, false, n.maxTextureSize);
            at = xe(v, at);
            const yt = r.convert(v.format, v.colorSpace), Lt = r.convert(v.type);
            let Nt = b(v.internalFormat, yt, Lt, v.colorSpace, v.isVideoTexture);
            Pt($, v);
            let xt;
            const te = v.mipmaps, qt = v.isVideoTexture !== true, ye = St.__version === void 0 || it === true, U = J.dataReady, At = M(v, at);
            if (v.isDepthTexture) Nt = y(v.format === Ys, v.type), ye && (qt ? e.texStorage2D(s.TEXTURE_2D, 1, Nt, at.width, at.height) : e.texImage2D(s.TEXTURE_2D, 0, Nt, at.width, at.height, 0, yt, Lt, null));
            else if (v.isDataTexture) if (te.length > 0) {
              qt && ye && e.texStorage2D(s.TEXTURE_2D, At, Nt, te[0].width, te[0].height);
              for (let X = 0, tt = te.length; X < tt; X++) xt = te[X], qt ? U && e.texSubImage2D(s.TEXTURE_2D, X, 0, 0, xt.width, xt.height, yt, Lt, xt.data) : e.texImage2D(s.TEXTURE_2D, X, Nt, xt.width, xt.height, 0, yt, Lt, xt.data);
              v.generateMipmaps = false;
            } else qt ? (ye && e.texStorage2D(s.TEXTURE_2D, At, Nt, at.width, at.height), U && e.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, at.width, at.height, yt, Lt, at.data)) : e.texImage2D(s.TEXTURE_2D, 0, Nt, at.width, at.height, 0, yt, Lt, at.data);
            else if (v.isCompressedTexture) if (v.isCompressedArrayTexture) {
              qt && ye && e.texStorage3D(s.TEXTURE_2D_ARRAY, At, Nt, te[0].width, te[0].height, at.depth);
              for (let X = 0, tt = te.length; X < tt; X++) if (xt = te[X], v.format !== We) if (yt !== null) if (qt) {
                if (U) if (v.layerUpdates.size > 0) {
                  const _t = zu(xt.width, xt.height, v.format, v.type);
                  for (const gt of v.layerUpdates) {
                    const Wt = xt.data.subarray(gt * _t / xt.data.BYTES_PER_ELEMENT, (gt + 1) * _t / xt.data.BYTES_PER_ELEMENT);
                    e.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, gt, xt.width, xt.height, 1, yt, Wt);
                  }
                  v.clearLayerUpdates();
                } else e.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, 0, xt.width, xt.height, at.depth, yt, xt.data);
              } else e.compressedTexImage3D(s.TEXTURE_2D_ARRAY, X, Nt, xt.width, xt.height, at.depth, 0, xt.data, 0, 0);
              else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              else qt ? U && e.texSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, 0, xt.width, xt.height, at.depth, yt, Lt, xt.data) : e.texImage3D(s.TEXTURE_2D_ARRAY, X, Nt, xt.width, xt.height, at.depth, 0, yt, Lt, xt.data);
            } else {
              qt && ye && e.texStorage2D(s.TEXTURE_2D, At, Nt, te[0].width, te[0].height);
              for (let X = 0, tt = te.length; X < tt; X++) xt = te[X], v.format !== We ? yt !== null ? qt ? U && e.compressedTexSubImage2D(s.TEXTURE_2D, X, 0, 0, xt.width, xt.height, yt, xt.data) : e.compressedTexImage2D(s.TEXTURE_2D, X, Nt, xt.width, xt.height, 0, xt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qt ? U && e.texSubImage2D(s.TEXTURE_2D, X, 0, 0, xt.width, xt.height, yt, Lt, xt.data) : e.texImage2D(s.TEXTURE_2D, X, Nt, xt.width, xt.height, 0, yt, Lt, xt.data);
            }
            else if (v.isDataArrayTexture) if (qt) {
              if (ye && e.texStorage3D(s.TEXTURE_2D_ARRAY, At, Nt, at.width, at.height, at.depth), U) if (v.layerUpdates.size > 0) {
                const X = zu(at.width, at.height, v.format, v.type);
                for (const tt of v.layerUpdates) {
                  const _t = at.data.subarray(tt * X / at.data.BYTES_PER_ELEMENT, (tt + 1) * X / at.data.BYTES_PER_ELEMENT);
                  e.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, tt, at.width, at.height, 1, yt, Lt, _t);
                }
                v.clearLayerUpdates();
              } else e.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, at.width, at.height, at.depth, yt, Lt, at.data);
            } else e.texImage3D(s.TEXTURE_2D_ARRAY, 0, Nt, at.width, at.height, at.depth, 0, yt, Lt, at.data);
            else if (v.isData3DTexture) qt ? (ye && e.texStorage3D(s.TEXTURE_3D, At, Nt, at.width, at.height, at.depth), U && e.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, at.width, at.height, at.depth, yt, Lt, at.data)) : e.texImage3D(s.TEXTURE_3D, 0, Nt, at.width, at.height, at.depth, 0, yt, Lt, at.data);
            else if (v.isFramebufferTexture) {
              if (ye) if (qt) e.texStorage2D(s.TEXTURE_2D, At, Nt, at.width, at.height);
              else {
                let X = at.width, tt = at.height;
                for (let _t = 0; _t < At; _t++) e.texImage2D(s.TEXTURE_2D, _t, Nt, X, tt, 0, yt, Lt, null), X >>= 1, tt >>= 1;
              }
            } else if (te.length > 0) {
              if (qt && ye) {
                const X = Ct(te[0]);
                e.texStorage2D(s.TEXTURE_2D, At, Nt, X.width, X.height);
              }
              for (let X = 0, tt = te.length; X < tt; X++) xt = te[X], qt ? U && e.texSubImage2D(s.TEXTURE_2D, X, 0, 0, yt, Lt, xt) : e.texImage2D(s.TEXTURE_2D, X, Nt, yt, Lt, xt);
              v.generateMipmaps = false;
            } else if (qt) {
              if (ye) {
                const X = Ct(at);
                e.texStorage2D(s.TEXTURE_2D, At, Nt, X.width, X.height);
              }
              U && e.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, yt, Lt, at);
            } else e.texImage2D(s.TEXTURE_2D, 0, Nt, yt, Lt, at);
            g(v) && A($), St.__version = J.version, v.onUpdate && v.onUpdate(v);
          }
          D.__version = v.version;
        }
        function ot(D, v, z) {
          if (v.image.length !== 6) return;
          const $ = Vt(D, v), it = v.source;
          e.bindTexture(s.TEXTURE_CUBE_MAP, D.__webglTexture, s.TEXTURE0 + z);
          const J = i.get(it);
          if (it.version !== J.__version || $ === true) {
            e.activeTexture(s.TEXTURE0 + z);
            const St = zt.getPrimaries(zt.workingColorSpace), pt = v.colorSpace === an ? null : zt.getPrimaries(v.colorSpace), wt = v.colorSpace === an || St === pt ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, v.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, v.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, wt);
            const se = v.isCompressedTexture || v.image[0].isCompressedTexture, at = v.image[0] && v.image[0].isDataTexture, yt = [];
            for (let tt = 0; tt < 6; tt++) !se && !at ? yt[tt] = m(v.image[tt], true, n.maxCubemapSize) : yt[tt] = at ? v.image[tt].image : v.image[tt], yt[tt] = xe(v, yt[tt]);
            const Lt = yt[0], Nt = r.convert(v.format, v.colorSpace), xt = r.convert(v.type), te = b(v.internalFormat, Nt, xt, v.colorSpace), qt = v.isVideoTexture !== true, ye = J.__version === void 0 || $ === true, U = it.dataReady;
            let At = M(v, Lt);
            Pt(s.TEXTURE_CUBE_MAP, v);
            let X;
            if (se) {
              qt && ye && e.texStorage2D(s.TEXTURE_CUBE_MAP, At, te, Lt.width, Lt.height);
              for (let tt = 0; tt < 6; tt++) {
                X = yt[tt].mipmaps;
                for (let _t = 0; _t < X.length; _t++) {
                  const gt = X[_t];
                  v.format !== We ? Nt !== null ? qt ? U && e.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, 0, 0, gt.width, gt.height, Nt, gt.data) : e.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, te, gt.width, gt.height, 0, gt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : qt ? U && e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, 0, 0, gt.width, gt.height, Nt, xt, gt.data) : e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t, te, gt.width, gt.height, 0, Nt, xt, gt.data);
                }
              }
            } else {
              if (X = v.mipmaps, qt && ye) {
                X.length > 0 && At++;
                const tt = Ct(yt[0]);
                e.texStorage2D(s.TEXTURE_CUBE_MAP, At, te, tt.width, tt.height);
              }
              for (let tt = 0; tt < 6; tt++) if (at) {
                qt ? U && e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, yt[tt].width, yt[tt].height, Nt, xt, yt[tt].data) : e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, te, yt[tt].width, yt[tt].height, 0, Nt, xt, yt[tt].data);
                for (let _t = 0; _t < X.length; _t++) {
                  const Wt = X[_t].image[tt].image;
                  qt ? U && e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, 0, 0, Wt.width, Wt.height, Nt, xt, Wt.data) : e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, te, Wt.width, Wt.height, 0, Nt, xt, Wt.data);
                }
              } else {
                qt ? U && e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, Nt, xt, yt[tt]) : e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, te, Nt, xt, yt[tt]);
                for (let _t = 0; _t < X.length; _t++) {
                  const gt = X[_t];
                  qt ? U && e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, 0, 0, Nt, xt, gt.image[tt]) : e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + tt, _t + 1, te, Nt, xt, gt.image[tt]);
                }
              }
            }
            g(v) && A(s.TEXTURE_CUBE_MAP), J.__version = it.version, v.onUpdate && v.onUpdate(v);
          }
          D.__version = v.version;
        }
        function bt(D, v, z, $, it, J) {
          const St = r.convert(z.format, z.colorSpace), pt = r.convert(z.type), wt = b(z.internalFormat, St, pt, z.colorSpace), se = i.get(v), at = i.get(z);
          if (at.__renderTarget = v, !se.__hasExternalTextures) {
            const yt = Math.max(1, v.width >> J), Lt = Math.max(1, v.height >> J);
            it === s.TEXTURE_3D || it === s.TEXTURE_2D_ARRAY ? e.texImage3D(it, J, wt, yt, Lt, v.depth, 0, St, pt, null) : e.texImage2D(it, J, wt, yt, Lt, 0, St, pt, null);
          }
          e.bindFramebuffer(s.FRAMEBUFFER, D), $t(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, $, it, at.__webglTexture, 0, re(v)) : (it === s.TEXTURE_2D || it >= s.TEXTURE_CUBE_MAP_POSITIVE_X && it <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, $, it, at.__webglTexture, J), e.bindFramebuffer(s.FRAMEBUFFER, null);
        }
        function lt(D, v, z) {
          if (s.bindRenderbuffer(s.RENDERBUFFER, D), v.depthBuffer) {
            const $ = v.depthTexture, it = $ && $.isDepthTexture ? $.type : null, J = y(v.stencilBuffer, it), St = v.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, pt = re(v);
            $t(v) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, pt, J, v.width, v.height) : z ? s.renderbufferStorageMultisample(s.RENDERBUFFER, pt, J, v.width, v.height) : s.renderbufferStorage(s.RENDERBUFFER, J, v.width, v.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, St, s.RENDERBUFFER, D);
          } else {
            const $ = v.textures;
            for (let it = 0; it < $.length; it++) {
              const J = $[it], St = r.convert(J.format, J.colorSpace), pt = r.convert(J.type), wt = b(J.internalFormat, St, pt, J.colorSpace), se = re(v);
              z && $t(v) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, se, wt, v.width, v.height) : $t(v) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, se, wt, v.width, v.height) : s.renderbufferStorage(s.RENDERBUFFER, wt, v.width, v.height);
            }
          }
          s.bindRenderbuffer(s.RENDERBUFFER, null);
        }
        function Tt(D, v) {
          if (v && v.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (e.bindFramebuffer(s.FRAMEBUFFER, D), !(v.depthTexture && v.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const $ = i.get(v.depthTexture);
          $.__renderTarget = v, (!$.__webglTexture || v.depthTexture.image.width !== v.width || v.depthTexture.image.height !== v.height) && (v.depthTexture.image.width = v.width, v.depthTexture.image.height = v.height, v.depthTexture.needsUpdate = true), et(v.depthTexture, 0);
          const it = $.__webglTexture, J = re(v);
          if (v.depthTexture.format === Xs) $t(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, it, 0, J) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, it, 0);
          else if (v.depthTexture.format === Ys) $t(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, it, 0, J) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, it, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Zt(D) {
          const v = i.get(D), z = D.isWebGLCubeRenderTarget === true;
          if (v.__boundDepthTexture !== D.depthTexture) {
            const $ = D.depthTexture;
            if (v.__depthDisposeCallback && v.__depthDisposeCallback(), $) {
              const it = () => {
                delete v.__boundDepthTexture, delete v.__depthDisposeCallback, $.removeEventListener("dispose", it);
              };
              $.addEventListener("dispose", it), v.__depthDisposeCallback = it;
            }
            v.__boundDepthTexture = $;
          }
          if (D.depthTexture && !v.__autoAllocateDepthBuffer) {
            if (z) throw new Error("target.depthTexture not supported in Cube render targets");
            Tt(v.__webglFramebuffer, D);
          } else if (z) {
            v.__webglDepthbuffer = [];
            for (let $ = 0; $ < 6; $++) if (e.bindFramebuffer(s.FRAMEBUFFER, v.__webglFramebuffer[$]), v.__webglDepthbuffer[$] === void 0) v.__webglDepthbuffer[$] = s.createRenderbuffer(), lt(v.__webglDepthbuffer[$], D, false);
            else {
              const it = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, J = v.__webglDepthbuffer[$];
              s.bindRenderbuffer(s.RENDERBUFFER, J), s.framebufferRenderbuffer(s.FRAMEBUFFER, it, s.RENDERBUFFER, J);
            }
          } else if (e.bindFramebuffer(s.FRAMEBUFFER, v.__webglFramebuffer), v.__webglDepthbuffer === void 0) v.__webglDepthbuffer = s.createRenderbuffer(), lt(v.__webglDepthbuffer, D, false);
          else {
            const $ = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, it = v.__webglDepthbuffer;
            s.bindRenderbuffer(s.RENDERBUFFER, it), s.framebufferRenderbuffer(s.FRAMEBUFFER, $, s.RENDERBUFFER, it);
          }
          e.bindFramebuffer(s.FRAMEBUFFER, null);
        }
        function Ft(D, v, z) {
          const $ = i.get(D);
          v !== void 0 && bt($.__webglFramebuffer, D, D.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), z !== void 0 && Zt(D);
        }
        function Se(D) {
          const v = D.texture, z = i.get(D), $ = i.get(v);
          D.addEventListener("dispose", R);
          const it = D.textures, J = D.isWebGLCubeRenderTarget === true, St = it.length > 1;
          if (St || ($.__webglTexture === void 0 && ($.__webglTexture = s.createTexture()), $.__version = v.version, a.memory.textures++), J) {
            z.__webglFramebuffer = [];
            for (let pt = 0; pt < 6; pt++) if (v.mipmaps && v.mipmaps.length > 0) {
              z.__webglFramebuffer[pt] = [];
              for (let wt = 0; wt < v.mipmaps.length; wt++) z.__webglFramebuffer[pt][wt] = s.createFramebuffer();
            } else z.__webglFramebuffer[pt] = s.createFramebuffer();
          } else {
            if (v.mipmaps && v.mipmaps.length > 0) {
              z.__webglFramebuffer = [];
              for (let pt = 0; pt < v.mipmaps.length; pt++) z.__webglFramebuffer[pt] = s.createFramebuffer();
            } else z.__webglFramebuffer = s.createFramebuffer();
            if (St) for (let pt = 0, wt = it.length; pt < wt; pt++) {
              const se = i.get(it[pt]);
              se.__webglTexture === void 0 && (se.__webglTexture = s.createTexture(), a.memory.textures++);
            }
            if (D.samples > 0 && $t(D) === false) {
              z.__webglMultisampledFramebuffer = s.createFramebuffer(), z.__webglColorRenderbuffer = [], e.bindFramebuffer(s.FRAMEBUFFER, z.__webglMultisampledFramebuffer);
              for (let pt = 0; pt < it.length; pt++) {
                const wt = it[pt];
                z.__webglColorRenderbuffer[pt] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, z.__webglColorRenderbuffer[pt]);
                const se = r.convert(wt.format, wt.colorSpace), at = r.convert(wt.type), yt = b(wt.internalFormat, se, at, wt.colorSpace, D.isXRRenderTarget === true), Lt = re(D);
                s.renderbufferStorageMultisample(s.RENDERBUFFER, Lt, yt, D.width, D.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + pt, s.RENDERBUFFER, z.__webglColorRenderbuffer[pt]);
              }
              s.bindRenderbuffer(s.RENDERBUFFER, null), D.depthBuffer && (z.__webglDepthRenderbuffer = s.createRenderbuffer(), lt(z.__webglDepthRenderbuffer, D, true)), e.bindFramebuffer(s.FRAMEBUFFER, null);
            }
          }
          if (J) {
            e.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture), Pt(s.TEXTURE_CUBE_MAP, v);
            for (let pt = 0; pt < 6; pt++) if (v.mipmaps && v.mipmaps.length > 0) for (let wt = 0; wt < v.mipmaps.length; wt++) bt(z.__webglFramebuffer[pt][wt], D, v, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + pt, wt);
            else bt(z.__webglFramebuffer[pt], D, v, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + pt, 0);
            g(v) && A(s.TEXTURE_CUBE_MAP), e.unbindTexture();
          } else if (St) {
            for (let pt = 0, wt = it.length; pt < wt; pt++) {
              const se = it[pt], at = i.get(se);
              e.bindTexture(s.TEXTURE_2D, at.__webglTexture), Pt(s.TEXTURE_2D, se), bt(z.__webglFramebuffer, D, se, s.COLOR_ATTACHMENT0 + pt, s.TEXTURE_2D, 0), g(se) && A(s.TEXTURE_2D);
            }
            e.unbindTexture();
          } else {
            let pt = s.TEXTURE_2D;
            if ((D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (pt = D.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), e.bindTexture(pt, $.__webglTexture), Pt(pt, v), v.mipmaps && v.mipmaps.length > 0) for (let wt = 0; wt < v.mipmaps.length; wt++) bt(z.__webglFramebuffer[wt], D, v, s.COLOR_ATTACHMENT0, pt, wt);
            else bt(z.__webglFramebuffer, D, v, s.COLOR_ATTACHMENT0, pt, 0);
            g(v) && A(pt), e.unbindTexture();
          }
          D.depthBuffer && Zt(D);
        }
        function be(D) {
          const v = D.textures;
          for (let z = 0, $ = v.length; z < $; z++) {
            const it = v[z];
            if (g(it)) {
              const J = x(D), St = i.get(it).__webglTexture;
              e.bindTexture(J, St), A(J), e.unbindTexture();
            }
          }
        }
        const Kt = [], L = [];
        function Mi(D) {
          if (D.samples > 0) {
            if ($t(D) === false) {
              const v = D.textures, z = D.width, $ = D.height;
              let it = s.COLOR_BUFFER_BIT;
              const J = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, St = i.get(D), pt = v.length > 1;
              if (pt) for (let wt = 0; wt < v.length; wt++) e.bindFramebuffer(s.FRAMEBUFFER, St.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + wt, s.RENDERBUFFER, null), e.bindFramebuffer(s.FRAMEBUFFER, St.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + wt, s.TEXTURE_2D, null, 0);
              e.bindFramebuffer(s.READ_FRAMEBUFFER, St.__webglMultisampledFramebuffer), e.bindFramebuffer(s.DRAW_FRAMEBUFFER, St.__webglFramebuffer);
              for (let wt = 0; wt < v.length; wt++) {
                if (D.resolveDepthBuffer && (D.depthBuffer && (it |= s.DEPTH_BUFFER_BIT), D.stencilBuffer && D.resolveStencilBuffer && (it |= s.STENCIL_BUFFER_BIT)), pt) {
                  s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, St.__webglColorRenderbuffer[wt]);
                  const se = i.get(v[wt]).__webglTexture;
                  s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, se, 0);
                }
                s.blitFramebuffer(0, 0, z, $, 0, 0, z, $, it, s.NEAREST), c === true && (Kt.length = 0, L.length = 0, Kt.push(s.COLOR_ATTACHMENT0 + wt), D.depthBuffer && D.resolveDepthBuffer === false && (Kt.push(J), L.push(J), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, L)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Kt));
              }
              if (e.bindFramebuffer(s.READ_FRAMEBUFFER, null), e.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), pt) for (let wt = 0; wt < v.length; wt++) {
                e.bindFramebuffer(s.FRAMEBUFFER, St.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + wt, s.RENDERBUFFER, St.__webglColorRenderbuffer[wt]);
                const se = i.get(v[wt]).__webglTexture;
                e.bindFramebuffer(s.FRAMEBUFFER, St.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + wt, s.TEXTURE_2D, se, 0);
              }
              e.bindFramebuffer(s.DRAW_FRAMEBUFFER, St.__webglMultisampledFramebuffer);
            } else if (D.depthBuffer && D.resolveDepthBuffer === false && c) {
              const v = D.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
              s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [
                v
              ]);
            }
          }
        }
        function re(D) {
          return Math.min(n.maxSamples, D.samples);
        }
        function $t(D) {
          const v = i.get(D);
          return D.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && v.__useRenderToTexture !== false;
        }
        function It(D) {
          const v = a.render.frame;
          h.get(D) !== v && (h.set(D, v), D.update());
        }
        function xe(D, v) {
          const z = D.colorSpace, $ = D.format, it = D.type;
          return D.isCompressedTexture === true || D.isVideoTexture === true || z !== di && z !== an && (zt.getTransfer(z) === ge ? ($ !== We || it !== Je) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", z)), v;
        }
        function Ct(D) {
          return typeof HTMLImageElement < "u" && D instanceof HTMLImageElement ? (l.width = D.naturalWidth || D.width, l.height = D.naturalHeight || D.height) : typeof VideoFrame < "u" && D instanceof VideoFrame ? (l.width = D.displayWidth, l.height = D.displayHeight) : (l.width = D.width, l.height = D.height), l;
        }
        this.allocateTextureUnit = H, this.resetTextureUnits = G, this.setTexture2D = et, this.setTexture2DArray = q, this.setTexture3D = Z, this.setTextureCube = W, this.rebindTextures = Ft, this.setupRenderTarget = Se, this.updateRenderTargetMipmap = be, this.updateMultisampleRenderTarget = Mi, this.setupDepthRenderbuffer = Zt, this.setupFrameBufferTexture = bt, this.useMultisampledRTT = $t;
      }
      function rv(s, t) {
        function e(i, n = an) {
          let r;
          const a = zt.getTransfer(n);
          if (i === Je) return s.UNSIGNED_BYTE;
          if (i === Fh) return s.UNSIGNED_SHORT_4_4_4_4;
          if (i === Lh) return s.UNSIGNED_SHORT_5_5_5_1;
          if (i === cp) return s.UNSIGNED_INT_5_9_9_9_REV;
          if (i === ap) return s.BYTE;
          if (i === op) return s.SHORT;
          if (i === js) return s.UNSIGNED_SHORT;
          if (i === Ph) return s.INT;
          if (i === _r) return s.UNSIGNED_INT;
          if (i === ii) return s.FLOAT;
          if (i === Ci) return s.HALF_FLOAT;
          if (i === lp) return s.ALPHA;
          if (i === hp) return s.RGB;
          if (i === We) return s.RGBA;
          if (i === dp) return s.LUMINANCE;
          if (i === up) return s.LUMINANCE_ALPHA;
          if (i === Xs) return s.DEPTH_COMPONENT;
          if (i === Ys) return s.DEPTH_STENCIL;
          if (i === xn) return s.RED;
          if (i === kh) return s.RED_INTEGER;
          if (i === ur) return s.RG;
          if (i === Nh) return s.RG_INTEGER;
          if (i === Uh) return s.RGBA_INTEGER;
          if (i === wo || i === Ns || i === bo || i === Us) if (a === ge) if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
            if (i === wo) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === Ns) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === bo) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === Us) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (r = t.get("WEBGL_compressed_texture_s3tc"), r !== null) {
            if (i === wo) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Ns) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === bo) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Us) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (i === Io || i === Ql || i === Mo || i === Ol) if (r = t.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
            if (i === Io) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === Ql) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === Mo) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === Ol) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (i === To || i === Ro || i === Bo) if (r = t.get("WEBGL_compressed_texture_etc"), r !== null) {
            if (i === To || i === Ro) return a === ge ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (i === Bo) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (i === Ks || i === zl || i === Gl || i === Hl || i === Js || i === Vl || i === Wl || i === jl || i === ql || i === Xl || i === Yl || i === Kl || i === Jl || i === Zl) if (r = t.get("WEBGL_compressed_texture_astc"), r !== null) {
            if (i === Ks) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === zl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === Gl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === Hl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === Js) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === Vl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === Wl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === jl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === ql) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === Xl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === Yl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === Kl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === Jl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === Zl) return a === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (i === Qs || i === $l || i === Do) if (r = t.get("EXT_texture_compression_bptc"), r !== null) {
            if (i === Qs) return a === ge ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === $l) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === Do) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
          } else return null;
          if (i === fp || i === th || i === eh || i === ih) if (r = t.get("EXT_texture_compression_rgtc"), r !== null) {
            if (i === Qs) return r.COMPRESSED_RED_RGTC1_EXT;
            if (i === th) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === eh) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === ih) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return i === qs ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
        }
        return {
          convert: e
        };
      }
      const sv = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, av = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class ov {
        constructor() {
          this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(t, e, i) {
          if (this.texture === null) {
            const n = new Pe(), r = t.properties.get(n);
            r.__webglTexture = e.texture, (e.depthNear !== i.depthNear || e.depthFar !== i.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = n;
          }
        }
        getMesh(t) {
          if (this.texture !== null && this.mesh === null) {
            const e = t.cameras[0].viewport, i = new Ni({
              vertexShader: sv,
              fragmentShader: av,
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: e.z
                },
                depthHeight: {
                  value: e.w
                }
              }
            });
            this.mesh = new me(new vr(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class cv extends Xn {
        constructor(t, e) {
          super();
          const i = this;
          let n = null, r = 1, a = null, o = "local-floor", c = 1, l = null, h = null, d = null, u = null, f = null, p = null;
          const m = new ov(), g = e.getContextAttributes();
          let A = null, x = null;
          const b = [], y = [], M = new rt();
          let T = null;
          const R = new Ve();
          R.viewport = new jt();
          const B = new Ve();
          B.viewport = new jt();
          const S = [
            R,
            B
          ], E = new dw();
          let P = null, G = null;
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(K) {
            let ot = b[K];
            return ot === void 0 && (ot = new Nc(), b[K] = ot), ot.getTargetRaySpace();
          }, this.getControllerGrip = function(K) {
            let ot = b[K];
            return ot === void 0 && (ot = new Nc(), b[K] = ot), ot.getGripSpace();
          }, this.getHand = function(K) {
            let ot = b[K];
            return ot === void 0 && (ot = new Nc(), b[K] = ot), ot.getHandSpace();
          };
          function H(K) {
            const ot = y.indexOf(K.inputSource);
            if (ot === -1) return;
            const bt = b[ot];
            bt !== void 0 && (bt.update(K.inputSource, K.frame, l || a), bt.dispatchEvent({
              type: K.type,
              data: K.inputSource
            }));
          }
          function Y() {
            n.removeEventListener("select", H), n.removeEventListener("selectstart", H), n.removeEventListener("selectend", H), n.removeEventListener("squeeze", H), n.removeEventListener("squeezestart", H), n.removeEventListener("squeezeend", H), n.removeEventListener("end", Y), n.removeEventListener("inputsourceschange", et);
            for (let K = 0; K < b.length; K++) {
              const ot = y[K];
              ot !== null && (y[K] = null, b[K].disconnect(ot));
            }
            P = null, G = null, m.reset(), t.setRenderTarget(A), f = null, u = null, d = null, n = null, x = null, Vt.stop(), i.isPresenting = false, t.setPixelRatio(T), t.setSize(M.width, M.height, false), i.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(K) {
            r = K, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(K) {
            o = K, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return l || a;
          }, this.setReferenceSpace = function(K) {
            l = K;
          }, this.getBaseLayer = function() {
            return u !== null ? u : f;
          }, this.getBinding = function() {
            return d;
          }, this.getFrame = function() {
            return p;
          }, this.getSession = function() {
            return n;
          }, this.setSession = async function(K) {
            if (n = K, n !== null) {
              if (A = t.getRenderTarget(), n.addEventListener("select", H), n.addEventListener("selectstart", H), n.addEventListener("selectend", H), n.addEventListener("squeeze", H), n.addEventListener("squeezestart", H), n.addEventListener("squeezeend", H), n.addEventListener("end", Y), n.addEventListener("inputsourceschange", et), g.xrCompatible !== true && await e.makeXRCompatible(), T = t.getPixelRatio(), t.getSize(M), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                let bt = null, lt = null, Tt = null;
                g.depth && (Tt = g.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, bt = g.stencil ? Ys : Xs, lt = g.stencil ? qs : _r);
                const Zt = {
                  colorFormat: e.RGBA8,
                  depthFormat: Tt,
                  scaleFactor: r
                };
                d = new XRWebGLBinding(n, e), u = d.createProjectionLayer(Zt), n.updateRenderState({
                  layers: [
                    u
                  ]
                }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, false), x = new In(u.textureWidth, u.textureHeight, {
                  format: We,
                  type: Je,
                  depthTexture: new Mp(u.textureWidth, u.textureHeight, lt, void 0, void 0, void 0, void 0, void 0, void 0, bt),
                  stencilBuffer: g.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: g.antialias ? 4 : 0,
                  resolveDepthBuffer: u.ignoreDepthValues === false,
                  resolveStencilBuffer: u.ignoreDepthValues === false
                });
              } else {
                const bt = {
                  antialias: g.antialias,
                  alpha: true,
                  depth: g.depth,
                  stencil: g.stencil,
                  framebufferScaleFactor: r
                };
                f = new XRWebGLLayer(n, e, bt), n.updateRenderState({
                  baseLayer: f
                }), t.setPixelRatio(1), t.setSize(f.framebufferWidth, f.framebufferHeight, false), x = new In(f.framebufferWidth, f.framebufferHeight, {
                  format: We,
                  type: Je,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: g.stencil,
                  resolveDepthBuffer: f.ignoreDepthValues === false,
                  resolveStencilBuffer: f.ignoreDepthValues === false
                });
              }
              x.isXRRenderTarget = true, this.setFoveation(c), l = null, a = await n.requestReferenceSpace(o), Vt.setContext(n), Vt.start(), i.isPresenting = true, i.dispatchEvent({
                type: "sessionstart"
              });
            }
          }, this.getEnvironmentBlendMode = function() {
            if (n !== null) return n.environmentBlendMode;
          }, this.getDepthTexture = function() {
            return m.getDepthTexture();
          };
          function et(K) {
            for (let ot = 0; ot < K.removed.length; ot++) {
              const bt = K.removed[ot], lt = y.indexOf(bt);
              lt >= 0 && (y[lt] = null, b[lt].disconnect(bt));
            }
            for (let ot = 0; ot < K.added.length; ot++) {
              const bt = K.added[ot];
              let lt = y.indexOf(bt);
              if (lt === -1) {
                for (let Zt = 0; Zt < b.length; Zt++) if (Zt >= y.length) {
                  y.push(bt), lt = Zt;
                  break;
                } else if (y[Zt] === null) {
                  y[Zt] = bt, lt = Zt;
                  break;
                }
                if (lt === -1) break;
              }
              const Tt = b[lt];
              Tt && Tt.connect(bt);
            }
          }
          const q = new I(), Z = new I();
          function W(K, ot, bt) {
            q.setFromMatrixPosition(ot.matrixWorld), Z.setFromMatrixPosition(bt.matrixWorld);
            const lt = q.distanceTo(Z), Tt = ot.projectionMatrix.elements, Zt = bt.projectionMatrix.elements, Ft = Tt[14] / (Tt[10] - 1), Se = Tt[14] / (Tt[10] + 1), be = (Tt[9] + 1) / Tt[5], Kt = (Tt[9] - 1) / Tt[5], L = (Tt[8] - 1) / Tt[0], Mi = (Zt[8] + 1) / Zt[0], re = Ft * L, $t = Ft * Mi, It = lt / (-L + Mi), xe = It * -L;
            if (ot.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(xe), K.translateZ(It), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert(), Tt[10] === -1) K.projectionMatrix.copy(ot.projectionMatrix), K.projectionMatrixInverse.copy(ot.projectionMatrixInverse);
            else {
              const Ct = Ft + It, D = Se + It, v = re - xe, z = $t + (lt - xe), $ = be * Se / D * Ct, it = Kt * Se / D * Ct;
              K.projectionMatrix.makePerspective(v, z, $, it, Ct, D), K.projectionMatrixInverse.copy(K.projectionMatrix).invert();
            }
          }
          function st(K, ot) {
            ot === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(ot.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert();
          }
          this.updateCamera = function(K) {
            if (n === null) return;
            let ot = K.near, bt = K.far;
            m.texture !== null && (m.depthNear > 0 && (ot = m.depthNear), m.depthFar > 0 && (bt = m.depthFar)), E.near = B.near = R.near = ot, E.far = B.far = R.far = bt, (P !== E.near || G !== E.far) && (n.updateRenderState({
              depthNear: E.near,
              depthFar: E.far
            }), P = E.near, G = E.far), R.layers.mask = K.layers.mask | 2, B.layers.mask = K.layers.mask | 4, E.layers.mask = R.layers.mask | B.layers.mask;
            const lt = K.parent, Tt = E.cameras;
            st(E, lt);
            for (let Zt = 0; Zt < Tt.length; Zt++) st(Tt[Zt], lt);
            Tt.length === 2 ? W(E, R, B) : E.projectionMatrix.copy(R.projectionMatrix), dt(K, E, lt);
          };
          function dt(K, ot, bt) {
            bt === null ? K.matrix.copy(ot.matrixWorld) : (K.matrix.copy(bt.matrixWorld), K.matrix.invert(), K.matrix.multiply(ot.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(true), K.projectionMatrix.copy(ot.projectionMatrix), K.projectionMatrixInverse.copy(ot.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = os * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1);
          }
          this.getCamera = function() {
            return E;
          }, this.getFoveation = function() {
            if (!(u === null && f === null)) return c;
          }, this.setFoveation = function(K) {
            c = K, u !== null && (u.fixedFoveation = K), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = K);
          }, this.hasDepthSensing = function() {
            return m.texture !== null;
          }, this.getDepthSensingMesh = function() {
            return m.getMesh(E);
          };
          let Et = null;
          function Pt(K, ot) {
            if (h = ot.getViewerPose(l || a), p = ot, h !== null) {
              const bt = h.views;
              f !== null && (t.setRenderTargetFramebuffer(x, f.framebuffer), t.setRenderTarget(x));
              let lt = false;
              bt.length !== E.cameras.length && (E.cameras.length = 0, lt = true);
              for (let Ft = 0; Ft < bt.length; Ft++) {
                const Se = bt[Ft];
                let be = null;
                if (f !== null) be = f.getViewport(Se);
                else {
                  const L = d.getViewSubImage(u, Se);
                  be = L.viewport, Ft === 0 && (t.setRenderTargetTextures(x, L.colorTexture, L.depthStencilTexture), t.setRenderTarget(x));
                }
                let Kt = S[Ft];
                Kt === void 0 && (Kt = new Ve(), Kt.layers.enable(Ft), Kt.viewport = new jt(), S[Ft] = Kt), Kt.matrix.fromArray(Se.transform.matrix), Kt.matrix.decompose(Kt.position, Kt.quaternion, Kt.scale), Kt.projectionMatrix.fromArray(Se.projectionMatrix), Kt.projectionMatrixInverse.copy(Kt.projectionMatrix).invert(), Kt.viewport.set(be.x, be.y, be.width, be.height), Ft === 0 && (E.matrix.copy(Kt.matrix), E.matrix.decompose(E.position, E.quaternion, E.scale)), lt === true && E.cameras.push(Kt);
              }
              const Tt = n.enabledFeatures;
              if (Tt && Tt.includes("depth-sensing") && n.depthUsage == "gpu-optimized" && d) {
                const Ft = d.getDepthInformation(bt[0]);
                Ft && Ft.isValid && Ft.texture && m.init(t, Ft, n.renderState);
              }
            }
            for (let bt = 0; bt < b.length; bt++) {
              const lt = y[bt], Tt = b[bt];
              lt !== null && Tt !== void 0 && Tt.update(lt, ot, l || a);
            }
            Et && Et(K, ot), ot.detectedPlanes && i.dispatchEvent({
              type: "planesdetected",
              data: ot
            }), p = null;
          }
          const Vt = new Kp();
          Vt.setAnimationLoop(Pt), this.setAnimationLoop = function(K) {
            Et = K;
          }, this.dispose = function() {
          };
        }
      }
      const ar = new Oe(), lv = new ft();
      function hv(s, t) {
        function e(g, A) {
          g.matrixAutoUpdate === true && g.updateMatrix(), A.value.copy(g.matrix);
        }
        function i(g, A) {
          A.color.getRGB(g.fogColor.value, xp(s)), A.isFog ? (g.fogNear.value = A.near, g.fogFar.value = A.far) : A.isFogExp2 && (g.fogDensity.value = A.density);
        }
        function n(g, A, x, b, y) {
          A.isMeshBasicMaterial || A.isMeshLambertMaterial ? r(g, A) : A.isMeshToonMaterial ? (r(g, A), d(g, A)) : A.isMeshPhongMaterial ? (r(g, A), h(g, A)) : A.isMeshStandardMaterial ? (r(g, A), u(g, A), A.isMeshPhysicalMaterial && f(g, A, y)) : A.isMeshMatcapMaterial ? (r(g, A), p(g, A)) : A.isMeshDepthMaterial ? r(g, A) : A.isMeshDistanceMaterial ? (r(g, A), m(g, A)) : A.isMeshNormalMaterial ? r(g, A) : A.isLineBasicMaterial ? (a(g, A), A.isLineDashedMaterial && o(g, A)) : A.isPointsMaterial ? c(g, A, x, b) : A.isSpriteMaterial ? l(g, A) : A.isShadowMaterial ? (g.color.value.copy(A.color), g.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = false);
        }
        function r(g, A) {
          g.opacity.value = A.opacity, A.color && g.diffuse.value.copy(A.color), A.emissive && g.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (g.map.value = A.map, e(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, e(A.alphaMap, g.alphaMapTransform)), A.bumpMap && (g.bumpMap.value = A.bumpMap, e(A.bumpMap, g.bumpMapTransform), g.bumpScale.value = A.bumpScale, A.side === yi && (g.bumpScale.value *= -1)), A.normalMap && (g.normalMap.value = A.normalMap, e(A.normalMap, g.normalMapTransform), g.normalScale.value.copy(A.normalScale), A.side === yi && g.normalScale.value.negate()), A.displacementMap && (g.displacementMap.value = A.displacementMap, e(A.displacementMap, g.displacementMapTransform), g.displacementScale.value = A.displacementScale, g.displacementBias.value = A.displacementBias), A.emissiveMap && (g.emissiveMap.value = A.emissiveMap, e(A.emissiveMap, g.emissiveMapTransform)), A.specularMap && (g.specularMap.value = A.specularMap, e(A.specularMap, g.specularMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
          const x = t.get(A), b = x.envMap, y = x.envMapRotation;
          b && (g.envMap.value = b, ar.copy(y), ar.x *= -1, ar.y *= -1, ar.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === false && (ar.y *= -1, ar.z *= -1), g.envMapRotation.value.setFromMatrix4(lv.makeRotationFromEuler(ar)), g.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = A.reflectivity, g.ior.value = A.ior, g.refractionRatio.value = A.refractionRatio), A.lightMap && (g.lightMap.value = A.lightMap, g.lightMapIntensity.value = A.lightMapIntensity, e(A.lightMap, g.lightMapTransform)), A.aoMap && (g.aoMap.value = A.aoMap, g.aoMapIntensity.value = A.aoMapIntensity, e(A.aoMap, g.aoMapTransform));
        }
        function a(g, A) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, A.map && (g.map.value = A.map, e(A.map, g.mapTransform));
        }
        function o(g, A) {
          g.dashSize.value = A.dashSize, g.totalSize.value = A.dashSize + A.gapSize, g.scale.value = A.scale;
        }
        function c(g, A, x, b) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.size.value = A.size * x, g.scale.value = b * 0.5, A.map && (g.map.value = A.map, e(A.map, g.uvTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, e(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
        }
        function l(g, A) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.rotation.value = A.rotation, A.map && (g.map.value = A.map, e(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, e(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
        }
        function h(g, A) {
          g.specular.value.copy(A.specular), g.shininess.value = Math.max(A.shininess, 1e-4);
        }
        function d(g, A) {
          A.gradientMap && (g.gradientMap.value = A.gradientMap);
        }
        function u(g, A) {
          g.metalness.value = A.metalness, A.metalnessMap && (g.metalnessMap.value = A.metalnessMap, e(A.metalnessMap, g.metalnessMapTransform)), g.roughness.value = A.roughness, A.roughnessMap && (g.roughnessMap.value = A.roughnessMap, e(A.roughnessMap, g.roughnessMapTransform)), A.envMap && (g.envMapIntensity.value = A.envMapIntensity);
        }
        function f(g, A, x) {
          g.ior.value = A.ior, A.sheen > 0 && (g.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), g.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (g.sheenColorMap.value = A.sheenColorMap, e(A.sheenColorMap, g.sheenColorMapTransform)), A.sheenRoughnessMap && (g.sheenRoughnessMap.value = A.sheenRoughnessMap, e(A.sheenRoughnessMap, g.sheenRoughnessMapTransform))), A.clearcoat > 0 && (g.clearcoat.value = A.clearcoat, g.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (g.clearcoatMap.value = A.clearcoatMap, e(A.clearcoatMap, g.clearcoatMapTransform)), A.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, e(A.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (g.clearcoatNormalMap.value = A.clearcoatNormalMap, e(A.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A.side === yi && g.clearcoatNormalScale.value.negate())), A.dispersion > 0 && (g.dispersion.value = A.dispersion), A.iridescence > 0 && (g.iridescence.value = A.iridescence, g.iridescenceIOR.value = A.iridescenceIOR, g.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (g.iridescenceMap.value = A.iridescenceMap, e(A.iridescenceMap, g.iridescenceMapTransform)), A.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = A.iridescenceThicknessMap, e(A.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), A.transmission > 0 && (g.transmission.value = A.transmission, g.transmissionSamplerMap.value = x.texture, g.transmissionSamplerSize.value.set(x.width, x.height), A.transmissionMap && (g.transmissionMap.value = A.transmissionMap, e(A.transmissionMap, g.transmissionMapTransform)), g.thickness.value = A.thickness, A.thicknessMap && (g.thicknessMap.value = A.thicknessMap, e(A.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = A.attenuationDistance, g.attenuationColor.value.copy(A.attenuationColor)), A.anisotropy > 0 && (g.anisotropyVector.value.set(A.anisotropy * Math.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (g.anisotropyMap.value = A.anisotropyMap, e(A.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = A.specularIntensity, g.specularColor.value.copy(A.specularColor), A.specularColorMap && (g.specularColorMap.value = A.specularColorMap, e(A.specularColorMap, g.specularColorMapTransform)), A.specularIntensityMap && (g.specularIntensityMap.value = A.specularIntensityMap, e(A.specularIntensityMap, g.specularIntensityMapTransform));
        }
        function p(g, A) {
          A.matcap && (g.matcap.value = A.matcap);
        }
        function m(g, A) {
          const x = t.get(A).light;
          g.referencePosition.value.setFromMatrixPosition(x.matrixWorld), g.nearDistance.value = x.shadow.camera.near, g.farDistance.value = x.shadow.camera.far;
        }
        return {
          refreshFogUniforms: i,
          refreshMaterialUniforms: n
        };
      }
      function dv(s, t, e, i) {
        let n = {}, r = {}, a = [];
        const o = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
        function c(x, b) {
          const y = b.program;
          i.uniformBlockBinding(x, y);
        }
        function l(x, b) {
          let y = n[x.id];
          y === void 0 && (p(x), y = h(x), n[x.id] = y, x.addEventListener("dispose", g));
          const M = b.program;
          i.updateUBOMapping(x, M);
          const T = t.render.frame;
          r[x.id] !== T && (u(x), r[x.id] = T);
        }
        function h(x) {
          const b = d();
          x.__bindingPointIndex = b;
          const y = s.createBuffer(), M = x.__size, T = x.usage;
          return s.bindBuffer(s.UNIFORM_BUFFER, y), s.bufferData(s.UNIFORM_BUFFER, M, T), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, b, y), y;
        }
        function d() {
          for (let x = 0; x < o; x++) if (a.indexOf(x) === -1) return a.push(x), x;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function u(x) {
          const b = n[x.id], y = x.uniforms, M = x.__cache;
          s.bindBuffer(s.UNIFORM_BUFFER, b);
          for (let T = 0, R = y.length; T < R; T++) {
            const B = Array.isArray(y[T]) ? y[T] : [
              y[T]
            ];
            for (let S = 0, E = B.length; S < E; S++) {
              const P = B[S];
              if (f(P, T, S, M) === true) {
                const G = P.__offset, H = Array.isArray(P.value) ? P.value : [
                  P.value
                ];
                let Y = 0;
                for (let et = 0; et < H.length; et++) {
                  const q = H[et], Z = m(q);
                  typeof q == "number" || typeof q == "boolean" ? (P.__data[0] = q, s.bufferSubData(s.UNIFORM_BUFFER, G + Y, P.__data)) : q.isMatrix3 ? (P.__data[0] = q.elements[0], P.__data[1] = q.elements[1], P.__data[2] = q.elements[2], P.__data[3] = 0, P.__data[4] = q.elements[3], P.__data[5] = q.elements[4], P.__data[6] = q.elements[5], P.__data[7] = 0, P.__data[8] = q.elements[6], P.__data[9] = q.elements[7], P.__data[10] = q.elements[8], P.__data[11] = 0) : (q.toArray(P.__data, Y), Y += Z.storage / Float32Array.BYTES_PER_ELEMENT);
                }
                s.bufferSubData(s.UNIFORM_BUFFER, G, P.__data);
              }
            }
          }
          s.bindBuffer(s.UNIFORM_BUFFER, null);
        }
        function f(x, b, y, M) {
          const T = x.value, R = b + "_" + y;
          if (M[R] === void 0) return typeof T == "number" || typeof T == "boolean" ? M[R] = T : M[R] = T.clone(), true;
          {
            const B = M[R];
            if (typeof T == "number" || typeof T == "boolean") {
              if (B !== T) return M[R] = T, true;
            } else if (B.equals(T) === false) return B.copy(T), true;
          }
          return false;
        }
        function p(x) {
          const b = x.uniforms;
          let y = 0;
          const M = 16;
          for (let R = 0, B = b.length; R < B; R++) {
            const S = Array.isArray(b[R]) ? b[R] : [
              b[R]
            ];
            for (let E = 0, P = S.length; E < P; E++) {
              const G = S[E], H = Array.isArray(G.value) ? G.value : [
                G.value
              ];
              for (let Y = 0, et = H.length; Y < et; Y++) {
                const q = H[Y], Z = m(q), W = y % M, st = W % Z.boundary, dt = W + st;
                y += st, dt !== 0 && M - dt < Z.storage && (y += M - dt), G.__data = new Float32Array(Z.storage / Float32Array.BYTES_PER_ELEMENT), G.__offset = y, y += Z.storage;
              }
            }
          }
          const T = y % M;
          return T > 0 && (y += M - T), x.__size = y, x.__cache = {}, this;
        }
        function m(x) {
          const b = {
            boundary: 0,
            storage: 0
          };
          return typeof x == "number" || typeof x == "boolean" ? (b.boundary = 4, b.storage = 4) : x.isVector2 ? (b.boundary = 8, b.storage = 8) : x.isVector3 || x.isColor ? (b.boundary = 16, b.storage = 12) : x.isVector4 ? (b.boundary = 16, b.storage = 16) : x.isMatrix3 ? (b.boundary = 48, b.storage = 48) : x.isMatrix4 ? (b.boundary = 64, b.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), b;
        }
        function g(x) {
          const b = x.target;
          b.removeEventListener("dispose", g);
          const y = a.indexOf(b.__bindingPointIndex);
          a.splice(y, 1), s.deleteBuffer(n[b.id]), delete n[b.id], delete r[b.id];
        }
        function A() {
          for (const x in n) s.deleteBuffer(n[x]);
          a = [], n = {}, r = {};
        }
        return {
          bind: c,
          update: l,
          dispose: A
        };
      }
      class eA {
        constructor(t = {}) {
          const { canvas: e = B_(), context: i = null, depth: n = true, stencil: r = false, alpha: a = false, antialias: o = false, premultipliedAlpha: c = true, preserveDrawingBuffer: l = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false, reverseDepthBuffer: u = false } = t;
          this.isWebGLRenderer = true;
          let f;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = i.getContextAttributes().alpha;
          } else f = a;
          const p = new Uint32Array(4), m = new Int32Array(4);
          let g = null, A = null;
          const x = [], b = [];
          this.domElement = e, this.debug = {
            checkShaderErrors: true,
            onShaderError: null
          }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.toneMapping = Vn, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
          const y = this;
          let M = false;
          this._outputColorSpace = ne;
          let T = 0, R = 0, B = null, S = -1, E = null;
          const P = new jt(), G = new jt();
          let H = null;
          const Y = new ht(0);
          let et = 0, q = e.width, Z = e.height, W = 1, st = null, dt = null;
          const Et = new jt(0, 0, q, Z), Pt = new jt(0, 0, q, Z);
          let Vt = false;
          const K = new jh();
          let ot = false, bt = false;
          const lt = new ft(), Tt = new ft(), Zt = new I(), Ft = new jt(), Se = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
          };
          let be = false;
          function Kt() {
            return B === null ? W : 1;
          }
          let L = i;
          function Mi(C, Q) {
            return e.getContext(C, Q);
          }
          try {
            const C = {
              alpha: true,
              depth: n,
              stencil: r,
              antialias: o,
              premultipliedAlpha: c,
              preserveDrawingBuffer: l,
              powerPreference: h,
              failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Dh}`), e.addEventListener("webglcontextlost", tt, false), e.addEventListener("webglcontextrestored", _t, false), e.addEventListener("webglcontextcreationerror", gt, false), L === null) {
              const Q = "webgl2";
              if (L = Mi(Q, C), L === null) throw Mi(Q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (C) {
            throw console.error("THREE.WebGLRenderer: " + C.message), C;
          }
          let re, $t, It, xe, Ct, D, v, z, $, it, J, St, pt, wt, se, at, yt, Lt, Nt, xt, te, qt, ye, U;
          function At() {
            re = new x0(L), re.init(), qt = new rv(L, re), $t = new A0(L, re, t, qt), It = new iv(L, re), $t.reverseDepthBuffer && u && It.buffers.depth.setReversed(true), xe = new S0(L), Ct = new Hx(), D = new nv(L, re, It, Ct, $t, qt, xe), v = new _0(y), z = new y0(y), $ = new Bw(L), ye = new f0(L, $), it = new v0(L, $, xe, ye), J = new I0(L, it, $, xe), Nt = new C0(L, $t, D), at = new g0(Ct), St = new Gx(y, v, z, re, $t, ye, at), pt = new hv(y, Ct), wt = new Wx(), se = new Jx(re), Lt = new u0(y, v, z, It, J, f, c), yt = new tv(y, J, $t), U = new dv(L, xe, $t, It), xt = new p0(L, re, xe), te = new E0(L, re, xe), xe.programs = St.programs, y.capabilities = $t, y.extensions = re, y.properties = Ct, y.renderLists = wt, y.shadowMap = yt, y.state = It, y.info = xe;
          }
          At();
          const X = new cv(y, L);
          this.xr = X, this.getContext = function() {
            return L;
          }, this.getContextAttributes = function() {
            return L.getContextAttributes();
          }, this.forceContextLoss = function() {
            const C = re.get("WEBGL_lose_context");
            C && C.loseContext();
          }, this.forceContextRestore = function() {
            const C = re.get("WEBGL_lose_context");
            C && C.restoreContext();
          }, this.getPixelRatio = function() {
            return W;
          }, this.setPixelRatio = function(C) {
            C !== void 0 && (W = C, this.setSize(q, Z, false));
          }, this.getSize = function(C) {
            return C.set(q, Z);
          }, this.setSize = function(C, Q, V = true) {
            if (X.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            q = C, Z = Q, e.width = Math.floor(C * W), e.height = Math.floor(Q * W), V === true && (e.style.width = C + "px", e.style.height = Q + "px"), this.setViewport(0, 0, C, Q);
          }, this.getDrawingBufferSize = function(C) {
            return C.set(q * W, Z * W).floor();
          }, this.setDrawingBufferSize = function(C, Q, V) {
            q = C, Z = Q, W = V, e.width = Math.floor(C * V), e.height = Math.floor(Q * V), this.setViewport(0, 0, C, Q);
          }, this.getCurrentViewport = function(C) {
            return C.copy(P);
          }, this.getViewport = function(C) {
            return C.copy(Et);
          }, this.setViewport = function(C, Q, V, j) {
            C.isVector4 ? Et.set(C.x, C.y, C.z, C.w) : Et.set(C, Q, V, j), It.viewport(P.copy(Et).multiplyScalar(W).round());
          }, this.getScissor = function(C) {
            return C.copy(Pt);
          }, this.setScissor = function(C, Q, V, j) {
            C.isVector4 ? Pt.set(C.x, C.y, C.z, C.w) : Pt.set(C, Q, V, j), It.scissor(G.copy(Pt).multiplyScalar(W).round());
          }, this.getScissorTest = function() {
            return Vt;
          }, this.setScissorTest = function(C) {
            It.setScissorTest(Vt = C);
          }, this.setOpaqueSort = function(C) {
            st = C;
          }, this.setTransparentSort = function(C) {
            dt = C;
          }, this.getClearColor = function(C) {
            return C.copy(Lt.getClearColor());
          }, this.setClearColor = function() {
            Lt.setClearColor(...arguments);
          }, this.getClearAlpha = function() {
            return Lt.getClearAlpha();
          }, this.setClearAlpha = function() {
            Lt.setClearAlpha(...arguments);
          }, this.clear = function(C = true, Q = true, V = true) {
            let j = 0;
            if (C) {
              let O = false;
              if (B !== null) {
                const nt = B.texture.format;
                O = nt === Uh || nt === Nh || nt === kh;
              }
              if (O) {
                const nt = B.texture.type, ut = nt === Je || nt === _r || nt === js || nt === qs || nt === Fh || nt === Lh, mt = Lt.getClearColor(), vt = Lt.getClearAlpha(), Ut = mt.r, kt = mt.g, Mt = mt.b;
                ut ? (p[0] = Ut, p[1] = kt, p[2] = Mt, p[3] = vt, L.clearBufferuiv(L.COLOR, 0, p)) : (m[0] = Ut, m[1] = kt, m[2] = Mt, m[3] = vt, L.clearBufferiv(L.COLOR, 0, m));
              } else j |= L.COLOR_BUFFER_BIT;
            }
            Q && (j |= L.DEPTH_BUFFER_BIT), V && (j |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(j);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", tt, false), e.removeEventListener("webglcontextrestored", _t, false), e.removeEventListener("webglcontextcreationerror", gt, false), Lt.dispose(), wt.dispose(), se.dispose(), Ct.dispose(), v.dispose(), z.dispose(), J.dispose(), ye.dispose(), U.dispose(), St.dispose(), X.dispose(), X.removeEventListener("sessionstart", Bd), X.removeEventListener("sessionend", Dd), Yn.stop();
          };
          function tt(C) {
            C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = true;
          }
          function _t() {
            console.log("THREE.WebGLRenderer: Context Restored."), M = false;
            const C = xe.autoReset, Q = yt.enabled, V = yt.autoUpdate, j = yt.needsUpdate, O = yt.type;
            At(), xe.autoReset = C, yt.enabled = Q, yt.autoUpdate = V, yt.needsUpdate = j, yt.type = O;
          }
          function gt(C) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage);
          }
          function Wt(C) {
            const Q = C.target;
            Q.removeEventListener("dispose", Wt), Be(Q);
          }
          function Be(C) {
            si(C), Ct.remove(C);
          }
          function si(C) {
            const Q = Ct.get(C).programs;
            Q !== void 0 && (Q.forEach(function(V) {
              St.releaseProgram(V);
            }), C.isShaderMaterial && St.releaseShaderCache(C));
          }
          this.renderBufferDirect = function(C, Q, V, j, O, nt) {
            Q === null && (Q = Se);
            const ut = O.isMesh && O.matrixWorld.determinant() < 0, mt = wg(C, Q, V, j, O);
            It.setMaterial(j, ut);
            let vt = V.index, Ut = 1;
            if (j.wireframe === true) {
              if (vt = it.getWireframeAttribute(V), vt === void 0) return;
              Ut = 2;
            }
            const kt = V.drawRange, Mt = V.attributes.position;
            let ae = kt.start * Ut, he = (kt.start + kt.count) * Ut;
            nt !== null && (ae = Math.max(ae, nt.start * Ut), he = Math.min(he, (nt.start + nt.count) * Ut)), vt !== null ? (ae = Math.max(ae, 0), he = Math.min(he, vt.count)) : Mt != null && (ae = Math.max(ae, 0), he = Math.min(he, Mt.count));
            const Ne = he - ae;
            if (Ne < 0 || Ne === 1 / 0) return;
            ye.setup(O, j, mt, V, vt);
            let De, oe = xt;
            if (vt !== null && (De = $.get(vt), oe = te, oe.setIndex(De)), O.isMesh) j.wireframe === true ? (It.setLineWidth(j.wireframeLinewidth * Kt()), oe.setMode(L.LINES)) : oe.setMode(L.TRIANGLES);
            else if (O.isLine) {
              let Rt = j.linewidth;
              Rt === void 0 && (Rt = 1), It.setLineWidth(Rt * Kt()), O.isLineSegments ? oe.setMode(L.LINES) : O.isLineLoop ? oe.setMode(L.LINE_LOOP) : oe.setMode(L.LINE_STRIP);
            } else O.isPoints ? oe.setMode(L.POINTS) : O.isSprite && oe.setMode(L.TRIANGLES);
            if (O.isBatchedMesh) if (O._multiDrawInstances !== null) yo("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), oe.renderMultiDrawInstances(O._multiDrawStarts, O._multiDrawCounts, O._multiDrawCount, O._multiDrawInstances);
            else if (re.get("WEBGL_multi_draw")) oe.renderMultiDraw(O._multiDrawStarts, O._multiDrawCounts, O._multiDrawCount);
            else {
              const Rt = O._multiDrawStarts, $e = O._multiDrawCounts, de = O._multiDrawCount, zi = vt ? $.get(vt).bytesPerElement : 1, Er = Ct.get(j).currentProgram.getUniforms();
              for (let xi = 0; xi < de; xi++) Er.setValue(L, "_gl_DrawID", xi), oe.render(Rt[xi] / zi, $e[xi]);
            }
            else if (O.isInstancedMesh) oe.renderInstances(ae, Ne, O.count);
            else if (V.isInstancedBufferGeometry) {
              const Rt = V._maxInstanceCount !== void 0 ? V._maxInstanceCount : 1 / 0, $e = Math.min(V.instanceCount, Rt);
              oe.renderInstances(ae, Ne, $e);
            } else oe.render(ae, Ne);
          };
          function pe(C, Q, V) {
            C.transparent === true && C.side === Ki && C.forceSinglePass === false ? (C.side = yi, C.needsUpdate = true, Sa(C, Q, V), C.side = Cn, C.needsUpdate = true, Sa(C, Q, V), C.side = Ki) : Sa(C, Q, V);
          }
          this.compile = function(C, Q, V = null) {
            V === null && (V = C), A = se.get(V), A.init(Q), b.push(A), V.traverseVisible(function(O) {
              O.isLight && O.layers.test(Q.layers) && (A.pushLight(O), O.castShadow && A.pushShadow(O));
            }), C !== V && C.traverseVisible(function(O) {
              O.isLight && O.layers.test(Q.layers) && (A.pushLight(O), O.castShadow && A.pushShadow(O));
            }), A.setupLights();
            const j = /* @__PURE__ */ new Set();
            return C.traverse(function(O) {
              if (!(O.isMesh || O.isPoints || O.isLine || O.isSprite)) return;
              const nt = O.material;
              if (nt) if (Array.isArray(nt)) for (let ut = 0; ut < nt.length; ut++) {
                const mt = nt[ut];
                pe(mt, V, O), j.add(mt);
              }
              else pe(nt, V, O), j.add(nt);
            }), A = b.pop(), j;
          }, this.compileAsync = function(C, Q, V = null) {
            const j = this.compile(C, Q, V);
            return new Promise((O) => {
              function nt() {
                if (j.forEach(function(ut) {
                  Ct.get(ut).currentProgram.isReady() && j.delete(ut);
                }), j.size === 0) {
                  O(C);
                  return;
                }
                setTimeout(nt, 10);
              }
              re.get("KHR_parallel_shader_compile") !== null ? nt() : setTimeout(nt, 10);
            });
          };
          let Oi = null;
          function dn(C) {
            Oi && Oi(C);
          }
          function Bd() {
            Yn.stop();
          }
          function Dd() {
            Yn.start();
          }
          const Yn = new Kp();
          Yn.setAnimationLoop(dn), typeof self < "u" && Yn.setContext(self), this.setAnimationLoop = function(C) {
            Oi = C, X.setAnimationLoop(C), C === null ? Yn.stop() : Yn.start();
          }, X.addEventListener("sessionstart", Bd), X.addEventListener("sessionend", Dd), this.render = function(C, Q) {
            if (Q !== void 0 && Q.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (M === true) return;
            if (C.matrixWorldAutoUpdate === true && C.updateMatrixWorld(), Q.parent === null && Q.matrixWorldAutoUpdate === true && Q.updateMatrixWorld(), X.enabled === true && X.isPresenting === true && (X.cameraAutoUpdate === true && X.updateCamera(Q), Q = X.getCamera()), C.isScene === true && C.onBeforeRender(y, C, Q, B), A = se.get(C, b.length), A.init(Q), b.push(A), Tt.multiplyMatrices(Q.projectionMatrix, Q.matrixWorldInverse), K.setFromProjectionMatrix(Tt), bt = this.localClippingEnabled, ot = at.init(this.clippingPlanes, bt), g = wt.get(C, x.length), g.init(), x.push(g), X.enabled === true && X.isPresenting === true) {
              const nt = y.xr.getDepthSensingMesh();
              nt !== null && Ac(nt, Q, -1 / 0, y.sortObjects);
            }
            Ac(C, Q, 0, y.sortObjects), g.finish(), y.sortObjects === true && g.sort(st, dt), be = X.enabled === false || X.isPresenting === false || X.hasDepthSensing() === false, be && Lt.addToRenderList(g, C), this.info.render.frame++, ot === true && at.beginShadows();
            const V = A.state.shadowsArray;
            yt.render(V, C, Q), ot === true && at.endShadows(), this.info.autoReset === true && this.info.reset();
            const j = g.opaque, O = g.transmissive;
            if (A.setupLights(), Q.isArrayCamera) {
              const nt = Q.cameras;
              if (O.length > 0) for (let ut = 0, mt = nt.length; ut < mt; ut++) {
                const vt = nt[ut];
                Fd(j, O, C, vt);
              }
              be && Lt.render(C);
              for (let ut = 0, mt = nt.length; ut < mt; ut++) {
                const vt = nt[ut];
                Pd(g, C, vt, vt.viewport);
              }
            } else O.length > 0 && Fd(j, O, C, Q), be && Lt.render(C), Pd(g, C, Q);
            B !== null && R === 0 && (D.updateMultisampleRenderTarget(B), D.updateRenderTargetMipmap(B)), C.isScene === true && C.onAfterRender(y, C, Q), ye.resetDefaultState(), S = -1, E = null, b.pop(), b.length > 0 ? (A = b[b.length - 1], ot === true && at.setGlobalState(y.clippingPlanes, A.state.camera)) : A = null, x.pop(), x.length > 0 ? g = x[x.length - 1] : g = null;
          };
          function Ac(C, Q, V, j) {
            if (C.visible === false) return;
            if (C.layers.test(Q.layers)) {
              if (C.isGroup) V = C.renderOrder;
              else if (C.isLOD) C.autoUpdate === true && C.update(Q);
              else if (C.isLight) A.pushLight(C), C.castShadow && A.pushShadow(C);
              else if (C.isSprite) {
                if (!C.frustumCulled || K.intersectsSprite(C)) {
                  j && Ft.setFromMatrixPosition(C.matrixWorld).applyMatrix4(Tt);
                  const ut = J.update(C), mt = C.material;
                  mt.visible && g.push(C, ut, mt, V, Ft.z, null);
                }
              } else if ((C.isMesh || C.isLine || C.isPoints) && (!C.frustumCulled || K.intersectsObject(C))) {
                const ut = J.update(C), mt = C.material;
                if (j && (C.boundingSphere !== void 0 ? (C.boundingSphere === null && C.computeBoundingSphere(), Ft.copy(C.boundingSphere.center)) : (ut.boundingSphere === null && ut.computeBoundingSphere(), Ft.copy(ut.boundingSphere.center)), Ft.applyMatrix4(C.matrixWorld).applyMatrix4(Tt)), Array.isArray(mt)) {
                  const vt = ut.groups;
                  for (let Ut = 0, kt = vt.length; Ut < kt; Ut++) {
                    const Mt = vt[Ut], ae = mt[Mt.materialIndex];
                    ae && ae.visible && g.push(C, ut, ae, V, Ft.z, Mt);
                  }
                } else mt.visible && g.push(C, ut, mt, V, Ft.z, null);
              }
            }
            const nt = C.children;
            for (let ut = 0, mt = nt.length; ut < mt; ut++) Ac(nt[ut], Q, V, j);
          }
          function Pd(C, Q, V, j) {
            const O = C.opaque, nt = C.transmissive, ut = C.transparent;
            A.setupLightsView(V), ot === true && at.setGlobalState(y.clippingPlanes, V), j && It.viewport(P.copy(j)), O.length > 0 && Ea(O, Q, V), nt.length > 0 && Ea(nt, Q, V), ut.length > 0 && Ea(ut, Q, V), It.buffers.depth.setTest(true), It.buffers.depth.setMask(true), It.buffers.color.setMask(true), It.setPolygonOffset(false);
          }
          function Fd(C, Q, V, j) {
            if ((V.isScene === true ? V.overrideMaterial : null) !== null) return;
            A.state.transmissionRenderTarget[j.id] === void 0 && (A.state.transmissionRenderTarget[j.id] = new In(1, 1, {
              generateMipmaps: true,
              type: re.has("EXT_color_buffer_half_float") || re.has("EXT_color_buffer_float") ? Ci : Je,
              minFilter: Zi,
              samples: 4,
              stencilBuffer: r,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: zt.workingColorSpace
            }));
            const nt = A.state.transmissionRenderTarget[j.id], ut = j.viewport || P;
            nt.setSize(ut.z * y.transmissionResolutionScale, ut.w * y.transmissionResolutionScale);
            const mt = y.getRenderTarget();
            y.setRenderTarget(nt), y.getClearColor(Y), et = y.getClearAlpha(), et < 1 && y.setClearColor(16777215, 0.5), y.clear(), be && Lt.render(V);
            const vt = y.toneMapping;
            y.toneMapping = Vn;
            const Ut = j.viewport;
            if (j.viewport !== void 0 && (j.viewport = void 0), A.setupLightsView(j), ot === true && at.setGlobalState(y.clippingPlanes, j), Ea(C, V, j), D.updateMultisampleRenderTarget(nt), D.updateRenderTargetMipmap(nt), re.has("WEBGL_multisampled_render_to_texture") === false) {
              let kt = false;
              for (let Mt = 0, ae = Q.length; Mt < ae; Mt++) {
                const he = Q[Mt], Ne = he.object, De = he.geometry, oe = he.material, Rt = he.group;
                if (oe.side === Ki && Ne.layers.test(j.layers)) {
                  const $e = oe.side;
                  oe.side = yi, oe.needsUpdate = true, Ld(Ne, V, j, De, oe, Rt), oe.side = $e, oe.needsUpdate = true, kt = true;
                }
              }
              kt === true && (D.updateMultisampleRenderTarget(nt), D.updateRenderTargetMipmap(nt));
            }
            y.setRenderTarget(mt), y.setClearColor(Y, et), Ut !== void 0 && (j.viewport = Ut), y.toneMapping = vt;
          }
          function Ea(C, Q, V) {
            const j = Q.isScene === true ? Q.overrideMaterial : null;
            for (let O = 0, nt = C.length; O < nt; O++) {
              const ut = C[O], mt = ut.object, vt = ut.geometry, Ut = ut.group;
              let kt = ut.material;
              kt.allowOverride === true && j !== null && (kt = j), mt.layers.test(V.layers) && Ld(mt, Q, V, vt, kt, Ut);
            }
          }
          function Ld(C, Q, V, j, O, nt) {
            C.onBeforeRender(y, Q, V, j, O, nt), C.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), O.onBeforeRender(y, Q, V, j, C, nt), O.transparent === true && O.side === Ki && O.forceSinglePass === false ? (O.side = yi, O.needsUpdate = true, y.renderBufferDirect(V, Q, j, O, C, nt), O.side = Cn, O.needsUpdate = true, y.renderBufferDirect(V, Q, j, O, C, nt), O.side = Ki) : y.renderBufferDirect(V, Q, j, O, C, nt), C.onAfterRender(y, Q, V, j, O, nt);
          }
          function Sa(C, Q, V) {
            Q.isScene !== true && (Q = Se);
            const j = Ct.get(C), O = A.state.lights, nt = A.state.shadowsArray, ut = O.state.version, mt = St.getParameters(C, O.state, nt, Q, V), vt = St.getProgramCacheKey(mt);
            let Ut = j.programs;
            j.environment = C.isMeshStandardMaterial ? Q.environment : null, j.fog = Q.fog, j.envMap = (C.isMeshStandardMaterial ? z : v).get(C.envMap || j.environment), j.envMapRotation = j.environment !== null && C.envMap === null ? Q.environmentRotation : C.envMapRotation, Ut === void 0 && (C.addEventListener("dispose", Wt), Ut = /* @__PURE__ */ new Map(), j.programs = Ut);
            let kt = Ut.get(vt);
            if (kt !== void 0) {
              if (j.currentProgram === kt && j.lightsStateVersion === ut) return Nd(C, mt), kt;
            } else mt.uniforms = St.getUniforms(C), C.onBeforeCompile(mt, y), kt = St.acquireProgram(mt, vt), Ut.set(vt, kt), j.uniforms = mt.uniforms;
            const Mt = j.uniforms;
            return (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === true) && (Mt.clippingPlanes = at.uniform), Nd(C, mt), j.needsLights = yg(C), j.lightsStateVersion = ut, j.needsLights && (Mt.ambientLightColor.value = O.state.ambient, Mt.lightProbe.value = O.state.probe, Mt.directionalLights.value = O.state.directional, Mt.directionalLightShadows.value = O.state.directionalShadow, Mt.spotLights.value = O.state.spot, Mt.spotLightShadows.value = O.state.spotShadow, Mt.rectAreaLights.value = O.state.rectArea, Mt.ltc_1.value = O.state.rectAreaLTC1, Mt.ltc_2.value = O.state.rectAreaLTC2, Mt.pointLights.value = O.state.point, Mt.pointLightShadows.value = O.state.pointShadow, Mt.hemisphereLights.value = O.state.hemi, Mt.directionalShadowMap.value = O.state.directionalShadowMap, Mt.directionalShadowMatrix.value = O.state.directionalShadowMatrix, Mt.spotShadowMap.value = O.state.spotShadowMap, Mt.spotLightMatrix.value = O.state.spotLightMatrix, Mt.spotLightMap.value = O.state.spotLightMap, Mt.pointShadowMap.value = O.state.pointShadowMap, Mt.pointShadowMatrix.value = O.state.pointShadowMatrix), j.currentProgram = kt, j.uniformsList = null, kt;
          }
          function kd(C) {
            if (C.uniformsList === null) {
              const Q = C.currentProgram.getUniforms();
              C.uniformsList = vo.seqWithValue(Q.seq, C.uniforms);
            }
            return C.uniformsList;
          }
          function Nd(C, Q) {
            const V = Ct.get(C);
            V.outputColorSpace = Q.outputColorSpace, V.batching = Q.batching, V.batchingColor = Q.batchingColor, V.instancing = Q.instancing, V.instancingColor = Q.instancingColor, V.instancingMorph = Q.instancingMorph, V.skinning = Q.skinning, V.morphTargets = Q.morphTargets, V.morphNormals = Q.morphNormals, V.morphColors = Q.morphColors, V.morphTargetsCount = Q.morphTargetsCount, V.numClippingPlanes = Q.numClippingPlanes, V.numIntersection = Q.numClipIntersection, V.vertexAlphas = Q.vertexAlphas, V.vertexTangents = Q.vertexTangents, V.toneMapping = Q.toneMapping;
          }
          function wg(C, Q, V, j, O) {
            Q.isScene !== true && (Q = Se), D.resetTextureUnits();
            const nt = Q.fog, ut = j.isMeshStandardMaterial ? Q.environment : null, mt = B === null ? y.outputColorSpace : B.isXRRenderTarget === true ? B.texture.colorSpace : di, vt = (j.isMeshStandardMaterial ? z : v).get(j.envMap || ut), Ut = j.vertexColors === true && !!V.attributes.color && V.attributes.color.itemSize === 4, kt = !!V.attributes.tangent && (!!j.normalMap || j.anisotropy > 0), Mt = !!V.morphAttributes.position, ae = !!V.morphAttributes.normal, he = !!V.morphAttributes.color;
            let Ne = Vn;
            j.toneMapped && (B === null || B.isXRRenderTarget === true) && (Ne = y.toneMapping);
            const De = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color, oe = De !== void 0 ? De.length : 0, Rt = Ct.get(j), $e = A.state.lights;
            if (ot === true && (bt === true || C !== E)) {
              const ui = C === E && j.id === S;
              at.setState(j, C, ui);
            }
            let de = false;
            j.version === Rt.__version ? (Rt.needsLights && Rt.lightsStateVersion !== $e.state.version || Rt.outputColorSpace !== mt || O.isBatchedMesh && Rt.batching === false || !O.isBatchedMesh && Rt.batching === true || O.isBatchedMesh && Rt.batchingColor === true && O.colorTexture === null || O.isBatchedMesh && Rt.batchingColor === false && O.colorTexture !== null || O.isInstancedMesh && Rt.instancing === false || !O.isInstancedMesh && Rt.instancing === true || O.isSkinnedMesh && Rt.skinning === false || !O.isSkinnedMesh && Rt.skinning === true || O.isInstancedMesh && Rt.instancingColor === true && O.instanceColor === null || O.isInstancedMesh && Rt.instancingColor === false && O.instanceColor !== null || O.isInstancedMesh && Rt.instancingMorph === true && O.morphTexture === null || O.isInstancedMesh && Rt.instancingMorph === false && O.morphTexture !== null || Rt.envMap !== vt || j.fog === true && Rt.fog !== nt || Rt.numClippingPlanes !== void 0 && (Rt.numClippingPlanes !== at.numPlanes || Rt.numIntersection !== at.numIntersection) || Rt.vertexAlphas !== Ut || Rt.vertexTangents !== kt || Rt.morphTargets !== Mt || Rt.morphNormals !== ae || Rt.morphColors !== he || Rt.toneMapping !== Ne || Rt.morphTargetsCount !== oe) && (de = true) : (de = true, Rt.__version = j.version);
            let zi = Rt.currentProgram;
            de === true && (zi = Sa(j, Q, O));
            let Er = false, xi = false, ws = false;
            const Ce = zi.getUniforms(), Ti = Rt.uniforms;
            if (It.useProgram(zi.program) && (Er = true, xi = true, ws = true), j.id !== S && (S = j.id, xi = true), Er || E !== C) {
              It.buffers.depth.getReversed() ? (lt.copy(C.projectionMatrix), P_(lt), F_(lt), Ce.setValue(L, "projectionMatrix", lt)) : Ce.setValue(L, "projectionMatrix", C.projectionMatrix), Ce.setValue(L, "viewMatrix", C.matrixWorldInverse);
              const wi = Ce.map.cameraPosition;
              wi !== void 0 && wi.setValue(L, Zt.setFromMatrixPosition(C.matrixWorld)), $t.logarithmicDepthBuffer && Ce.setValue(L, "logDepthBufFC", 2 / (Math.log(C.far + 1) / Math.LN2)), (j.isMeshPhongMaterial || j.isMeshToonMaterial || j.isMeshLambertMaterial || j.isMeshBasicMaterial || j.isMeshStandardMaterial || j.isShaderMaterial) && Ce.setValue(L, "isOrthographic", C.isOrthographicCamera === true), E !== C && (E = C, xi = true, ws = true);
            }
            if (O.isSkinnedMesh) {
              Ce.setOptional(L, O, "bindMatrix"), Ce.setOptional(L, O, "bindMatrixInverse");
              const ui = O.skeleton;
              ui && (ui.boneTexture === null && ui.computeBoneTexture(), Ce.setValue(L, "boneTexture", ui.boneTexture, D));
            }
            O.isBatchedMesh && (Ce.setOptional(L, O, "batchingTexture"), Ce.setValue(L, "batchingTexture", O._matricesTexture, D), Ce.setOptional(L, O, "batchingIdTexture"), Ce.setValue(L, "batchingIdTexture", O._indirectTexture, D), Ce.setOptional(L, O, "batchingColorTexture"), O._colorsTexture !== null && Ce.setValue(L, "batchingColorTexture", O._colorsTexture, D));
            const Ri = V.morphAttributes;
            if ((Ri.position !== void 0 || Ri.normal !== void 0 || Ri.color !== void 0) && Nt.update(O, V, zi), (xi || Rt.receiveShadow !== O.receiveShadow) && (Rt.receiveShadow = O.receiveShadow, Ce.setValue(L, "receiveShadow", O.receiveShadow)), j.isMeshGouraudMaterial && j.envMap !== null && (Ti.envMap.value = vt, Ti.flipEnvMap.value = vt.isCubeTexture && vt.isRenderTargetTexture === false ? -1 : 1), j.isMeshStandardMaterial && j.envMap === null && Q.environment !== null && (Ti.envMapIntensity.value = Q.environmentIntensity), xi && (Ce.setValue(L, "toneMappingExposure", y.toneMappingExposure), Rt.needsLights && bg(Ti, ws), nt && j.fog === true && pt.refreshFogUniforms(Ti, nt), pt.refreshMaterialUniforms(Ti, j, W, Z, A.state.transmissionRenderTarget[C.id]), vo.upload(L, kd(Rt), Ti, D)), j.isShaderMaterial && j.uniformsNeedUpdate === true && (vo.upload(L, kd(Rt), Ti, D), j.uniformsNeedUpdate = false), j.isSpriteMaterial && Ce.setValue(L, "center", O.center), Ce.setValue(L, "modelViewMatrix", O.modelViewMatrix), Ce.setValue(L, "normalMatrix", O.normalMatrix), Ce.setValue(L, "modelMatrix", O.matrixWorld), j.isShaderMaterial || j.isRawShaderMaterial) {
              const ui = j.uniformsGroups;
              for (let wi = 0, gc = ui.length; wi < gc; wi++) {
                const Kn = ui[wi];
                U.update(Kn, zi), U.bind(Kn, zi);
              }
            }
            return zi;
          }
          function bg(C, Q) {
            C.ambientLightColor.needsUpdate = Q, C.lightProbe.needsUpdate = Q, C.directionalLights.needsUpdate = Q, C.directionalLightShadows.needsUpdate = Q, C.pointLights.needsUpdate = Q, C.pointLightShadows.needsUpdate = Q, C.spotLights.needsUpdate = Q, C.spotLightShadows.needsUpdate = Q, C.rectAreaLights.needsUpdate = Q, C.hemisphereLights.needsUpdate = Q;
          }
          function yg(C) {
            return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === true;
          }
          this.getActiveCubeFace = function() {
            return T;
          }, this.getActiveMipmapLevel = function() {
            return R;
          }, this.getRenderTarget = function() {
            return B;
          }, this.setRenderTargetTextures = function(C, Q, V) {
            const j = Ct.get(C);
            j.__autoAllocateDepthBuffer = C.resolveDepthBuffer === false, j.__autoAllocateDepthBuffer === false && (j.__useRenderToTexture = false), Ct.get(C.texture).__webglTexture = Q, Ct.get(C.depthTexture).__webglTexture = j.__autoAllocateDepthBuffer ? void 0 : V, j.__hasExternalTextures = true;
          }, this.setRenderTargetFramebuffer = function(C, Q) {
            const V = Ct.get(C);
            V.__webglFramebuffer = Q, V.__useDefaultFramebuffer = Q === void 0;
          };
          const xg = L.createFramebuffer();
          this.setRenderTarget = function(C, Q = 0, V = 0) {
            B = C, T = Q, R = V;
            let j = true, O = null, nt = false, ut = false;
            if (C) {
              const vt = Ct.get(C);
              if (vt.__useDefaultFramebuffer !== void 0) It.bindFramebuffer(L.FRAMEBUFFER, null), j = false;
              else if (vt.__webglFramebuffer === void 0) D.setupRenderTarget(C);
              else if (vt.__hasExternalTextures) D.rebindTextures(C, Ct.get(C.texture).__webglTexture, Ct.get(C.depthTexture).__webglTexture);
              else if (C.depthBuffer) {
                const Mt = C.depthTexture;
                if (vt.__boundDepthTexture !== Mt) {
                  if (Mt !== null && Ct.has(Mt) && (C.width !== Mt.image.width || C.height !== Mt.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  D.setupDepthRenderbuffer(C);
                }
              }
              const Ut = C.texture;
              (Ut.isData3DTexture || Ut.isDataArrayTexture || Ut.isCompressedArrayTexture) && (ut = true);
              const kt = Ct.get(C).__webglFramebuffer;
              C.isWebGLCubeRenderTarget ? (Array.isArray(kt[Q]) ? O = kt[Q][V] : O = kt[Q], nt = true) : C.samples > 0 && D.useMultisampledRTT(C) === false ? O = Ct.get(C).__webglMultisampledFramebuffer : Array.isArray(kt) ? O = kt[V] : O = kt, P.copy(C.viewport), G.copy(C.scissor), H = C.scissorTest;
            } else P.copy(Et).multiplyScalar(W).floor(), G.copy(Pt).multiplyScalar(W).floor(), H = Vt;
            if (V !== 0 && (O = xg), It.bindFramebuffer(L.FRAMEBUFFER, O) && j && It.drawBuffers(C, O), It.viewport(P), It.scissor(G), It.setScissorTest(H), nt) {
              const vt = Ct.get(C.texture);
              L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + Q, vt.__webglTexture, V);
            } else if (ut) {
              const vt = Ct.get(C.texture), Ut = Q;
              L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, vt.__webglTexture, V, Ut);
            } else if (C !== null && V !== 0) {
              const vt = Ct.get(C.texture);
              L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, vt.__webglTexture, V);
            }
            S = -1;
          }, this.readRenderTargetPixels = function(C, Q, V, j, O, nt, ut) {
            if (!(C && C.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let mt = Ct.get(C).__webglFramebuffer;
            if (C.isWebGLCubeRenderTarget && ut !== void 0 && (mt = mt[ut]), mt) {
              It.bindFramebuffer(L.FRAMEBUFFER, mt);
              try {
                const vt = C.texture, Ut = vt.format, kt = vt.type;
                if (!$t.textureFormatReadable(Ut)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                if (!$t.textureTypeReadable(kt)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                Q >= 0 && Q <= C.width - j && V >= 0 && V <= C.height - O && L.readPixels(Q, V, j, O, qt.convert(Ut), qt.convert(kt), nt);
              } finally {
                const vt = B !== null ? Ct.get(B).__webglFramebuffer : null;
                It.bindFramebuffer(L.FRAMEBUFFER, vt);
              }
            }
          }, this.readRenderTargetPixelsAsync = async function(C, Q, V, j, O, nt, ut) {
            if (!(C && C.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let mt = Ct.get(C).__webglFramebuffer;
            if (C.isWebGLCubeRenderTarget && ut !== void 0 && (mt = mt[ut]), mt) if (Q >= 0 && Q <= C.width - j && V >= 0 && V <= C.height - O) {
              It.bindFramebuffer(L.FRAMEBUFFER, mt);
              const vt = C.texture, Ut = vt.format, kt = vt.type;
              if (!$t.textureFormatReadable(Ut)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              if (!$t.textureTypeReadable(kt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              const Mt = L.createBuffer();
              L.bindBuffer(L.PIXEL_PACK_BUFFER, Mt), L.bufferData(L.PIXEL_PACK_BUFFER, nt.byteLength, L.STREAM_READ), L.readPixels(Q, V, j, O, qt.convert(Ut), qt.convert(kt), 0);
              const ae = B !== null ? Ct.get(B).__webglFramebuffer : null;
              It.bindFramebuffer(L.FRAMEBUFFER, ae);
              const he = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return L.flush(), await D_(L, he, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, Mt), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, nt), L.deleteBuffer(Mt), L.deleteSync(he), nt;
            } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
          }, this.copyFramebufferToTexture = function(C, Q = null, V = 0) {
            const j = Math.pow(2, -V), O = Math.floor(C.image.width * j), nt = Math.floor(C.image.height * j), ut = Q !== null ? Q.x : 0, mt = Q !== null ? Q.y : 0;
            D.setTexture2D(C, 0), L.copyTexSubImage2D(L.TEXTURE_2D, V, 0, 0, ut, mt, O, nt), It.unbindTexture();
          };
          const vg = L.createFramebuffer(), Eg = L.createFramebuffer();
          this.copyTextureToTexture = function(C, Q, V = null, j = null, O = 0, nt = null) {
            nt === null && (O !== 0 ? (yo("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), nt = O, O = 0) : nt = 0);
            let ut, mt, vt, Ut, kt, Mt, ae, he, Ne;
            const De = C.isCompressedTexture ? C.mipmaps[nt] : C.image;
            if (V !== null) ut = V.max.x - V.min.x, mt = V.max.y - V.min.y, vt = V.isBox3 ? V.max.z - V.min.z : 1, Ut = V.min.x, kt = V.min.y, Mt = V.isBox3 ? V.min.z : 0;
            else {
              const Ri = Math.pow(2, -O);
              ut = Math.floor(De.width * Ri), mt = Math.floor(De.height * Ri), C.isDataArrayTexture ? vt = De.depth : C.isData3DTexture ? vt = Math.floor(De.depth * Ri) : vt = 1, Ut = 0, kt = 0, Mt = 0;
            }
            j !== null ? (ae = j.x, he = j.y, Ne = j.z) : (ae = 0, he = 0, Ne = 0);
            const oe = qt.convert(Q.format), Rt = qt.convert(Q.type);
            let $e;
            Q.isData3DTexture ? (D.setTexture3D(Q, 0), $e = L.TEXTURE_3D) : Q.isDataArrayTexture || Q.isCompressedArrayTexture ? (D.setTexture2DArray(Q, 0), $e = L.TEXTURE_2D_ARRAY) : (D.setTexture2D(Q, 0), $e = L.TEXTURE_2D), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, Q.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, Q.unpackAlignment);
            const de = L.getParameter(L.UNPACK_ROW_LENGTH), zi = L.getParameter(L.UNPACK_IMAGE_HEIGHT), Er = L.getParameter(L.UNPACK_SKIP_PIXELS), xi = L.getParameter(L.UNPACK_SKIP_ROWS), ws = L.getParameter(L.UNPACK_SKIP_IMAGES);
            L.pixelStorei(L.UNPACK_ROW_LENGTH, De.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, De.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Ut), L.pixelStorei(L.UNPACK_SKIP_ROWS, kt), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Mt);
            const Ce = C.isDataArrayTexture || C.isData3DTexture, Ti = Q.isDataArrayTexture || Q.isData3DTexture;
            if (C.isDepthTexture) {
              const Ri = Ct.get(C), ui = Ct.get(Q), wi = Ct.get(Ri.__renderTarget), gc = Ct.get(ui.__renderTarget);
              It.bindFramebuffer(L.READ_FRAMEBUFFER, wi.__webglFramebuffer), It.bindFramebuffer(L.DRAW_FRAMEBUFFER, gc.__webglFramebuffer);
              for (let Kn = 0; Kn < vt; Kn++) Ce && (L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ct.get(C).__webglTexture, O, Mt + Kn), L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ct.get(Q).__webglTexture, nt, Ne + Kn)), L.blitFramebuffer(Ut, kt, ut, mt, ae, he, ut, mt, L.DEPTH_BUFFER_BIT, L.NEAREST);
              It.bindFramebuffer(L.READ_FRAMEBUFFER, null), It.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
            } else if (O !== 0 || C.isRenderTargetTexture || Ct.has(C)) {
              const Ri = Ct.get(C), ui = Ct.get(Q);
              It.bindFramebuffer(L.READ_FRAMEBUFFER, vg), It.bindFramebuffer(L.DRAW_FRAMEBUFFER, Eg);
              for (let wi = 0; wi < vt; wi++) Ce ? L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, Ri.__webglTexture, O, Mt + wi) : L.framebufferTexture2D(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, Ri.__webglTexture, O), Ti ? L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, ui.__webglTexture, nt, Ne + wi) : L.framebufferTexture2D(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, ui.__webglTexture, nt), O !== 0 ? L.blitFramebuffer(Ut, kt, ut, mt, ae, he, ut, mt, L.COLOR_BUFFER_BIT, L.NEAREST) : Ti ? L.copyTexSubImage3D($e, nt, ae, he, Ne + wi, Ut, kt, ut, mt) : L.copyTexSubImage2D($e, nt, ae, he, Ut, kt, ut, mt);
              It.bindFramebuffer(L.READ_FRAMEBUFFER, null), It.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
            } else Ti ? C.isDataTexture || C.isData3DTexture ? L.texSubImage3D($e, nt, ae, he, Ne, ut, mt, vt, oe, Rt, De.data) : Q.isCompressedArrayTexture ? L.compressedTexSubImage3D($e, nt, ae, he, Ne, ut, mt, vt, oe, De.data) : L.texSubImage3D($e, nt, ae, he, Ne, ut, mt, vt, oe, Rt, De) : C.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, nt, ae, he, ut, mt, oe, Rt, De.data) : C.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, nt, ae, he, De.width, De.height, oe, De.data) : L.texSubImage2D(L.TEXTURE_2D, nt, ae, he, ut, mt, oe, Rt, De);
            L.pixelStorei(L.UNPACK_ROW_LENGTH, de), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, zi), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Er), L.pixelStorei(L.UNPACK_SKIP_ROWS, xi), L.pixelStorei(L.UNPACK_SKIP_IMAGES, ws), nt === 0 && Q.generateMipmaps && L.generateMipmap($e), It.unbindTexture();
          }, this.copyTextureToTexture3D = function(C, Q, V = null, j = null, O = 0) {
            return yo('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(C, Q, V, j, O);
          }, this.initRenderTarget = function(C) {
            Ct.get(C).__webglFramebuffer === void 0 && D.setupRenderTarget(C);
          }, this.initTexture = function(C) {
            C.isCubeTexture ? D.setTextureCube(C, 0) : C.isData3DTexture ? D.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? D.setTexture2DArray(C, 0) : D.setTexture2D(C, 0), It.unbindTexture();
          }, this.resetState = function() {
            T = 0, R = 0, B = null, It.reset(), ye.reset();
          }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        get coordinateSystem() {
          return vn;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(t) {
          this._outputColorSpace = t;
          const e = this.getContext();
          e.drawingBufferColorSpace = zt._getDrawingBufferColorSpace(t), e.unpackColorSpace = zt._getUnpackColorSpace();
        }
      }
      const ff = "./shaders/", uv = [
        ff + "grass.vert",
        ff + "grass.frag"
      ], fv = [
        "grass"
      ], uh = /* @__PURE__ */ new Map();
      async function pv() {
        const s = await Promise.all(uv.map(Av));
        for (let t = 0; t < s.length; t += 2) {
          const e = Math.floor(t / 2), i = fv[e];
          uh.set(i + "_VS", s[t]), uh.set(i + "_FS", s[t + 1]);
        }
      }
      async function Av(s) {
        return fetch(s).then((t) => t.text());
      }
      class gv {
        constructor() {
          this.maxGrassRadius = 400, this.grassMaskTexture = new hi().load("./textures/grass.jpg"), this.grassDiffTexture = new hi().load("./textures/grass_diffuse.jpg"), this.perlinNoiseTexture = new hi().load("./noise/perlin_noise.png"), this.emptyTexture = new ga(new Uint8Array([
            255,
            255,
            255,
            255
          ]), 1, 1, We), this.emptyTexture.needsUpdate = true;
        }
        shaderMaterial(t) {
          return new Wm({
            uniforms: {
              time: {
                value: 0
              },
              grassMaskTexture: {
                value: this.grassMaskTexture
              },
              grassDiffTexture: {
                value: this.grassDiffTexture
              },
              perlinNoiseTexture: {
                value: this.perlinNoiseTexture
              },
              heightMap: {
                value: null
              },
              terrainHeightScale: {
                value: 1
              },
              terrainSize: {
                value: new rt(1, 1)
              },
              useHeightMap: {
                value: false
              },
              bladeHeightUniform: {
                value: 1
              },
              bladeWidthUniform: {
                value: 1
              },
              vegetationMaskTexture: {
                value: this.emptyTexture
              },
              vegetationMaskSize: {
                value: new rt(1, 1)
              },
              fog: true,
              fogColor: {
                value: new ht(16777215)
              },
              fogDensity: {
                value: 0
              },
              fogTime: {
                value: 0
              },
              grassRadius: {
                value: this.maxGrassRadius
              }
            },
            vertexShader: t.get("grass_VS"),
            fragmentShader: t.get("grass_FS"),
            side: Ki,
            transparent: true
          });
        }
      }
      function nc(s, t = false) {
        const e = s[0].index !== null, i = new Set(Object.keys(s[0].attributes)), n = new Set(Object.keys(s[0].morphAttributes)), r = {}, a = {}, o = s[0].morphTargetsRelative, c = new Fe();
        let l = 0;
        for (let h = 0; h < s.length; ++h) {
          const d = s[h];
          let u = 0;
          if (e !== (d.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
          for (const f in d.attributes) {
            if (!i.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
            r[f] === void 0 && (r[f] = []), r[f].push(d.attributes[f]), u++;
          }
          if (u !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
          if (o !== d.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
          for (const f in d.morphAttributes) {
            if (!n.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
            a[f] === void 0 && (a[f] = []), a[f].push(d.morphAttributes[f]);
          }
          if (t) {
            let f;
            if (e) f = d.index.count;
            else if (d.attributes.position !== void 0) f = d.attributes.position.count;
            else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
            c.addGroup(l, f, h), l += f;
          }
        }
        if (e) {
          let h = 0;
          const d = [];
          for (let u = 0; u < s.length; ++u) {
            const f = s[u].index;
            for (let p = 0; p < f.count; ++p) d.push(f.getX(p) + h);
            h += s[u].attributes.position.count;
          }
          c.setIndex(d);
        }
        for (const h in r) {
          const d = pf(r[h]);
          if (!d) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " attribute."), null;
          c.setAttribute(h, d);
        }
        for (const h in a) {
          const d = a[h][0].length;
          if (d === 0) break;
          c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[h] = [];
          for (let u = 0; u < d; ++u) {
            const f = [];
            for (let m = 0; m < a[h].length; ++m) f.push(a[h][m][u]);
            const p = pf(f);
            if (!p) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " morphAttribute."), null;
            c.morphAttributes[h].push(p);
          }
        }
        return c;
      }
      function pf(s) {
        let t, e, i, n = -1, r = 0;
        for (let l = 0; l < s.length; ++l) {
          const h = s[l];
          if (t === void 0 && (t = h.array.constructor), t !== h.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
          if (e === void 0 && (e = h.itemSize), e !== h.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
          if (i === void 0 && (i = h.normalized), i !== h.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
          if (n === -1 && (n = h.gpuType), n !== h.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
          r += h.count * e;
        }
        const a = new t(r), o = new ri(a, e, i);
        let c = 0;
        for (let l = 0; l < s.length; ++l) {
          const h = s[l];
          if (h.isInterleavedBufferAttribute) {
            const d = c / e;
            for (let u = 0, f = h.count; u < f; u++) for (let p = 0; p < e; p++) {
              const m = h.getComponent(u, p);
              o.setComponent(u + d, p, m);
            }
          } else a.set(h.array, c);
          c += h.count * e;
        }
        return n !== void 0 && (o.gpuType = n), o;
      }
      function Af(s, t) {
        if (t === r_) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
        if (t === nh || t === pp) {
          let e = s.getIndex();
          if (e === null) {
            const a = [], o = s.getAttribute("position");
            if (o !== void 0) {
              for (let c = 0; c < o.count; c++) a.push(c);
              s.setIndex(a), e = s.getIndex();
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
          }
          const i = e.count - 2, n = [];
          if (t === nh) for (let a = 1; a <= i; a++) n.push(e.getX(0)), n.push(e.getX(a)), n.push(e.getX(a + 1));
          else for (let a = 0; a < i; a++) a % 2 === 0 ? (n.push(e.getX(a)), n.push(e.getX(a + 1)), n.push(e.getX(a + 2))) : (n.push(e.getX(a + 2)), n.push(e.getX(a + 1)), n.push(e.getX(a)));
          n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
          const r = s.clone();
          return r.setIndex(n), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), s;
      }
      class _v extends ki {
        constructor(t, e) {
          var _a3;
          super(), this.minX = 0, this.maxX = 0, this.minZ = 0, this.maxZ = 0, this.instances = 2e5, this.w = 1315, this.d = 1300, this.h = 0, this.terrain = t, this.mapScaleFactor = {
            x: 1,
            y: 1,
            z: 1
          }, this.terrainHeightScale = 1, this.bladeHeight = 0.9, this.bladeWidth = 0.4, this.terrainPositions = [], this.positions = [], this.indices = [], this.uvs = [], this.angles = [], this.bladeHeights = [], this.grassMask = null, this.fog = (_a3 = t == null ? void 0 : t.parent) == null ? void 0 : _a3.fog, this.geo, this.particles, this.dirLight = e;
        }
        createParticles() {
          this.positions.push(4, -4, 0), this.positions.push(-4, -4, 0), this.positions.push(-4, 4, 0), this.positions.push(4, 4, 0), this.indices.push(0, 1, 2, 2, 3, 0), this.uvs.push(1, 0, 0, 0, 0, 1, 1, 1);
          for (let i = 0; i < this.instances; i++) {
            let n = Math.random() * this.w - this.w / 2, r = this.h, a = Math.random() * this.d - this.d / 2, o = Math.random() * 360, c = ke.randFloat(0.7, 1.3);
            this.terrainPositions.push(n, r, a), this.angles.push(o), this.bladeHeights.push(c);
          }
          this.geo = new cw(), this.geo.instanceCount = this.instances, this.geo.setAttribute("position", new le(this.positions, 3)), this.geo.setAttribute("uv", new le(this.uvs, 2)), this.geo.setIndex(new ri(new Uint16Array(this.indices), 1)), this.geo.setAttribute("terPos", new fr(new Float32Array(this.terrainPositions), 3)), this.geo.setAttribute("angle", new fr(new Float32Array(this.angles), 1)), this.geo.setAttribute("bladeHeight", new fr(new Float32Array(this.bladeHeights), 1)), this.geo.setAttribute("worldPos", new fr(new Float32Array(this.terrainPositions), 3));
          const e = new gv(this.dirLight).shaderMaterial(uh);
          this._setVegetationAreas(e), this.heightsFromTerrain(e), this.grassParticles = new me(this.geo, e), this.grassParticles.castShadow = true, this.grassParticles.receiveShadow = true, this.grassParticles.frustumCulled = false, this.add(this.grassParticles);
        }
        async heightsFromTerrain(t) {
          const e = await this._createHeightTexture();
          if (!e) {
            console.error("\u274C Failed to generate height texture from terrain."), t.uniforms.useHeightMap.value = false;
            return;
          }
          e.minFilter = Re, e.magFilter = Re, e.wrapS = _i, e.wrapT = _i, e.needsUpdate = true, t.uniforms.heightMap.value = e, t.uniforms.terrainHeightScale.value = this.terrainHeightScale, t.uniforms.terrainSize.value = new rt(this.w, this.d), t.uniforms.useHeightMap.value = true, t.uniforms.minX = {
            value: this.minX
          }, t.uniforms.minZ = {
            value: this.minZ
          }, t.uniforms.bladeHeightUniform = {
            value: this.bladeHeight
          }, t.uniforms.bladeWidthUniform = {
            value: this.bladeWidth
          }, this.fog && (t.uniforms.fogColor = {
            value: this.fog.color
          }, t.uniforms.fogDensity = {
            value: this.fog.density
          });
        }
        _setVegetationAreas(t) {
          this.grassMask = new hi().load("./map/vegetation_map.jpeg"), this.grassMask.wrapS = this.grassMask.wrapT = _i, this.grassMask.minFilter = Re, this.grassMask.magFilter = Re, t.uniforms.vegetationMaskTexture.value = this.grassMask, t.uniforms.vegetationMaskSize.value = new rt(this.w * 1, this.d * 1);
        }
        getTerrainMesh() {
          if (!this.terrain) throw new Error("No mesh found");
          if (this.terrainMesh = this.terrain.getObjectByName("Plane"), !this.terrainMesh) throw new Error("\u274C Terrain 'Plane' not found!");
          let t = [];
          if (this.terrainMesh.type === "Mesh" ? t.push(this.terrainMesh) : t = this.terrainMesh.children.filter((r) => r.isMesh), t.length === 0) throw new Error("\u274C No meshes found inside 'Plane'!");
          const e = t.map((r) => {
            const a = r.geometry.clone().applyMatrix4(r.matrixWorld);
            return a.scale(this.mapScaleFactor.x, this.mapScaleFactor.y, this.mapScaleFactor.z), a;
          }), i = nc(e, false);
          if (!i) throw new Error("\u274C Terrain mesh not found!");
          return new me(i, new ci({
            color: 65280
          }));
        }
        async _extractHeightData() {
          let i;
          try {
            i = this.getTerrainMesh();
          } catch (g) {
            return console.error(g.message), null;
          }
          const r = i.geometry.attributes.position.array, a = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
          for (let g = 0; g < r.length; g += 3) a.add(r[g]), o.add(r[g + 2]);
          const c = 100, l = 100, h = Math.min(...a), d = Math.max(...a), u = Math.min(...o), f = Math.max(...o), p = new Float32Array(c * l), m = new Float32Array(c * l).fill(0);
          for (let g = 0; g < r.length; g += 3) {
            const A = r[g], x = r[g + 2], b = r[g + 1] / 1 + 4, y = (A - h) / (d - h) || 1, M = (x - u) / (f - u) || 1, T = Math.floor(y * (c - 1)), B = Math.floor(M * (l - 1)) * c + T;
            p[B] += b, m[B] += 1;
          }
          for (let g = 0; g < p.length; g++) m[g] > 0 && (p[g] /= m[g]);
          return {
            heightData: p,
            sizeX: c,
            sizeZ: l,
            minX: h,
            minZ: u
          };
        }
        async _createHeightTexture() {
          const t = await this._extractHeightData();
          if (!t) return console.error("Failed to extract height data!"), null;
          const { heightData: e, sizeX: i, sizeZ: n, minX: r, minZ: a } = t;
          this.minX = r, this.minZ = a;
          const o = new ga(e, i, n, xn, ii);
          return o.needsUpdate = true, o;
        }
        update(t) {
          this.grassParticles.material.uniforms.time.value = t;
        }
      }
      const mv = "/resume_3d/assets/rapier_wasm3d_bg-CcbIg-ps.wasm", wv = async (s = {}, t) => {
        let e;
        if (t.startsWith("data:")) {
          const i = t.replace(/^data:.*?base64,/, "");
          let n;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const r = atob(i);
            n = new Uint8Array(r.length);
            for (let a = 0; a < r.length; a++) n[a] = r.charCodeAt(a);
          } else throw new Error("Cannot decode base64-encoded data URL");
          e = await WebAssembly.instantiate(n, s);
        } else {
          const i = await fetch(t), n = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(i, s);
          else {
            const r = await i.arrayBuffer();
            e = await WebAssembly.instantiate(r, s);
          }
        }
        return e.instance.exports;
      };
      let _;
      function bv(s) {
        _ = s;
      }
      const ie = new Array(128).fill(void 0);
      ie.push(void 0, null, true, false);
      function fe(s) {
        return ie[s];
      }
      let Vs = ie.length;
      function ze(s) {
        Vs === ie.length && ie.push(ie.length + 1);
        const t = Vs;
        return Vs = ie[t], ie[t] = s, t;
      }
      function ad(s, t) {
        try {
          return s.apply(this, t);
        } catch (e) {
          _.__wbindgen_export_0(ze(e));
        }
      }
      function Dt(s) {
        return s == null;
      }
      let Vr = null;
      function Ke() {
        return (Vr === null || Vr.buffer.detached === true || Vr.buffer.detached === void 0 && Vr.buffer !== _.memory.buffer) && (Vr = new DataView(_.memory.buffer)), Vr;
      }
      function yv(s) {
        s < 132 || (ie[s] = Vs, Vs = s);
      }
      function aa(s) {
        const t = fe(s);
        return yv(s), t;
      }
      const xv = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let iA = new xv("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      iA.decode();
      let lo = null;
      function vv() {
        return (lo === null || lo.byteLength === 0) && (lo = new Uint8Array(_.memory.buffer)), lo;
      }
      function nA(s, t) {
        return s = s >>> 0, iA.decode(vv().subarray(s, s + t));
      }
      function Ev() {
        let s, t;
        try {
          const n = _.__wbindgen_add_to_stack_pointer(-16);
          _.version(n);
          var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getInt32(n + 4 * 1, true);
          return s = e, t = i, nA(e, i);
        } finally {
          _.__wbindgen_add_to_stack_pointer(16), _.__wbindgen_export_1(s, t, 1);
        }
      }
      function F(s, t) {
        if (!(s instanceof t)) throw new Error(`expected instance of ${t.name}`);
      }
      let we = 128;
      function Ie(s) {
        if (we == 1) throw new Error("out of js stack");
        return ie[--we] = s, we;
      }
      let ho = null;
      function rA() {
        return (ho === null || ho.byteLength === 0) && (ho = new Float32Array(_.memory.buffer)), ho;
      }
      function gf(s, t) {
        return s = s >>> 0, rA().subarray(s / 4, s / 4 + t);
      }
      let uo = null;
      function sA() {
        return (uo === null || uo.byteLength === 0) && (uo = new Uint32Array(_.memory.buffer)), uo;
      }
      function Sv(s, t) {
        return s = s >>> 0, sA().subarray(s / 4, s / 4 + t);
      }
      let Si = 0;
      function or(s, t) {
        const e = t(s.length * 4, 4) >>> 0;
        return rA().set(s, e / 4), Si = s.length, e;
      }
      function fo(s, t) {
        const e = t(s.length * 4, 4) >>> 0;
        return sA().set(s, e / 4), Si = s.length, e;
      }
      const rc = Object.freeze({
        LinX: 0,
        0: "LinX",
        LinY: 1,
        1: "LinY",
        LinZ: 2,
        2: "LinZ",
        AngX: 3,
        3: "AngX",
        AngY: 4,
        4: "AngY",
        AngZ: 5,
        5: "AngZ"
      }), Xi = Object.freeze({
        Revolute: 0,
        0: "Revolute",
        Fixed: 1,
        1: "Fixed",
        Prismatic: 2,
        2: "Prismatic",
        Rope: 3,
        3: "Rope",
        Spring: 4,
        4: "Spring",
        Spherical: 5,
        5: "Spherical",
        Generic: 6,
        6: "Generic"
      }), ti = Object.freeze({
        Ball: 0,
        0: "Ball",
        Cuboid: 1,
        1: "Cuboid",
        Capsule: 2,
        2: "Capsule",
        Segment: 3,
        3: "Segment",
        Polyline: 4,
        4: "Polyline",
        Triangle: 5,
        5: "Triangle",
        TriMesh: 6,
        6: "TriMesh",
        HeightField: 7,
        7: "HeightField",
        Compound: 8,
        8: "Compound",
        ConvexPolyhedron: 9,
        9: "ConvexPolyhedron",
        Cylinder: 10,
        10: "Cylinder",
        Cone: 11,
        11: "Cone",
        RoundCuboid: 12,
        12: "RoundCuboid",
        RoundTriangle: 13,
        13: "RoundTriangle",
        RoundCylinder: 14,
        14: "RoundCylinder",
        RoundCone: 15,
        15: "RoundCone",
        RoundConvexPolyhedron: 16,
        16: "RoundConvexPolyhedron",
        HalfSpace: 17,
        17: "HalfSpace"
      }), il = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawbroadphase_free(s >>> 0, 1));
      class yr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(yr.prototype);
          return e.__wbg_ptr = t, il.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, il.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawbroadphase_free(t, 0);
        }
        constructor() {
          const t = _.rawbroadphase_new();
          return this.__wbg_ptr = t >>> 0, il.register(this, this.__wbg_ptr, this), this;
        }
      }
      const _f = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawccdsolver_free(s >>> 0, 1));
      class fh {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, _f.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawccdsolver_free(t, 0);
        }
        constructor() {
          const t = _.rawccdsolver_new();
          return this.__wbg_ptr = t >>> 0, _f.register(this, this.__wbg_ptr, this), this;
        }
      }
      const mf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcharactercollision_free(s >>> 0, 1));
      class aA {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, mf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcharactercollision_free(t, 0);
        }
        constructor() {
          const t = _.rawcharactercollision_new();
          return this.__wbg_ptr = t >>> 0, mf.register(this, this.__wbg_ptr, this), this;
        }
        handle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        translationDeltaApplied() {
          const t = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return N.__wrap(t);
        }
        translationDeltaRemaining() {
          const t = _.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
          return N.__wrap(t);
        }
        toi() {
          return _.rawcharactercollision_toi(this.__wbg_ptr);
        }
        worldWitness1() {
          const t = _.rawcharactercollision_worldWitness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        worldWitness2() {
          const t = _.rawcharactercollision_worldWitness2(this.__wbg_ptr);
          return N.__wrap(t);
        }
        worldNormal1() {
          const t = _.rawcharactercollision_worldNormal1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        worldNormal2() {
          const t = _.rawcharactercollision_worldNormal2(this.__wbg_ptr);
          return N.__wrap(t);
        }
      }
      const nl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcolliderset_free(s >>> 0, 1));
      class Me {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Me.prototype);
          return e.__wbg_ptr = t, nl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, nl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcolliderset_free(t, 0);
        }
        coTranslation(t) {
          const e = _.rawcolliderset_coTranslation(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        coRotation(t) {
          const e = _.rawcolliderset_coRotation(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        coSetTranslation(t, e, i, n) {
          _.rawcolliderset_coSetTranslation(this.__wbg_ptr, t, e, i, n);
        }
        coSetTranslationWrtParent(t, e, i, n) {
          _.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, t, e, i, n);
        }
        coSetRotation(t, e, i, n, r) {
          _.rawcolliderset_coSetRotation(this.__wbg_ptr, t, e, i, n, r);
        }
        coSetRotationWrtParent(t, e, i, n, r) {
          _.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, t, e, i, n, r);
        }
        coIsSensor(t) {
          return _.rawcolliderset_coIsSensor(this.__wbg_ptr, t) !== 0;
        }
        coShapeType(t) {
          return _.rawcolliderset_coShapeType(this.__wbg_ptr, t);
        }
        coHalfspaceNormal(t) {
          const e = _.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        coHalfExtents(t) {
          const e = _.rawcolliderset_coHalfExtents(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        coSetHalfExtents(t, e) {
          F(e, N), _.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        coRadius(t) {
          const e = _.rawcolliderset_coRadius(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coSetRadius(t, e) {
          _.rawcolliderset_coSetRadius(this.__wbg_ptr, t, e);
        }
        coHalfHeight(t) {
          const e = _.rawcolliderset_coHalfHeight(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coSetHalfHeight(t, e) {
          _.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, t, e);
        }
        coRoundRadius(t) {
          const e = _.rawcolliderset_coRoundRadius(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coSetRoundRadius(t, e) {
          _.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, t, e);
        }
        coVertices(t) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coVertices(n, this.__wbg_ptr, t);
            var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getInt32(n + 4 * 1, true);
            let r;
            return e !== 0 && (r = gf(e, i).slice(), _.__wbindgen_export_1(e, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coIndices(t) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coIndices(n, this.__wbg_ptr, t);
            var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getInt32(n + 4 * 1, true);
            let r;
            return e !== 0 && (r = Sv(e, i).slice(), _.__wbindgen_export_1(e, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coTriMeshFlags(t) {
          const e = _.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coHeightFieldFlags(t) {
          const e = _.rawcolliderset_coHeightFieldFlags(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coHeightfieldHeights(t) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coHeightfieldHeights(n, this.__wbg_ptr, t);
            var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getInt32(n + 4 * 1, true);
            let r;
            return e !== 0 && (r = gf(e, i).slice(), _.__wbindgen_export_1(e, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coHeightfieldScale(t) {
          const e = _.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        coHeightfieldNRows(t) {
          const e = _.rawcolliderset_coHeightfieldNRows(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coHeightfieldNCols(t) {
          const e = _.rawcolliderset_coHeightfieldNCols(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        coParent(t) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coParent(n, this.__wbg_ptr, t);
            var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getFloat64(n + 8 * 1, true);
            return e === 0 ? void 0 : i;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coSetEnabled(t, e) {
          _.rawcolliderset_coSetEnabled(this.__wbg_ptr, t, e);
        }
        coIsEnabled(t) {
          return _.rawcolliderset_coIsEnabled(this.__wbg_ptr, t) !== 0;
        }
        coSetContactSkin(t, e) {
          _.rawcolliderset_coSetContactSkin(this.__wbg_ptr, t, e);
        }
        coContactSkin(t) {
          return _.rawcolliderset_coContactSkin(this.__wbg_ptr, t);
        }
        coFriction(t) {
          return _.rawcolliderset_coFriction(this.__wbg_ptr, t);
        }
        coRestitution(t) {
          return _.rawcolliderset_coRestitution(this.__wbg_ptr, t);
        }
        coDensity(t) {
          return _.rawcolliderset_coDensity(this.__wbg_ptr, t);
        }
        coMass(t) {
          return _.rawcolliderset_coMass(this.__wbg_ptr, t);
        }
        coVolume(t) {
          return _.rawcolliderset_coVolume(this.__wbg_ptr, t);
        }
        coCollisionGroups(t) {
          return _.rawcolliderset_coCollisionGroups(this.__wbg_ptr, t) >>> 0;
        }
        coSolverGroups(t) {
          return _.rawcolliderset_coSolverGroups(this.__wbg_ptr, t) >>> 0;
        }
        coActiveHooks(t) {
          return _.rawcolliderset_coActiveHooks(this.__wbg_ptr, t) >>> 0;
        }
        coActiveCollisionTypes(t) {
          return _.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, t);
        }
        coActiveEvents(t) {
          return _.rawcolliderset_coActiveEvents(this.__wbg_ptr, t) >>> 0;
        }
        coContactForceEventThreshold(t) {
          return _.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, t);
        }
        coContainsPoint(t, e) {
          return F(e, N), _.rawcolliderset_coContainsPoint(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
        }
        coCastShape(t, e, i, n, r, a, o, c, l) {
          F(e, N), F(i, Bt), F(n, N), F(r, Yt), F(a, N);
          const h = _.rawcolliderset_coCastShape(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o, c, l);
          return h === 0 ? void 0 : lc.__wrap(h);
        }
        coCastCollider(t, e, i, n, r, a, o) {
          F(e, N), F(n, N);
          const c = _.rawcolliderset_coCastCollider(this.__wbg_ptr, t, e.__wbg_ptr, i, n.__wbg_ptr, r, a, o);
          return c === 0 ? void 0 : sc.__wrap(c);
        }
        coIntersectsShape(t, e, i, n) {
          return F(e, Bt), F(i, N), F(n, Yt), _.rawcolliderset_coIntersectsShape(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr) !== 0;
        }
        coContactShape(t, e, i, n, r) {
          F(e, Bt), F(i, N), F(n, Yt);
          const a = _.rawcolliderset_coContactShape(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r);
          return a === 0 ? void 0 : oa.__wrap(a);
        }
        coContactCollider(t, e, i) {
          const n = _.rawcolliderset_coContactCollider(this.__wbg_ptr, t, e, i);
          return n === 0 ? void 0 : oa.__wrap(n);
        }
        coProjectPoint(t, e, i) {
          F(e, N);
          const n = _.rawcolliderset_coProjectPoint(this.__wbg_ptr, t, e.__wbg_ptr, i);
          return ac.__wrap(n);
        }
        coIntersectsRay(t, e, i, n) {
          return F(e, N), F(i, N), _.rawcolliderset_coIntersectsRay(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n) !== 0;
        }
        coCastRay(t, e, i, n, r) {
          return F(e, N), F(i, N), _.rawcolliderset_coCastRay(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n, r);
        }
        coCastRayAndGetNormal(t, e, i, n, r) {
          F(e, N), F(i, N);
          const a = _.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n, r);
          return a === 0 ? void 0 : cc.__wrap(a);
        }
        coSetSensor(t, e) {
          _.rawcolliderset_coSetSensor(this.__wbg_ptr, t, e);
        }
        coSetRestitution(t, e) {
          _.rawcolliderset_coSetRestitution(this.__wbg_ptr, t, e);
        }
        coSetFriction(t, e) {
          _.rawcolliderset_coSetFriction(this.__wbg_ptr, t, e);
        }
        coFrictionCombineRule(t) {
          return _.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, t) >>> 0;
        }
        coSetFrictionCombineRule(t, e) {
          _.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, t, e);
        }
        coRestitutionCombineRule(t) {
          return _.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, t) >>> 0;
        }
        coSetRestitutionCombineRule(t, e) {
          _.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, t, e);
        }
        coSetCollisionGroups(t, e) {
          _.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, t, e);
        }
        coSetSolverGroups(t, e) {
          _.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, t, e);
        }
        coSetActiveHooks(t, e) {
          _.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, t, e);
        }
        coSetActiveEvents(t, e) {
          _.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, t, e);
        }
        coSetActiveCollisionTypes(t, e) {
          _.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, t, e);
        }
        coSetShape(t, e) {
          F(e, Bt), _.rawcolliderset_coSetShape(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        coSetContactForceEventThreshold(t, e) {
          _.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, t, e);
        }
        coSetDensity(t, e) {
          _.rawcolliderset_coSetDensity(this.__wbg_ptr, t, e);
        }
        coSetMass(t, e) {
          _.rawcolliderset_coSetMass(this.__wbg_ptr, t, e);
        }
        coSetMassProperties(t, e, i, n, r) {
          F(i, N), F(n, N), F(r, Yt), _.rawcolliderset_coSetMassProperties(this.__wbg_ptr, t, e, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
        constructor() {
          const t = _.rawcolliderset_new();
          return this.__wbg_ptr = t >>> 0, nl.register(this, this.__wbg_ptr, this), this;
        }
        len() {
          return _.rawcolliderset_len(this.__wbg_ptr) >>> 0;
        }
        contains(t) {
          return _.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
        }
        createCollider(t, e, i, n, r, a, o, c, l, h, d, u, f, p, m, g, A, x, b, y, M, T, R, B, S) {
          try {
            const G = _.__wbindgen_add_to_stack_pointer(-16);
            F(e, Bt), F(i, N), F(n, Yt), F(o, N), F(c, N), F(l, Yt), F(S, ve), _.rawcolliderset_createCollider(G, this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h, d, u, f, p, m, g, A, x, b, y, M, T, R, B, S.__wbg_ptr);
            var E = Ke().getInt32(G + 4 * 0, true), P = Ke().getFloat64(G + 8 * 1, true);
            return E === 0 ? void 0 : P;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        remove(t, e, i, n) {
          F(e, Tn), F(i, ve), _.rawcolliderset_remove(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n);
        }
        isHandleValid(t) {
          return _.rawcolliderset_contains(this.__wbg_ptr, t) !== 0;
        }
        forEachColliderHandle(t) {
          try {
            _.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
      }
      const wf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcollidershapecasthit_free(s >>> 0, 1));
      class sc {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(sc.prototype);
          return e.__wbg_ptr = t, wf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, wf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcollidershapecasthit_free(t, 0);
        }
        colliderHandle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        witness1() {
          const t = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        witness2() {
          const t = _.rawcollidershapecasthit_witness2(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal1() {
          const t = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal2() {
          const t = _.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
          return N.__wrap(t);
        }
      }
      const bf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactforceevent_free(s >>> 0, 1));
      class od {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(od.prototype);
          return e.__wbg_ptr = t, bf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, bf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcontactforceevent_free(t, 0);
        }
        collider1() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        collider2() {
          return _.rawcontactforceevent_collider2(this.__wbg_ptr);
        }
        total_force() {
          const t = _.rawcontactforceevent_total_force(this.__wbg_ptr);
          return N.__wrap(t);
        }
        total_force_magnitude() {
          return _.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
        }
        max_force_direction() {
          const t = _.rawcontactforceevent_max_force_direction(this.__wbg_ptr);
          return N.__wrap(t);
        }
        max_force_magnitude() {
          return _.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
        }
      }
      const yf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactmanifold_free(s >>> 0, 1));
      class cd {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(cd.prototype);
          return e.__wbg_ptr = t, yf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, yf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcontactmanifold_free(t, 0);
        }
        normal() {
          const t = _.rawcontactmanifold_normal(this.__wbg_ptr);
          return N.__wrap(t);
        }
        local_n1() {
          const t = _.rawcontactmanifold_local_n1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        local_n2() {
          const t = _.rawcontactmanifold_local_n2(this.__wbg_ptr);
          return N.__wrap(t);
        }
        subshape1() {
          return _.rawcontactmanifold_subshape1(this.__wbg_ptr) >>> 0;
        }
        subshape2() {
          return _.rawcontactmanifold_subshape2(this.__wbg_ptr) >>> 0;
        }
        num_contacts() {
          return _.rawcontactmanifold_num_contacts(this.__wbg_ptr) >>> 0;
        }
        contact_local_p1(t) {
          const e = _.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        contact_local_p2(t) {
          const e = _.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        contact_dist(t) {
          return _.rawcontactmanifold_contact_dist(this.__wbg_ptr, t);
        }
        contact_fid1(t) {
          return _.rawcontactmanifold_contact_fid1(this.__wbg_ptr, t) >>> 0;
        }
        contact_fid2(t) {
          return _.rawcontactmanifold_contact_fid2(this.__wbg_ptr, t) >>> 0;
        }
        contact_impulse(t) {
          return _.rawcontactmanifold_contact_impulse(this.__wbg_ptr, t);
        }
        contact_tangent_impulse_x(t) {
          return _.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, t);
        }
        contact_tangent_impulse_y(t) {
          return _.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, t);
        }
        num_solver_contacts() {
          return _.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr) >>> 0;
        }
        solver_contact_point(t) {
          const e = _.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        solver_contact_dist(t) {
          return _.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, t);
        }
        solver_contact_friction(t) {
          return _.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, t);
        }
        solver_contact_restitution(t) {
          return _.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, t);
        }
        solver_contact_tangent_velocity(t) {
          const e = _.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
      }
      const xf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactpair_free(s >>> 0, 1));
      class ld {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ld.prototype);
          return e.__wbg_ptr = t, xf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, xf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawcontactpair_free(t, 0);
        }
        collider1() {
          return _.rawcontactpair_collider1(this.__wbg_ptr);
        }
        collider2() {
          return _.rawcontactpair_collider2(this.__wbg_ptr);
        }
        numContactManifolds() {
          return _.rawcontactpair_numContactManifolds(this.__wbg_ptr) >>> 0;
        }
        contactManifold(t) {
          const e = _.rawcontactpair_contactManifold(this.__wbg_ptr, t);
          return e === 0 ? void 0 : cd.__wrap(e);
        }
      }
      const vf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdebugrenderpipeline_free(s >>> 0, 1));
      class Cv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, vf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawdebugrenderpipeline_free(t, 0);
        }
        constructor() {
          const t = _.rawdebugrenderpipeline_new();
          return this.__wbg_ptr = t >>> 0, vf.register(this, this.__wbg_ptr, this), this;
        }
        vertices() {
          const t = _.rawdebugrenderpipeline_vertices(this.__wbg_ptr);
          return aa(t);
        }
        colors() {
          const t = _.rawdebugrenderpipeline_colors(this.__wbg_ptr);
          return aa(t);
        }
        render(t, e, i, n, r) {
          F(t, ve), F(e, Me), F(i, Mn), F(n, Rn), F(r, jn), _.rawdebugrenderpipeline_render(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
      }
      const Ef = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdeserializedworld_free(s >>> 0, 1));
      class hd {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(hd.prototype);
          return e.__wbg_ptr = t, Ef.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ef.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawdeserializedworld_free(t, 0);
        }
        takeGravity() {
          const t = _.rawdeserializedworld_takeGravity(this.__wbg_ptr);
          return t === 0 ? void 0 : N.__wrap(t);
        }
        takeIntegrationParameters() {
          const t = _.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);
          return t === 0 ? void 0 : xr.__wrap(t);
        }
        takeIslandManager() {
          const t = _.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);
          return t === 0 ? void 0 : Tn.__wrap(t);
        }
        takeBroadPhase() {
          const t = _.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);
          return t === 0 ? void 0 : yr.__wrap(t);
        }
        takeNarrowPhase() {
          const t = _.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);
          return t === 0 ? void 0 : jn.__wrap(t);
        }
        takeBodies() {
          const t = _.rawdeserializedworld_takeBodies(this.__wbg_ptr);
          return t === 0 ? void 0 : ve.__wrap(t);
        }
        takeColliders() {
          const t = _.rawdeserializedworld_takeColliders(this.__wbg_ptr);
          return t === 0 ? void 0 : Me.__wrap(t);
        }
        takeImpulseJoints() {
          const t = _.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);
          return t === 0 ? void 0 : Mn.__wrap(t);
        }
        takeMultibodyJoints() {
          const t = _.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);
          return t === 0 ? void 0 : Rn.__wrap(t);
        }
      }
      const Sf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdynamicraycastvehiclecontroller_free(s >>> 0, 1));
      class Iv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Sf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawdynamicraycastvehiclecontroller_free(t, 0);
        }
        constructor(t) {
          const e = _.rawdynamicraycastvehiclecontroller_new(t);
          return this.__wbg_ptr = e >>> 0, Sf.register(this, this.__wbg_ptr, this), this;
        }
        current_vehicle_speed() {
          return _.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);
        }
        chassis() {
          return _.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);
        }
        index_up_axis() {
          return _.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr) >>> 0;
        }
        set_index_up_axis(t) {
          _.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, t);
        }
        index_forward_axis() {
          return _.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr) >>> 0;
        }
        set_index_forward_axis(t) {
          _.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, t);
        }
        add_wheel(t, e, i, n, r) {
          F(t, N), F(e, N), F(i, N), _.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n, r);
        }
        num_wheels() {
          return _.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr) >>> 0;
        }
        update_vehicle(t, e, i, n, r, a, o) {
          try {
            F(e, ve), F(i, Me), F(n, dd), _.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, Dt(a) ? 4294967297 : a >>> 0, Ie(o));
          } finally {
            ie[we++] = void 0;
          }
        }
        wheel_chassis_connection_point_cs(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        set_wheel_chassis_connection_point_cs(t, e) {
          F(e, N), _.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        wheel_suspension_rest_length(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_suspension_rest_length(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, t, e);
        }
        wheel_max_suspension_travel(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_max_suspension_travel(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, t, e);
        }
        wheel_radius(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_radius(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_radius(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, t, e);
        }
        wheel_suspension_stiffness(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_suspension_stiffness(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, t, e);
        }
        wheel_suspension_compression(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_suspension_compression(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, t, e);
        }
        wheel_suspension_relaxation(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_suspension_relaxation(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, t, e);
        }
        wheel_max_suspension_force(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_max_suspension_force(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, t, e);
        }
        wheel_brake(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_brake(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_brake(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, t, e);
        }
        wheel_steering(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_steering(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_steering(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, t, e);
        }
        wheel_engine_force(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_engine_force(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_engine_force(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, t, e);
        }
        wheel_direction_cs(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        set_wheel_direction_cs(t, e) {
          F(e, N), _.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        wheel_axle_cs(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        set_wheel_axle_cs(t, e) {
          F(e, N), _.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        wheel_friction_slip(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_friction_slip(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_friction_slip(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, t, e);
        }
        wheel_side_friction_stiffness(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        set_wheel_side_friction_stiffness(t, e) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, t, e);
        }
        wheel_rotation(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_rotation(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        wheel_forward_impulse(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        wheel_side_impulse(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_side_impulse(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        wheel_suspension_force(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_force(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        wheel_contact_normal_ws(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        wheel_contact_point_ws(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        wheel_suspension_length(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_suspension_length(this.__wbg_ptr, t);
          return e === 4294967297 ? void 0 : e;
        }
        wheel_hard_point_ws(t) {
          const e = _.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, t);
          return e === 0 ? void 0 : N.__wrap(e);
        }
        wheel_is_in_contact(t) {
          return _.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, t) !== 0;
        }
        wheel_ground_object(t) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawdynamicraycastvehiclecontroller_wheel_ground_object(n, this.__wbg_ptr, t);
            var e = Ke().getInt32(n + 4 * 0, true), i = Ke().getFloat64(n + 8 * 1, true);
            return e === 0 ? void 0 : i;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const Cf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_raweventqueue_free(s >>> 0, 1));
      class oA {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Cf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_raweventqueue_free(t, 0);
        }
        constructor(t) {
          const e = _.raweventqueue_new(t);
          return this.__wbg_ptr = e >>> 0, Cf.register(this, this.__wbg_ptr, this), this;
        }
        drainCollisionEvents(t) {
          try {
            _.raweventqueue_drainCollisionEvents(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
        drainContactForceEvents(t) {
          try {
            _.raweventqueue_drainContactForceEvents(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
        clear() {
          _.raweventqueue_clear(this.__wbg_ptr);
        }
      }
      const If = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawgenericjoint_free(s >>> 0, 1));
      class Ze {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Ze.prototype);
          return e.__wbg_ptr = t, If.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, If.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawgenericjoint_free(t, 0);
        }
        static generic(t, e, i, n) {
          F(t, N), F(e, N), F(i, N);
          const r = _.rawgenericjoint_generic(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n);
          return r === 0 ? void 0 : Ze.__wrap(r);
        }
        static spring(t, e, i, n, r) {
          F(n, N), F(r, N);
          const a = _.rawgenericjoint_spring(t, e, i, n.__wbg_ptr, r.__wbg_ptr);
          return Ze.__wrap(a);
        }
        static rope(t, e, i) {
          F(e, N), F(i, N);
          const n = _.rawgenericjoint_rope(t, e.__wbg_ptr, i.__wbg_ptr);
          return Ze.__wrap(n);
        }
        static spherical(t, e) {
          F(t, N), F(e, N);
          const i = _.rawgenericjoint_spherical(t.__wbg_ptr, e.__wbg_ptr);
          return Ze.__wrap(i);
        }
        static prismatic(t, e, i, n, r, a) {
          F(t, N), F(e, N), F(i, N);
          const o = _.rawgenericjoint_prismatic(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n, r, a);
          return o === 0 ? void 0 : Ze.__wrap(o);
        }
        static fixed(t, e, i, n) {
          F(t, N), F(e, Yt), F(i, N), F(n, Yt);
          const r = _.rawgenericjoint_fixed(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr);
          return Ze.__wrap(r);
        }
        static revolute(t, e, i) {
          F(t, N), F(e, N), F(i, N);
          const n = _.rawgenericjoint_revolute(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr);
          return n === 0 ? void 0 : Ze.__wrap(n);
        }
      }
      const rl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawimpulsejointset_free(s >>> 0, 1));
      class Mn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Mn.prototype);
          return e.__wbg_ptr = t, rl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, rl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawimpulsejointset_free(t, 0);
        }
        jointType(t) {
          return _.rawimpulsejointset_jointType(this.__wbg_ptr, t);
        }
        jointBodyHandle1(t) {
          return _.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, t);
        }
        jointBodyHandle2(t) {
          return _.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, t);
        }
        jointFrameX1(t) {
          const e = _.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        jointFrameX2(t) {
          const e = _.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        jointAnchor1(t) {
          const e = _.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        jointAnchor2(t) {
          const e = _.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        jointSetAnchor1(t, e) {
          F(e, N), _.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        jointSetAnchor2(t, e) {
          F(e, N), _.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        jointContactsEnabled(t) {
          return _.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
        }
        jointSetContactsEnabled(t, e) {
          _.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
        }
        jointLimitsEnabled(t, e) {
          return _.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
        }
        jointLimitsMin(t, e) {
          return _.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, t, e);
        }
        jointLimitsMax(t, e) {
          return _.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, t, e);
        }
        jointSetLimits(t, e, i, n) {
          _.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, t, e, i, n);
        }
        jointConfigureMotorModel(t, e, i) {
          _.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, t, e, i);
        }
        jointConfigureMotorVelocity(t, e, i, n) {
          _.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, t, e, i, n);
        }
        jointConfigureMotorPosition(t, e, i, n, r) {
          _.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, t, e, i, n, r);
        }
        jointConfigureMotor(t, e, i, n, r, a) {
          _.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, t, e, i, n, r, a);
        }
        constructor() {
          const t = _.rawimpulsejointset_new();
          return this.__wbg_ptr = t >>> 0, rl.register(this, this.__wbg_ptr, this), this;
        }
        createJoint(t, e, i, n) {
          return F(t, Ze), _.rawimpulsejointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, i, n);
        }
        remove(t, e) {
          _.rawimpulsejointset_remove(this.__wbg_ptr, t, e);
        }
        len() {
          return _.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
        }
        contains(t) {
          return _.rawimpulsejointset_contains(this.__wbg_ptr, t) !== 0;
        }
        forEachJointHandle(t) {
          try {
            _.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
        forEachJointAttachedToRigidBody(t, e) {
          try {
            _.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Ie(e));
          } finally {
            ie[we++] = void 0;
          }
        }
      }
      const sl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawintegrationparameters_free(s >>> 0, 1));
      class xr {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(xr.prototype);
          return e.__wbg_ptr = t, sl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, sl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawintegrationparameters_free(t, 0);
        }
        constructor() {
          const t = _.rawintegrationparameters_new();
          return this.__wbg_ptr = t >>> 0, sl.register(this, this.__wbg_ptr, this), this;
        }
        get dt() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        get contact_erp() {
          return _.rawintegrationparameters_contact_erp(this.__wbg_ptr);
        }
        get normalizedAllowedLinearError() {
          return _.rawintegrationparameters_normalizedAllowedLinearError(this.__wbg_ptr);
        }
        get normalizedPredictionDistance() {
          return _.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
        }
        get numSolverIterations() {
          return _.rawintegrationparameters_numSolverIterations(this.__wbg_ptr) >>> 0;
        }
        get numAdditionalFrictionIterations() {
          return _.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr) >>> 0;
        }
        get numInternalPgsIterations() {
          return _.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr) >>> 0;
        }
        get minIslandSize() {
          return _.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
        }
        get maxCcdSubsteps() {
          return _.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr) >>> 0;
        }
        get lengthUnit() {
          return _.rawintegrationparameters_lengthUnit(this.__wbg_ptr);
        }
        set dt(t) {
          _.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
        }
        set contact_natural_frequency(t) {
          _.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, t);
        }
        set normalizedAllowedLinearError(t) {
          _.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, t);
        }
        set normalizedPredictionDistance(t) {
          _.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, t);
        }
        set numSolverIterations(t) {
          _.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, t);
        }
        set numAdditionalFrictionIterations(t) {
          _.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, t);
        }
        set numInternalPgsIterations(t) {
          _.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, t);
        }
        set minIslandSize(t) {
          _.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, t);
        }
        set maxCcdSubsteps(t) {
          _.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, t);
        }
        set lengthUnit(t) {
          _.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, t);
        }
        switchToStandardPgsSolver() {
          _.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);
        }
        switchToSmallStepsPgsSolver() {
          _.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          _.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);
        }
      }
      const al = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawislandmanager_free(s >>> 0, 1));
      class Tn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Tn.prototype);
          return e.__wbg_ptr = t, al.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, al.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawislandmanager_free(t, 0);
        }
        constructor() {
          const t = _.rawislandmanager_new();
          return this.__wbg_ptr = t >>> 0, al.register(this, this.__wbg_ptr, this), this;
        }
        forEachActiveRigidBodyHandle(t) {
          try {
            _.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
      }
      const Mf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawkinematiccharactercontroller_free(s >>> 0, 1));
      class Mv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Mf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawkinematiccharactercontroller_free(t, 0);
        }
        constructor(t) {
          const e = _.rawkinematiccharactercontroller_new(t);
          return this.__wbg_ptr = e >>> 0, Mf.register(this, this.__wbg_ptr, this), this;
        }
        up() {
          const t = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return N.__wrap(t);
        }
        setUp(t) {
          F(t, N), _.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, t.__wbg_ptr);
        }
        normalNudgeFactor() {
          return _.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);
        }
        setNormalNudgeFactor(t) {
          _.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, t);
        }
        offset() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        setOffset(t) {
          _.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, t);
        }
        slideEnabled() {
          return _.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr) !== 0;
        }
        setSlideEnabled(t) {
          _.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, t);
        }
        autostepMaxHeight() {
          const t = _.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
        autostepMinWidth() {
          const t = _.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
        autostepIncludesDynamicBodies() {
          const t = _.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);
          return t === 16777215 ? void 0 : t !== 0;
        }
        autostepEnabled() {
          return _.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr) !== 0;
        }
        enableAutostep(t, e, i) {
          _.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, t, e, i);
        }
        disableAutostep() {
          _.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);
        }
        maxSlopeClimbAngle() {
          return _.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
        }
        setMaxSlopeClimbAngle(t) {
          _.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, t);
        }
        minSlopeSlideAngle() {
          return _.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);
        }
        setMinSlopeSlideAngle(t) {
          _.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, t);
        }
        snapToGroundDistance() {
          const t = _.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
        enableSnapToGround(t) {
          _.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, t);
        }
        disableSnapToGround() {
          _.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);
        }
        snapToGroundEnabled() {
          return _.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr) !== 0;
        }
        computeColliderMovement(t, e, i, n, r, a, o, c, l, h, d) {
          try {
            F(e, ve), F(i, Me), F(n, dd), F(a, N), _.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a.__wbg_ptr, o, Dt(c) ? 4294967297 : Math.fround(c), l, Dt(h) ? 4294967297 : h >>> 0, Ie(d));
          } finally {
            ie[we++] = void 0;
          }
        }
        computedMovement() {
          const t = _.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);
          return N.__wrap(t);
        }
        computedGrounded() {
          return _.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr) !== 0;
        }
        numComputedCollisions() {
          return _.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr) >>> 0;
        }
        computedCollision(t, e) {
          return F(e, aA), _.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, t, e.__wbg_ptr) !== 0;
        }
      }
      const ol = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawmultibodyjointset_free(s >>> 0, 1));
      class Rn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Rn.prototype);
          return e.__wbg_ptr = t, ol.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ol.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawmultibodyjointset_free(t, 0);
        }
        jointType(t) {
          return _.rawmultibodyjointset_jointType(this.__wbg_ptr, t);
        }
        jointFrameX1(t) {
          const e = _.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        jointFrameX2(t) {
          const e = _.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        jointAnchor1(t) {
          const e = _.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        jointAnchor2(t) {
          const e = _.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        jointContactsEnabled(t) {
          return _.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, t) !== 0;
        }
        jointSetContactsEnabled(t, e) {
          _.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, t, e);
        }
        jointLimitsEnabled(t, e) {
          return _.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, t, e) !== 0;
        }
        jointLimitsMin(t, e) {
          return _.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, t, e);
        }
        jointLimitsMax(t, e) {
          return _.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, t, e);
        }
        constructor() {
          const t = _.rawmultibodyjointset_new();
          return this.__wbg_ptr = t >>> 0, ol.register(this, this.__wbg_ptr, this), this;
        }
        createJoint(t, e, i, n) {
          return F(t, Ze), _.rawmultibodyjointset_createJoint(this.__wbg_ptr, t.__wbg_ptr, e, i, n);
        }
        remove(t, e) {
          _.rawmultibodyjointset_remove(this.__wbg_ptr, t, e);
        }
        contains(t) {
          return _.rawmultibodyjointset_contains(this.__wbg_ptr, t) !== 0;
        }
        forEachJointHandle(t) {
          try {
            _.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
        forEachJointAttachedToRigidBody(t, e) {
          try {
            _.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, t, Ie(e));
          } finally {
            ie[we++] = void 0;
          }
        }
      }
      const cl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawnarrowphase_free(s >>> 0, 1));
      class jn {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(jn.prototype);
          return e.__wbg_ptr = t, cl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, cl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawnarrowphase_free(t, 0);
        }
        constructor() {
          const t = _.rawnarrowphase_new();
          return this.__wbg_ptr = t >>> 0, cl.register(this, this.__wbg_ptr, this), this;
        }
        contact_pairs_with(t, e) {
          _.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, t, ze(e));
        }
        contact_pair(t, e) {
          const i = _.rawnarrowphase_contact_pair(this.__wbg_ptr, t, e);
          return i === 0 ? void 0 : ld.__wrap(i);
        }
        intersection_pairs_with(t, e) {
          _.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, t, ze(e));
        }
        intersection_pair(t, e) {
          return _.rawnarrowphase_intersection_pair(this.__wbg_ptr, t, e) !== 0;
        }
      }
      const Tf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawphysicspipeline_free(s >>> 0, 1));
      class Tv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Tf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawphysicspipeline_free(t, 0);
        }
        constructor() {
          const t = _.rawphysicspipeline_new();
          return this.__wbg_ptr = t >>> 0, Tf.register(this, this.__wbg_ptr, this), this;
        }
        step(t, e, i, n, r, a, o, c, l, h) {
          F(t, N), F(e, xr), F(i, Tn), F(n, yr), F(r, jn), F(a, ve), F(o, Me), F(c, Mn), F(l, Rn), F(h, fh), _.rawphysicspipeline_step(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr);
        }
        stepWithEvents(t, e, i, n, r, a, o, c, l, h, d, u, f, p) {
          F(t, N), F(e, xr), F(i, Tn), F(n, yr), F(r, jn), F(a, ve), F(o, Me), F(c, Mn), F(l, Rn), F(h, fh), F(d, oA), _.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, ze(u), ze(f), ze(p));
        }
      }
      const Rf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpidcontroller_free(s >>> 0, 1));
      class Rv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Rf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawpidcontroller_free(t, 0);
        }
        constructor(t, e, i, n) {
          const r = _.rawpidcontroller_new(t, e, i, n);
          return this.__wbg_ptr = r >>> 0, Rf.register(this, this.__wbg_ptr, this), this;
        }
        set_kp(t, e) {
          _.rawpidcontroller_set_kp(this.__wbg_ptr, t, e);
        }
        set_ki(t, e) {
          _.rawpidcontroller_set_ki(this.__wbg_ptr, t, e);
        }
        set_kd(t, e) {
          _.rawpidcontroller_set_kd(this.__wbg_ptr, t, e);
        }
        set_axes_mask(t) {
          _.rawpidcontroller_set_axes_mask(this.__wbg_ptr, t);
        }
        reset_integrals() {
          _.rawpidcontroller_reset_integrals(this.__wbg_ptr);
        }
        apply_linear_correction(t, e, i, n, r) {
          F(e, ve), F(n, N), F(r, N), _.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, t, e.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
        }
        apply_angular_correction(t, e, i, n, r) {
          F(e, ve), F(n, Yt), F(r, N), _.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, t, e.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
        }
        linear_correction(t, e, i, n, r) {
          F(e, ve), F(n, N), F(r, N);
          const a = _.rawpidcontroller_linear_correction(this.__wbg_ptr, t, e.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
          return N.__wrap(a);
        }
        angular_correction(t, e, i, n, r) {
          F(e, ve), F(n, Yt), F(r, N);
          const a = _.rawpidcontroller_angular_correction(this.__wbg_ptr, t, e.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
          return N.__wrap(a);
        }
      }
      const Bf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpointcolliderprojection_free(s >>> 0, 1));
      class Oo {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Oo.prototype);
          return e.__wbg_ptr = t, Bf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Bf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawpointcolliderprojection_free(t, 0);
        }
        colliderHandle() {
          return _.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
        }
        point() {
          const t = _.rawpointcolliderprojection_point(this.__wbg_ptr);
          return N.__wrap(t);
        }
        isInside() {
          return _.rawpointcolliderprojection_isInside(this.__wbg_ptr) !== 0;
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const t = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
      }
      const Df = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpointprojection_free(s >>> 0, 1));
      class ac {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ac.prototype);
          return e.__wbg_ptr = t, Df.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Df.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawpointprojection_free(t, 0);
        }
        point() {
          const t = _.rawpointprojection_point(this.__wbg_ptr);
          return N.__wrap(t);
        }
        isInside() {
          return _.rawpointprojection_isInside(this.__wbg_ptr) !== 0;
        }
      }
      const Pf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawquerypipeline_free(s >>> 0, 1));
      class dd {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Pf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawquerypipeline_free(t, 0);
        }
        constructor() {
          const t = _.rawquerypipeline_new();
          return this.__wbg_ptr = t >>> 0, Pf.register(this, this.__wbg_ptr, this), this;
        }
        update(t) {
          F(t, Me), _.rawquerypipeline_update(this.__wbg_ptr, t.__wbg_ptr);
        }
        castRay(t, e, i, n, r, a, o, c, l, h, d) {
          try {
            F(t, ve), F(e, Me), F(i, N), F(n, N);
            const u = _.rawquerypipeline_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o, Dt(c) ? 4294967297 : c >>> 0, !Dt(l), Dt(l) ? 0 : l, !Dt(h), Dt(h) ? 0 : h, Ie(d));
            return u === 0 ? void 0 : ud.__wrap(u);
          } finally {
            ie[we++] = void 0;
          }
        }
        castRayAndGetNormal(t, e, i, n, r, a, o, c, l, h, d) {
          try {
            F(t, ve), F(e, Me), F(i, N), F(n, N);
            const u = _.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o, Dt(c) ? 4294967297 : c >>> 0, !Dt(l), Dt(l) ? 0 : l, !Dt(h), Dt(h) ? 0 : h, Ie(d));
            return u === 0 ? void 0 : oc.__wrap(u);
          } finally {
            ie[we++] = void 0;
          }
        }
        intersectionsWithRay(t, e, i, n, r, a, o, c, l, h, d, u) {
          try {
            F(t, ve), F(e, Me), F(i, N), F(n, N), _.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, Ie(o), c, Dt(l) ? 4294967297 : l >>> 0, !Dt(h), Dt(h) ? 0 : h, !Dt(d), Dt(d) ? 0 : d, Ie(u));
          } finally {
            ie[we++] = void 0, ie[we++] = void 0;
          }
        }
        intersectionWithShape(t, e, i, n, r, a, o, c, l, h) {
          try {
            const f = _.__wbindgen_add_to_stack_pointer(-16);
            F(t, ve), F(e, Me), F(i, N), F(n, Yt), F(r, Bt), _.rawquerypipeline_intersectionWithShape(f, this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a, Dt(o) ? 4294967297 : o >>> 0, !Dt(c), Dt(c) ? 0 : c, !Dt(l), Dt(l) ? 0 : l, Ie(h));
            var d = Ke().getInt32(f + 4 * 0, true), u = Ke().getFloat64(f + 8 * 1, true);
            return d === 0 ? void 0 : u;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16), ie[we++] = void 0;
          }
        }
        projectPoint(t, e, i, n, r, a, o, c, l) {
          try {
            F(t, ve), F(e, Me), F(i, N);
            const h = _.rawquerypipeline_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n, r, Dt(a) ? 4294967297 : a >>> 0, !Dt(o), Dt(o) ? 0 : o, !Dt(c), Dt(c) ? 0 : c, Ie(l));
            return h === 0 ? void 0 : Oo.__wrap(h);
          } finally {
            ie[we++] = void 0;
          }
        }
        projectPointAndGetFeature(t, e, i, n, r, a, o, c) {
          try {
            F(t, ve), F(e, Me), F(i, N);
            const l = _.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n, Dt(r) ? 4294967297 : r >>> 0, !Dt(a), Dt(a) ? 0 : a, !Dt(o), Dt(o) ? 0 : o, Ie(c));
            return l === 0 ? void 0 : Oo.__wrap(l);
          } finally {
            ie[we++] = void 0;
          }
        }
        intersectionsWithPoint(t, e, i, n, r, a, o, c, l) {
          try {
            F(t, ve), F(e, Me), F(i, N), _.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, Ie(n), r, Dt(a) ? 4294967297 : a >>> 0, !Dt(o), Dt(o) ? 0 : o, !Dt(c), Dt(c) ? 0 : c, Ie(l));
          } finally {
            ie[we++] = void 0, ie[we++] = void 0;
          }
        }
        castShape(t, e, i, n, r, a, o, c, l, h, d, u, f, p) {
          try {
            F(t, ve), F(e, Me), F(i, N), F(n, Yt), F(r, N), F(a, Bt);
            const m = _.rawquerypipeline_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o, c, l, h, Dt(d) ? 4294967297 : d >>> 0, !Dt(u), Dt(u) ? 0 : u, !Dt(f), Dt(f) ? 0 : f, Ie(p));
            return m === 0 ? void 0 : sc.__wrap(m);
          } finally {
            ie[we++] = void 0;
          }
        }
        intersectionsWithShape(t, e, i, n, r, a, o, c, l, h, d) {
          try {
            F(t, ve), F(e, Me), F(i, N), F(n, Yt), F(r, Bt), _.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, Ie(a), o, Dt(c) ? 4294967297 : c >>> 0, !Dt(l), Dt(l) ? 0 : l, !Dt(h), Dt(h) ? 0 : h, Ie(d));
          } finally {
            ie[we++] = void 0, ie[we++] = void 0;
          }
        }
        collidersWithAabbIntersectingAabb(t, e, i) {
          try {
            F(t, N), F(e, N), _.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, Ie(i));
          } finally {
            ie[we++] = void 0;
          }
        }
      }
      const Ff = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawraycolliderhit_free(s >>> 0, 1));
      class ud {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ud.prototype);
          return e.__wbg_ptr = t, Ff.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ff.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawraycolliderhit_free(t, 0);
        }
        colliderHandle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        timeOfImpact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
      }
      const Lf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawraycolliderintersection_free(s >>> 0, 1));
      class oc {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(oc.prototype);
          return e.__wbg_ptr = t, Lf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Lf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawraycolliderintersection_free(t, 0);
        }
        colliderHandle() {
          return _.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
        }
        normal() {
          const t = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const t = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
      }
      const kf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrayintersection_free(s >>> 0, 1));
      class cc {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(cc.prototype);
          return e.__wbg_ptr = t, kf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, kf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawrayintersection_free(t, 0);
        }
        normal() {
          const t = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const t = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return t === 4294967297 ? void 0 : t;
        }
      }
      const ll = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrigidbodyset_free(s >>> 0, 1));
      class ve {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(ve.prototype);
          return e.__wbg_ptr = t, ll.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ll.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawrigidbodyset_free(t, 0);
        }
        rbTranslation(t) {
          const e = _.rawrigidbodyset_rbTranslation(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbRotation(t) {
          const e = _.rawrigidbodyset_rbRotation(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        rbSleep(t) {
          _.rawrigidbodyset_rbSleep(this.__wbg_ptr, t);
        }
        rbIsSleeping(t) {
          return _.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, t) !== 0;
        }
        rbIsMoving(t) {
          return _.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, t) !== 0;
        }
        rbNextTranslation(t) {
          const e = _.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbNextRotation(t) {
          const e = _.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        rbSetTranslation(t, e, i, n, r) {
          _.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, t, e, i, n, r);
        }
        rbSetRotation(t, e, i, n, r, a) {
          _.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, t, e, i, n, r, a);
        }
        rbSetLinvel(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbSetAngvel(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbSetNextKinematicTranslation(t, e, i, n) {
          _.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, t, e, i, n);
        }
        rbSetNextKinematicRotation(t, e, i, n, r) {
          _.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, t, e, i, n, r);
        }
        rbRecomputeMassPropertiesFromColliders(t, e) {
          F(e, Me), _.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, t, e.__wbg_ptr);
        }
        rbSetAdditionalMass(t, e, i) {
          _.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, t, e, i);
        }
        rbSetAdditionalMassProperties(t, e, i, n, r, a) {
          F(i, N), F(n, N), F(r, Yt), _.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, t, e, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a);
        }
        rbLinvel(t) {
          const e = _.rawrigidbodyset_rbLinvel(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbAngvel(t) {
          const e = _.rawrigidbodyset_rbAngvel(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbLockTranslations(t, e, i) {
          _.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, t, e, i);
        }
        rbSetEnabledTranslations(t, e, i, n, r) {
          _.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, t, e, i, n, r);
        }
        rbLockRotations(t, e, i) {
          _.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, t, e, i);
        }
        rbSetEnabledRotations(t, e, i, n, r) {
          _.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, t, e, i, n, r);
        }
        rbDominanceGroup(t) {
          return _.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, t);
        }
        rbSetDominanceGroup(t, e) {
          _.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, t, e);
        }
        rbEnableCcd(t, e) {
          _.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, t, e);
        }
        rbSetSoftCcdPrediction(t, e) {
          _.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, t, e);
        }
        rbMass(t) {
          return _.rawrigidbodyset_rbMass(this.__wbg_ptr, t);
        }
        rbInvMass(t) {
          return _.rawrigidbodyset_rbInvMass(this.__wbg_ptr, t);
        }
        rbEffectiveInvMass(t) {
          const e = _.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbLocalCom(t) {
          const e = _.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbWorldCom(t) {
          const e = _.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbInvPrincipalInertiaSqrt(t) {
          const e = _.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbPrincipalInertiaLocalFrame(t) {
          const e = _.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, t);
          return Yt.__wrap(e);
        }
        rbPrincipalInertia(t) {
          const e = _.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbEffectiveWorldInvInertiaSqrt(t) {
          const e = _.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, t);
          return zo.__wrap(e);
        }
        rbEffectiveAngularInertia(t) {
          const e = _.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, t);
          return zo.__wrap(e);
        }
        rbWakeUp(t) {
          _.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, t);
        }
        rbIsCcdEnabled(t) {
          return _.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, t) !== 0;
        }
        rbSoftCcdPrediction(t) {
          return _.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, t);
        }
        rbNumColliders(t) {
          return _.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, t) >>> 0;
        }
        rbCollider(t, e) {
          return _.rawrigidbodyset_rbCollider(this.__wbg_ptr, t, e);
        }
        rbBodyType(t) {
          return _.rawrigidbodyset_rbBodyType(this.__wbg_ptr, t);
        }
        rbSetBodyType(t, e, i) {
          _.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, t, e, i);
        }
        rbIsFixed(t) {
          return _.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, t) !== 0;
        }
        rbIsKinematic(t) {
          return _.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, t) !== 0;
        }
        rbIsDynamic(t) {
          return _.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, t) !== 0;
        }
        rbLinearDamping(t) {
          return _.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, t);
        }
        rbAngularDamping(t) {
          return _.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, t);
        }
        rbSetLinearDamping(t, e) {
          _.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, t, e);
        }
        rbSetAngularDamping(t, e) {
          _.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, t, e);
        }
        rbSetEnabled(t, e) {
          _.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, t, e);
        }
        rbIsEnabled(t) {
          return _.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, t) !== 0;
        }
        rbGravityScale(t) {
          return _.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, t);
        }
        rbSetGravityScale(t, e, i) {
          _.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, t, e, i);
        }
        rbResetForces(t, e) {
          _.rawrigidbodyset_rbResetForces(this.__wbg_ptr, t, e);
        }
        rbResetTorques(t, e) {
          _.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, t, e);
        }
        rbAddForce(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbAddForce(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbApplyImpulse(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbAddTorque(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbApplyTorqueImpulse(t, e, i) {
          F(e, N), _.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, t, e.__wbg_ptr, i);
        }
        rbAddForceAtPoint(t, e, i, n) {
          F(e, N), F(i, N), _.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n);
        }
        rbApplyImpulseAtPoint(t, e, i, n) {
          F(e, N), F(i, N), _.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n);
        }
        rbAdditionalSolverIterations(t) {
          return _.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, t) >>> 0;
        }
        rbSetAdditionalSolverIterations(t, e) {
          _.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, t, e);
        }
        rbUserData(t) {
          return _.rawrigidbodyset_rbUserData(this.__wbg_ptr, t) >>> 0;
        }
        rbSetUserData(t, e) {
          _.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, t, e);
        }
        rbUserForce(t) {
          const e = _.rawrigidbodyset_rbUserForce(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        rbUserTorque(t) {
          const e = _.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, t);
          return N.__wrap(e);
        }
        constructor() {
          const t = _.rawrigidbodyset_new();
          return this.__wbg_ptr = t >>> 0, ll.register(this, this.__wbg_ptr, this), this;
        }
        createRigidBody(t, e, i, n, r, a, o, c, l, h, d, u, f, p, m, g, A, x, b, y, M, T, R, B, S, E) {
          return F(e, N), F(i, Yt), F(o, N), F(c, N), F(l, N), F(h, N), F(d, Yt), _.rawrigidbodyset_createRigidBody(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n, r, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, u, f, p, m, g, A, x, b, y, M, T, R, B, S, E);
        }
        remove(t, e, i, n, r) {
          F(e, Tn), F(i, Me), F(n, Mn), F(r, Rn), _.rawrigidbodyset_remove(this.__wbg_ptr, t, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
        len() {
          return _.rawcolliderset_len(this.__wbg_ptr) >>> 0;
        }
        contains(t) {
          return _.rawrigidbodyset_contains(this.__wbg_ptr, t) !== 0;
        }
        forEachRigidBodyHandle(t) {
          try {
            _.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, Ie(t));
          } finally {
            ie[we++] = void 0;
          }
        }
        propagateModifiedBodyPositionsToColliders(t) {
          F(t, Me), _.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, t.__wbg_ptr);
        }
      }
      const hl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrotation_free(s >>> 0, 1));
      class Yt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Yt.prototype);
          return e.__wbg_ptr = t, hl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, hl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawrotation_free(t, 0);
        }
        constructor(t, e, i, n) {
          const r = _.rawrotation_new(t, e, i, n);
          return this.__wbg_ptr = r >>> 0, hl.register(this, this.__wbg_ptr, this), this;
        }
        static identity() {
          const t = _.rawrotation_identity();
          return Yt.__wrap(t);
        }
        get x() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        get y() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        get z() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        get w() {
          return _.rawrotation_w(this.__wbg_ptr);
        }
      }
      const Nf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawsdpmatrix3_free(s >>> 0, 1));
      class zo {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(zo.prototype);
          return e.__wbg_ptr = t, Nf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Nf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawsdpmatrix3_free(t, 0);
        }
        elements() {
          const t = _.rawsdpmatrix3_elements(this.__wbg_ptr);
          return aa(t);
        }
      }
      const Uf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawserializationpipeline_free(s >>> 0, 1));
      class Bv {
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Uf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawserializationpipeline_free(t, 0);
        }
        constructor() {
          const t = _.rawserializationpipeline_new();
          return this.__wbg_ptr = t >>> 0, Uf.register(this, this.__wbg_ptr, this), this;
        }
        serializeAll(t, e, i, n, r, a, o, c, l) {
          F(t, N), F(e, xr), F(i, Tn), F(n, yr), F(r, jn), F(a, ve), F(o, Me), F(c, Mn), F(l, Rn);
          const h = _.rawserializationpipeline_serializeAll(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr);
          return aa(h);
        }
        deserializeAll(t) {
          const e = _.rawserializationpipeline_deserializeAll(this.__wbg_ptr, ze(t));
          return e === 0 ? void 0 : hd.__wrap(e);
        }
      }
      const Qf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshape_free(s >>> 0, 1));
      class Bt {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Bt.prototype);
          return e.__wbg_ptr = t, Qf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Qf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawshape_free(t, 0);
        }
        static cuboid(t, e, i) {
          const n = _.rawshape_cuboid(t, e, i);
          return Bt.__wrap(n);
        }
        static roundCuboid(t, e, i, n) {
          const r = _.rawshape_roundCuboid(t, e, i, n);
          return Bt.__wrap(r);
        }
        static ball(t) {
          const e = _.rawshape_ball(t);
          return Bt.__wrap(e);
        }
        static halfspace(t) {
          F(t, N);
          const e = _.rawshape_halfspace(t.__wbg_ptr);
          return Bt.__wrap(e);
        }
        static capsule(t, e) {
          const i = _.rawshape_capsule(t, e);
          return Bt.__wrap(i);
        }
        static cylinder(t, e) {
          const i = _.rawshape_cylinder(t, e);
          return Bt.__wrap(i);
        }
        static roundCylinder(t, e, i) {
          const n = _.rawshape_roundCylinder(t, e, i);
          return Bt.__wrap(n);
        }
        static cone(t, e) {
          const i = _.rawshape_cone(t, e);
          return Bt.__wrap(i);
        }
        static roundCone(t, e, i) {
          const n = _.rawshape_roundCone(t, e, i);
          return Bt.__wrap(n);
        }
        static polyline(t, e) {
          const i = or(t, _.__wbindgen_export_2), n = Si, r = fo(e, _.__wbindgen_export_2), a = Si, o = _.rawshape_polyline(i, n, r, a);
          return Bt.__wrap(o);
        }
        static trimesh(t, e, i) {
          const n = or(t, _.__wbindgen_export_2), r = Si, a = fo(e, _.__wbindgen_export_2), o = Si, c = _.rawshape_trimesh(n, r, a, o, i);
          return c === 0 ? void 0 : Bt.__wrap(c);
        }
        static heightfield(t, e, i, n, r) {
          const a = or(i, _.__wbindgen_export_2), o = Si;
          F(n, N);
          const c = _.rawshape_heightfield(t, e, a, o, n.__wbg_ptr, r);
          return Bt.__wrap(c);
        }
        static segment(t, e) {
          F(t, N), F(e, N);
          const i = _.rawshape_segment(t.__wbg_ptr, e.__wbg_ptr);
          return Bt.__wrap(i);
        }
        static triangle(t, e, i) {
          F(t, N), F(e, N), F(i, N);
          const n = _.rawshape_triangle(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr);
          return Bt.__wrap(n);
        }
        static roundTriangle(t, e, i, n) {
          F(t, N), F(e, N), F(i, N);
          const r = _.rawshape_roundTriangle(t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n);
          return Bt.__wrap(r);
        }
        static convexHull(t) {
          const e = or(t, _.__wbindgen_export_2), i = Si, n = _.rawshape_convexHull(e, i);
          return n === 0 ? void 0 : Bt.__wrap(n);
        }
        static roundConvexHull(t, e) {
          const i = or(t, _.__wbindgen_export_2), n = Si, r = _.rawshape_roundConvexHull(i, n, e);
          return r === 0 ? void 0 : Bt.__wrap(r);
        }
        static convexMesh(t, e) {
          const i = or(t, _.__wbindgen_export_2), n = Si, r = fo(e, _.__wbindgen_export_2), a = Si, o = _.rawshape_convexMesh(i, n, r, a);
          return o === 0 ? void 0 : Bt.__wrap(o);
        }
        static roundConvexMesh(t, e, i) {
          const n = or(t, _.__wbindgen_export_2), r = Si, a = fo(e, _.__wbindgen_export_2), o = Si, c = _.rawshape_roundConvexMesh(n, r, a, o, i);
          return c === 0 ? void 0 : Bt.__wrap(c);
        }
        castShape(t, e, i, n, r, a, o, c, l, h) {
          F(t, N), F(e, Yt), F(i, N), F(n, Bt), F(r, N), F(a, Yt), F(o, N);
          const d = _.rawshape_castShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c, l, h);
          return d === 0 ? void 0 : lc.__wrap(d);
        }
        intersectsShape(t, e, i, n, r) {
          return F(t, N), F(e, Yt), F(i, Bt), F(n, N), F(r, Yt), _.rawshape_intersectsShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr) !== 0;
        }
        contactShape(t, e, i, n, r, a) {
          F(t, N), F(e, Yt), F(i, Bt), F(n, N), F(r, Yt);
          const o = _.rawshape_contactShape(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a);
          return o === 0 ? void 0 : oa.__wrap(o);
        }
        containsPoint(t, e, i) {
          return F(t, N), F(e, Yt), F(i, N), _.rawshape_containsPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr) !== 0;
        }
        projectPoint(t, e, i, n) {
          F(t, N), F(e, Yt), F(i, N);
          const r = _.rawshape_projectPoint(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n);
          return ac.__wrap(r);
        }
        intersectsRay(t, e, i, n, r) {
          return F(t, N), F(e, Yt), F(i, N), F(n, N), _.rawshape_intersectsRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r) !== 0;
        }
        castRay(t, e, i, n, r, a) {
          return F(t, N), F(e, Yt), F(i, N), F(n, N), _.rawshape_castRay(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a);
        }
        castRayAndGetNormal(t, e, i, n, r, a) {
          F(t, N), F(e, Yt), F(i, N), F(n, N);
          const o = _.rawshape_castRayAndGetNormal(this.__wbg_ptr, t.__wbg_ptr, e.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a);
          return o === 0 ? void 0 : cc.__wrap(o);
        }
      }
      const Of = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshapecasthit_free(s >>> 0, 1));
      class lc {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(lc.prototype);
          return e.__wbg_ptr = t, Of.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Of.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawshapecasthit_free(t, 0);
        }
        time_of_impact() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        witness1() {
          const t = _.rawshapecasthit_witness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        witness2() {
          const t = _.rawcontactforceevent_total_force(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal1() {
          const t = _.rawshapecasthit_normal1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal2() {
          const t = _.rawshapecasthit_normal2(this.__wbg_ptr);
          return N.__wrap(t);
        }
      }
      const zf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshapecontact_free(s >>> 0, 1));
      class oa {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(oa.prototype);
          return e.__wbg_ptr = t, zf.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, zf.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawshapecontact_free(t, 0);
        }
        distance() {
          return _.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
        }
        point1() {
          const t = _.rawpointprojection_point(this.__wbg_ptr);
          return N.__wrap(t);
        }
        point2() {
          const t = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal1() {
          const t = _.rawcollidershapecasthit_witness2(this.__wbg_ptr);
          return N.__wrap(t);
        }
        normal2() {
          const t = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return N.__wrap(t);
        }
      }
      const dl = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawvector_free(s >>> 0, 1));
      class N {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(N.prototype);
          return e.__wbg_ptr = t, dl.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, dl.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          _.__wbg_rawvector_free(t, 0);
        }
        static zero() {
          const t = _.rawvector_zero();
          return N.__wrap(t);
        }
        constructor(t, e, i) {
          const n = _.rawvector_new(t, e, i);
          return this.__wbg_ptr = n >>> 0, dl.register(this, this.__wbg_ptr, this), this;
        }
        get x() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        set x(t) {
          _.rawvector_set_x(this.__wbg_ptr, t);
        }
        get y() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        set y(t) {
          _.rawintegrationparameters_set_dt(this.__wbg_ptr, t);
        }
        get z() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        set z(t) {
          _.rawvector_set_z(this.__wbg_ptr, t);
        }
        xyz() {
          const t = _.rawvector_xyz(this.__wbg_ptr);
          return N.__wrap(t);
        }
        yxz() {
          const t = _.rawvector_yxz(this.__wbg_ptr);
          return N.__wrap(t);
        }
        zxy() {
          const t = _.rawvector_zxy(this.__wbg_ptr);
          return N.__wrap(t);
        }
        xzy() {
          const t = _.rawvector_xzy(this.__wbg_ptr);
          return N.__wrap(t);
        }
        yzx() {
          const t = _.rawvector_yzx(this.__wbg_ptr);
          return N.__wrap(t);
        }
        zyx() {
          const t = _.rawvector_zyx(this.__wbg_ptr);
          return N.__wrap(t);
        }
      }
      function Dv(s, t, e, i) {
        const n = fe(s).bind(fe(t), fe(e), fe(i));
        return ze(n);
      }
      function Pv(s) {
        const t = fe(s).buffer;
        return ze(t);
      }
      function Fv() {
        return ad(function(s, t, e) {
          const i = fe(s).call(fe(t), fe(e));
          return ze(i);
        }, arguments);
      }
      function Lv() {
        return ad(function(s, t, e, i) {
          const n = fe(s).call(fe(t), fe(e), fe(i));
          return ze(n);
        }, arguments);
      }
      function kv() {
        return ad(function(s, t, e, i, n) {
          const r = fe(s).call(fe(t), fe(e), fe(i), fe(n));
          return ze(r);
        }, arguments);
      }
      function Nv(s) {
        return fe(s).length;
      }
      function Uv(s) {
        return fe(s).length;
      }
      function Qv(s) {
        const t = new Uint8Array(fe(s));
        return ze(t);
      }
      function Ov(s, t, e) {
        const i = new Uint8Array(fe(s), t >>> 0, e >>> 0);
        return ze(i);
      }
      function zv(s, t, e) {
        const i = new Float32Array(fe(s), t >>> 0, e >>> 0);
        return ze(i);
      }
      function Gv(s) {
        const t = new Float32Array(s >>> 0);
        return ze(t);
      }
      function Hv(s) {
        const t = od.__wrap(s);
        return ze(t);
      }
      function Vv(s) {
        const t = oc.__wrap(s);
        return ze(t);
      }
      function Wv(s, t, e) {
        fe(s).set(fe(t), e >>> 0);
      }
      function jv(s, t, e) {
        fe(s).set(fe(t), e >>> 0);
      }
      function qv(s) {
        const t = fe(s);
        return typeof t == "boolean" ? t ? 1 : 0 : 2;
      }
      function Xv(s) {
        return typeof fe(s) == "function";
      }
      function Yv() {
        const s = _.memory;
        return ze(s);
      }
      function Kv(s, t) {
        const e = fe(t), i = typeof e == "number" ? e : void 0;
        Ke().setFloat64(s + 8 * 1, Dt(i) ? 0 : i, true), Ke().setInt32(s + 4 * 0, !Dt(i), true);
      }
      function Jv(s) {
        return ze(s);
      }
      function Zv(s) {
        aa(s);
      }
      function $v(s, t) {
        throw new Error(nA(s, t));
      }
      URL = globalThis.URL;
      const w = await wv({
        "./rapier_wasm3d_bg.js": {
          __wbindgen_number_new: Jv,
          __wbindgen_boolean_get: qv,
          __wbindgen_object_drop_ref: Zv,
          __wbindgen_number_get: Kv,
          __wbindgen_is_function: Xv,
          __wbg_rawraycolliderintersection_new: Vv,
          __wbg_rawcontactforceevent_new: Hv,
          __wbg_call_7cccdd69e0791ae2: Fv,
          __wbg_call_833bed5770ea2041: Lv,
          __wbg_call_b8adc8b1d0a0d8eb: kv,
          __wbg_bind_c8359b1cba058168: Dv,
          __wbg_buffer_609cc3eee51ed158: Pv,
          __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: Ov,
          __wbg_new_a12002a7f91c75be: Qv,
          __wbg_set_65595bdd868b3009: jv,
          __wbg_length_a446193dc22c12f8: Uv,
          __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: zv,
          __wbg_set_10bad9bee0e9c58b: Wv,
          __wbg_length_3b4f022188ae8db6: Nv,
          __wbg_newwithlength_5a5efe313cfd59f1: Gv,
          __wbindgen_throw: $v,
          __wbindgen_memory: Yv
        }
      }, mv), tE = w.memory, eE = w.version, iE = w.__wbg_rawkinematiccharactercontroller_free, nE = w.rawkinematiccharactercontroller_new, rE = w.rawkinematiccharactercontroller_setUp, sE = w.rawkinematiccharactercontroller_normalNudgeFactor, aE = w.rawkinematiccharactercontroller_setNormalNudgeFactor, oE = w.rawkinematiccharactercontroller_setOffset, cE = w.rawkinematiccharactercontroller_slideEnabled, lE = w.rawkinematiccharactercontroller_setSlideEnabled, hE = w.rawkinematiccharactercontroller_autostepMaxHeight, dE = w.rawkinematiccharactercontroller_autostepMinWidth, uE = w.rawkinematiccharactercontroller_autostepIncludesDynamicBodies, fE = w.rawkinematiccharactercontroller_autostepEnabled, pE = w.rawkinematiccharactercontroller_enableAutostep, AE = w.rawkinematiccharactercontroller_disableAutostep, gE = w.rawkinematiccharactercontroller_maxSlopeClimbAngle, _E = w.rawkinematiccharactercontroller_setMaxSlopeClimbAngle, mE = w.rawkinematiccharactercontroller_minSlopeSlideAngle, wE = w.rawkinematiccharactercontroller_setMinSlopeSlideAngle, bE = w.rawkinematiccharactercontroller_snapToGroundDistance, yE = w.rawkinematiccharactercontroller_enableSnapToGround, xE = w.rawkinematiccharactercontroller_disableSnapToGround, vE = w.rawkinematiccharactercontroller_snapToGroundEnabled, EE = w.rawkinematiccharactercontroller_computeColliderMovement, SE = w.rawkinematiccharactercontroller_computedMovement, CE = w.rawkinematiccharactercontroller_computedGrounded, IE = w.rawkinematiccharactercontroller_numComputedCollisions, ME = w.rawkinematiccharactercontroller_computedCollision, TE = w.__wbg_rawcharactercollision_free, RE = w.rawcharactercollision_new, BE = w.rawcharactercollision_handle, DE = w.rawcharactercollision_translationDeltaApplied, PE = w.rawcharactercollision_translationDeltaRemaining, FE = w.rawcharactercollision_toi, LE = w.rawcharactercollision_worldWitness1, kE = w.rawcharactercollision_worldWitness2, NE = w.rawcharactercollision_worldNormal1, UE = w.rawcharactercollision_worldNormal2, QE = w.__wbg_rawpidcontroller_free, OE = w.rawpidcontroller_new, zE = w.rawpidcontroller_set_kp, GE = w.rawpidcontroller_set_ki, HE = w.rawpidcontroller_set_kd, VE = w.rawpidcontroller_set_axes_mask, WE = w.rawpidcontroller_reset_integrals, jE = w.rawpidcontroller_apply_linear_correction, qE = w.rawpidcontroller_apply_angular_correction, XE = w.rawpidcontroller_linear_correction, YE = w.rawpidcontroller_angular_correction, KE = w.__wbg_rawdynamicraycastvehiclecontroller_free, JE = w.rawdynamicraycastvehiclecontroller_new, ZE = w.rawdynamicraycastvehiclecontroller_current_vehicle_speed, $E = w.rawdynamicraycastvehiclecontroller_chassis, tS = w.rawdynamicraycastvehiclecontroller_index_up_axis, eS = w.rawdynamicraycastvehiclecontroller_set_index_up_axis, iS = w.rawdynamicraycastvehiclecontroller_index_forward_axis, nS = w.rawdynamicraycastvehiclecontroller_set_index_forward_axis, rS = w.rawdynamicraycastvehiclecontroller_add_wheel, sS = w.rawdynamicraycastvehiclecontroller_num_wheels, aS = w.rawdynamicraycastvehiclecontroller_update_vehicle, oS = w.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs, cS = w.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs, lS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length, hS = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length, dS = w.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel, uS = w.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel, fS = w.rawdynamicraycastvehiclecontroller_wheel_radius, pS = w.rawdynamicraycastvehiclecontroller_set_wheel_radius, AS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness, gS = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness, _S = w.rawdynamicraycastvehiclecontroller_wheel_suspension_compression, mS = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression, wS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation, bS = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation, yS = w.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force, xS = w.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force, vS = w.rawdynamicraycastvehiclecontroller_wheel_brake, ES = w.rawdynamicraycastvehiclecontroller_set_wheel_brake, SS = w.rawdynamicraycastvehiclecontroller_wheel_steering, CS = w.rawdynamicraycastvehiclecontroller_set_wheel_steering, IS = w.rawdynamicraycastvehiclecontroller_wheel_engine_force, MS = w.rawdynamicraycastvehiclecontroller_set_wheel_engine_force, TS = w.rawdynamicraycastvehiclecontroller_wheel_direction_cs, RS = w.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs, BS = w.rawdynamicraycastvehiclecontroller_wheel_axle_cs, DS = w.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs, PS = w.rawdynamicraycastvehiclecontroller_wheel_friction_slip, FS = w.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip, LS = w.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness, kS = w.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness, NS = w.rawdynamicraycastvehiclecontroller_wheel_rotation, US = w.rawdynamicraycastvehiclecontroller_wheel_forward_impulse, QS = w.rawdynamicraycastvehiclecontroller_wheel_side_impulse, OS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_force, zS = w.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws, GS = w.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws, HS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_length, VS = w.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws, WS = w.rawdynamicraycastvehiclecontroller_wheel_is_in_contact, jS = w.rawdynamicraycastvehiclecontroller_wheel_ground_object, qS = w.__wbg_rawccdsolver_free, XS = w.rawccdsolver_new, YS = w.rawimpulsejointset_jointType, KS = w.rawimpulsejointset_jointBodyHandle1, JS = w.rawimpulsejointset_jointBodyHandle2, ZS = w.rawimpulsejointset_jointFrameX1, $S = w.rawimpulsejointset_jointFrameX2, tC = w.rawimpulsejointset_jointAnchor1, eC = w.rawimpulsejointset_jointAnchor2, iC = w.rawimpulsejointset_jointSetAnchor1, nC = w.rawimpulsejointset_jointSetAnchor2, rC = w.rawimpulsejointset_jointContactsEnabled, sC = w.rawimpulsejointset_jointSetContactsEnabled, aC = w.rawimpulsejointset_jointLimitsEnabled, oC = w.rawimpulsejointset_jointLimitsMin, cC = w.rawimpulsejointset_jointLimitsMax, lC = w.rawimpulsejointset_jointSetLimits, hC = w.rawimpulsejointset_jointConfigureMotorModel, dC = w.rawimpulsejointset_jointConfigureMotorVelocity, uC = w.rawimpulsejointset_jointConfigureMotorPosition, fC = w.rawimpulsejointset_jointConfigureMotor, pC = w.__wbg_rawimpulsejointset_free, AC = w.rawimpulsejointset_new, gC = w.rawimpulsejointset_createJoint, _C = w.rawimpulsejointset_remove, mC = w.rawimpulsejointset_len, wC = w.rawimpulsejointset_contains, bC = w.rawimpulsejointset_forEachJointHandle, yC = w.rawimpulsejointset_forEachJointAttachedToRigidBody, xC = w.__wbg_rawintegrationparameters_free, vC = w.rawintegrationparameters_new, EC = w.rawintegrationparameters_dt, SC = w.rawintegrationparameters_contact_erp, CC = w.rawintegrationparameters_normalizedAllowedLinearError, IC = w.rawintegrationparameters_numSolverIterations, MC = w.rawintegrationparameters_numAdditionalFrictionIterations, TC = w.rawintegrationparameters_numInternalPgsIterations, RC = w.rawintegrationparameters_maxCcdSubsteps, BC = w.rawintegrationparameters_lengthUnit, DC = w.rawintegrationparameters_set_dt, PC = w.rawintegrationparameters_set_contact_natural_frequency, FC = w.rawintegrationparameters_set_normalizedAllowedLinearError, LC = w.rawintegrationparameters_set_normalizedPredictionDistance, kC = w.rawintegrationparameters_set_numSolverIterations, NC = w.rawintegrationparameters_set_numAdditionalFrictionIterations, UC = w.rawintegrationparameters_set_numInternalPgsIterations, QC = w.rawintegrationparameters_set_minIslandSize, OC = w.rawintegrationparameters_set_maxCcdSubsteps, zC = w.rawintegrationparameters_set_lengthUnit, GC = w.rawintegrationparameters_switchToStandardPgsSolver, HC = w.rawintegrationparameters_switchToSmallStepsPgsSolver, VC = w.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart, WC = w.__wbg_rawislandmanager_free, jC = w.rawislandmanager_new, qC = w.rawislandmanager_forEachActiveRigidBodyHandle, XC = w.__wbg_rawgenericjoint_free, YC = w.rawgenericjoint_generic, KC = w.rawgenericjoint_spring, JC = w.rawgenericjoint_rope, ZC = w.rawgenericjoint_spherical, $C = w.rawgenericjoint_prismatic, tI = w.rawgenericjoint_fixed, eI = w.rawgenericjoint_revolute, iI = w.rawmultibodyjointset_jointType, nI = w.rawmultibodyjointset_jointFrameX1, rI = w.rawmultibodyjointset_jointFrameX2, sI = w.rawmultibodyjointset_jointAnchor1, aI = w.rawmultibodyjointset_jointAnchor2, oI = w.rawmultibodyjointset_jointContactsEnabled, cI = w.rawmultibodyjointset_jointSetContactsEnabled, lI = w.rawmultibodyjointset_jointLimitsEnabled, hI = w.rawmultibodyjointset_jointLimitsMin, dI = w.rawmultibodyjointset_jointLimitsMax, uI = w.__wbg_rawmultibodyjointset_free, fI = w.rawmultibodyjointset_new, pI = w.rawmultibodyjointset_createJoint, AI = w.rawmultibodyjointset_remove, gI = w.rawmultibodyjointset_contains, _I = w.rawmultibodyjointset_forEachJointHandle, mI = w.rawmultibodyjointset_forEachJointAttachedToRigidBody, wI = w.rawrigidbodyset_rbTranslation, bI = w.rawrigidbodyset_rbRotation, yI = w.rawrigidbodyset_rbSleep, xI = w.rawrigidbodyset_rbIsSleeping, vI = w.rawrigidbodyset_rbIsMoving, EI = w.rawrigidbodyset_rbNextTranslation, SI = w.rawrigidbodyset_rbNextRotation, CI = w.rawrigidbodyset_rbSetTranslation, II = w.rawrigidbodyset_rbSetRotation, MI = w.rawrigidbodyset_rbSetLinvel, TI = w.rawrigidbodyset_rbSetAngvel, RI = w.rawrigidbodyset_rbSetNextKinematicTranslation, BI = w.rawrigidbodyset_rbSetNextKinematicRotation, DI = w.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders, PI = w.rawrigidbodyset_rbSetAdditionalMass, FI = w.rawrigidbodyset_rbSetAdditionalMassProperties, LI = w.rawrigidbodyset_rbLinvel, kI = w.rawrigidbodyset_rbAngvel, NI = w.rawrigidbodyset_rbLockTranslations, UI = w.rawrigidbodyset_rbSetEnabledTranslations, QI = w.rawrigidbodyset_rbLockRotations, OI = w.rawrigidbodyset_rbSetEnabledRotations, zI = w.rawrigidbodyset_rbDominanceGroup, GI = w.rawrigidbodyset_rbSetDominanceGroup, HI = w.rawrigidbodyset_rbEnableCcd, VI = w.rawrigidbodyset_rbSetSoftCcdPrediction, WI = w.rawrigidbodyset_rbMass, jI = w.rawrigidbodyset_rbInvMass, qI = w.rawrigidbodyset_rbEffectiveInvMass, XI = w.rawrigidbodyset_rbLocalCom, YI = w.rawrigidbodyset_rbWorldCom, KI = w.rawrigidbodyset_rbInvPrincipalInertiaSqrt, JI = w.rawrigidbodyset_rbPrincipalInertiaLocalFrame, ZI = w.rawrigidbodyset_rbPrincipalInertia, $I = w.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt, tM = w.rawrigidbodyset_rbEffectiveAngularInertia, eM = w.rawrigidbodyset_rbWakeUp, iM = w.rawrigidbodyset_rbIsCcdEnabled, nM = w.rawrigidbodyset_rbSoftCcdPrediction, rM = w.rawrigidbodyset_rbNumColliders, sM = w.rawrigidbodyset_rbCollider, aM = w.rawrigidbodyset_rbBodyType, oM = w.rawrigidbodyset_rbSetBodyType, cM = w.rawrigidbodyset_rbIsFixed, lM = w.rawrigidbodyset_rbIsKinematic, hM = w.rawrigidbodyset_rbIsDynamic, dM = w.rawrigidbodyset_rbLinearDamping, uM = w.rawrigidbodyset_rbAngularDamping, fM = w.rawrigidbodyset_rbSetLinearDamping, pM = w.rawrigidbodyset_rbSetAngularDamping, AM = w.rawrigidbodyset_rbSetEnabled, gM = w.rawrigidbodyset_rbIsEnabled, _M = w.rawrigidbodyset_rbGravityScale, mM = w.rawrigidbodyset_rbSetGravityScale, wM = w.rawrigidbodyset_rbResetForces, bM = w.rawrigidbodyset_rbResetTorques, yM = w.rawrigidbodyset_rbAddForce, xM = w.rawrigidbodyset_rbApplyImpulse, vM = w.rawrigidbodyset_rbAddTorque, EM = w.rawrigidbodyset_rbApplyTorqueImpulse, SM = w.rawrigidbodyset_rbAddForceAtPoint, CM = w.rawrigidbodyset_rbApplyImpulseAtPoint, IM = w.rawrigidbodyset_rbAdditionalSolverIterations, MM = w.rawrigidbodyset_rbSetAdditionalSolverIterations, TM = w.rawrigidbodyset_rbUserData, RM = w.rawrigidbodyset_rbSetUserData, BM = w.rawrigidbodyset_rbUserForce, DM = w.rawrigidbodyset_rbUserTorque, PM = w.__wbg_rawrigidbodyset_free, FM = w.rawrigidbodyset_new, LM = w.rawrigidbodyset_createRigidBody, kM = w.rawrigidbodyset_remove, NM = w.rawrigidbodyset_contains, UM = w.rawrigidbodyset_forEachRigidBodyHandle, QM = w.rawrigidbodyset_propagateModifiedBodyPositionsToColliders, OM = w.__wbg_rawbroadphase_free, zM = w.rawbroadphase_new, GM = w.rawcolliderset_coTranslation, HM = w.rawcolliderset_coRotation, VM = w.rawcolliderset_coSetTranslation, WM = w.rawcolliderset_coSetTranslationWrtParent, jM = w.rawcolliderset_coSetRotation, qM = w.rawcolliderset_coSetRotationWrtParent, XM = w.rawcolliderset_coIsSensor, YM = w.rawcolliderset_coShapeType, KM = w.rawcolliderset_coHalfspaceNormal, JM = w.rawcolliderset_coHalfExtents, ZM = w.rawcolliderset_coSetHalfExtents, $M = w.rawcolliderset_coRadius, tT = w.rawcolliderset_coSetRadius, eT = w.rawcolliderset_coHalfHeight, iT = w.rawcolliderset_coSetHalfHeight, nT = w.rawcolliderset_coRoundRadius, rT = w.rawcolliderset_coSetRoundRadius, sT = w.rawcolliderset_coVertices, aT = w.rawcolliderset_coIndices, oT = w.rawcolliderset_coTriMeshFlags, cT = w.rawcolliderset_coHeightFieldFlags, lT = w.rawcolliderset_coHeightfieldHeights, hT = w.rawcolliderset_coHeightfieldScale, dT = w.rawcolliderset_coHeightfieldNRows, uT = w.rawcolliderset_coHeightfieldNCols, fT = w.rawcolliderset_coParent, pT = w.rawcolliderset_coSetEnabled, AT = w.rawcolliderset_coIsEnabled, gT = w.rawcolliderset_coSetContactSkin, _T = w.rawcolliderset_coContactSkin, mT = w.rawcolliderset_coFriction, wT = w.rawcolliderset_coRestitution, bT = w.rawcolliderset_coDensity, yT = w.rawcolliderset_coMass, xT = w.rawcolliderset_coVolume, vT = w.rawcolliderset_coCollisionGroups, ET = w.rawcolliderset_coSolverGroups, ST = w.rawcolliderset_coActiveHooks, CT = w.rawcolliderset_coActiveCollisionTypes, IT = w.rawcolliderset_coActiveEvents, MT = w.rawcolliderset_coContactForceEventThreshold, TT = w.rawcolliderset_coContainsPoint, RT = w.rawcolliderset_coCastShape, BT = w.rawcolliderset_coCastCollider, DT = w.rawcolliderset_coIntersectsShape, PT = w.rawcolliderset_coContactShape, FT = w.rawcolliderset_coContactCollider, LT = w.rawcolliderset_coProjectPoint, kT = w.rawcolliderset_coIntersectsRay, NT = w.rawcolliderset_coCastRay, UT = w.rawcolliderset_coCastRayAndGetNormal, QT = w.rawcolliderset_coSetSensor, OT = w.rawcolliderset_coSetRestitution, zT = w.rawcolliderset_coSetFriction, GT = w.rawcolliderset_coFrictionCombineRule, HT = w.rawcolliderset_coSetFrictionCombineRule, VT = w.rawcolliderset_coRestitutionCombineRule, WT = w.rawcolliderset_coSetRestitutionCombineRule, jT = w.rawcolliderset_coSetCollisionGroups, qT = w.rawcolliderset_coSetSolverGroups, XT = w.rawcolliderset_coSetActiveHooks, YT = w.rawcolliderset_coSetActiveEvents, KT = w.rawcolliderset_coSetActiveCollisionTypes, JT = w.rawcolliderset_coSetShape, ZT = w.rawcolliderset_coSetContactForceEventThreshold, $T = w.rawcolliderset_coSetDensity, tR = w.rawcolliderset_coSetMass, eR = w.rawcolliderset_coSetMassProperties, iR = w.__wbg_rawcolliderset_free, nR = w.rawcolliderset_new, rR = w.rawcolliderset_len, sR = w.rawcolliderset_contains, aR = w.rawcolliderset_createCollider, oR = w.rawcolliderset_remove, cR = w.rawcolliderset_forEachColliderHandle, lR = w.__wbg_rawshapecontact_free, hR = w.__wbg_rawnarrowphase_free, dR = w.rawnarrowphase_new, uR = w.rawnarrowphase_contact_pairs_with, fR = w.rawnarrowphase_contact_pair, pR = w.rawnarrowphase_intersection_pairs_with, AR = w.rawnarrowphase_intersection_pair, gR = w.__wbg_rawcontactmanifold_free, _R = w.rawcontactpair_collider1, mR = w.rawcontactpair_collider2, wR = w.rawcontactpair_numContactManifolds, bR = w.rawcontactpair_contactManifold, yR = w.rawcontactmanifold_normal, xR = w.rawcontactmanifold_local_n1, vR = w.rawcontactmanifold_local_n2, ER = w.rawcontactmanifold_subshape1, SR = w.rawcontactmanifold_subshape2, CR = w.rawcontactmanifold_num_contacts, IR = w.rawcontactmanifold_contact_local_p1, MR = w.rawcontactmanifold_contact_local_p2, TR = w.rawcontactmanifold_contact_dist, RR = w.rawcontactmanifold_contact_fid1, BR = w.rawcontactmanifold_contact_fid2, DR = w.rawcontactmanifold_contact_impulse, PR = w.rawcontactmanifold_contact_tangent_impulse_x, FR = w.rawcontactmanifold_contact_tangent_impulse_y, LR = w.rawcontactmanifold_num_solver_contacts, kR = w.rawcontactmanifold_solver_contact_point, NR = w.rawcontactmanifold_solver_contact_dist, UR = w.rawcontactmanifold_solver_contact_friction, QR = w.rawcontactmanifold_solver_contact_restitution, OR = w.rawcontactmanifold_solver_contact_tangent_velocity, zR = w.__wbg_rawpointprojection_free, GR = w.rawpointprojection_point, HR = w.rawpointprojection_isInside, VR = w.__wbg_rawpointcolliderprojection_free, WR = w.rawpointcolliderprojection_colliderHandle, jR = w.rawpointcolliderprojection_point, qR = w.rawpointcolliderprojection_isInside, XR = w.rawpointcolliderprojection_featureType, YR = w.rawpointcolliderprojection_featureId, KR = w.__wbg_rawrayintersection_free, JR = w.__wbg_rawraycolliderhit_free, ZR = w.__wbg_rawshape_free, $R = w.rawshape_cuboid, tB = w.rawshape_roundCuboid, eB = w.rawshape_ball, iB = w.rawshape_halfspace, nB = w.rawshape_capsule, rB = w.rawshape_cylinder, sB = w.rawshape_roundCylinder, aB = w.rawshape_cone, oB = w.rawshape_roundCone, cB = w.rawshape_polyline, lB = w.rawshape_trimesh, hB = w.rawshape_heightfield, dB = w.rawshape_segment, uB = w.rawshape_triangle, fB = w.rawshape_roundTriangle, pB = w.rawshape_convexHull, AB = w.rawshape_roundConvexHull, gB = w.rawshape_convexMesh, _B = w.rawshape_roundConvexMesh, mB = w.rawshape_castShape, wB = w.rawshape_intersectsShape, bB = w.rawshape_contactShape, yB = w.rawshape_containsPoint, xB = w.rawshape_projectPoint, vB = w.rawshape_intersectsRay, EB = w.rawshape_castRay, SB = w.rawshape_castRayAndGetNormal, CB = w.__wbg_rawshapecasthit_free, IB = w.rawshapecasthit_witness1, MB = w.rawshapecasthit_normal1, TB = w.rawshapecasthit_normal2, RB = w.__wbg_rawcollidershapecasthit_free, BB = w.rawcollidershapecasthit_time_of_impact, DB = w.rawcollidershapecasthit_witness1, PB = w.rawcollidershapecasthit_witness2, FB = w.rawrotation_new, LB = w.rawrotation_identity, kB = w.rawrotation_x, NB = w.rawrotation_w, UB = w.rawvector_zero, QB = w.rawvector_new, OB = w.rawvector_set_x, zB = w.rawvector_set_z, GB = w.rawvector_xyz, HB = w.rawvector_yxz, VB = w.rawvector_zxy, WB = w.rawvector_xzy, jB = w.rawvector_yzx, qB = w.rawvector_zyx, XB = w.rawsdpmatrix3_elements, YB = w.__wbg_rawdebugrenderpipeline_free, KB = w.rawdebugrenderpipeline_new, JB = w.rawdebugrenderpipeline_vertices, ZB = w.rawdebugrenderpipeline_colors, $B = w.rawdebugrenderpipeline_render, t1 = w.__wbg_raweventqueue_free, e1 = w.__wbg_rawcontactforceevent_free, i1 = w.rawcontactforceevent_collider2, n1 = w.rawcontactforceevent_total_force, r1 = w.rawcontactforceevent_total_force_magnitude, s1 = w.rawcontactforceevent_max_force_direction, a1 = w.rawcontactforceevent_max_force_magnitude, o1 = w.raweventqueue_new, c1 = w.raweventqueue_drainCollisionEvents, l1 = w.raweventqueue_drainContactForceEvents, h1 = w.raweventqueue_clear, d1 = w.__wbg_rawphysicspipeline_free, u1 = w.rawphysicspipeline_new, f1 = w.rawphysicspipeline_step, p1 = w.rawphysicspipeline_stepWithEvents, A1 = w.rawquerypipeline_new, g1 = w.rawquerypipeline_update, _1 = w.rawquerypipeline_castRay, m1 = w.rawquerypipeline_castRayAndGetNormal, w1 = w.rawquerypipeline_intersectionsWithRay, b1 = w.rawquerypipeline_intersectionWithShape, y1 = w.rawquerypipeline_projectPoint, x1 = w.rawquerypipeline_projectPointAndGetFeature, v1 = w.rawquerypipeline_intersectionsWithPoint, E1 = w.rawquerypipeline_castShape, S1 = w.rawquerypipeline_intersectionsWithShape, C1 = w.rawquerypipeline_collidersWithAabbIntersectingAabb, I1 = w.__wbg_rawdeserializedworld_free, M1 = w.rawdeserializedworld_takeGravity, T1 = w.rawdeserializedworld_takeIntegrationParameters, R1 = w.rawdeserializedworld_takeIslandManager, B1 = w.rawdeserializedworld_takeBroadPhase, D1 = w.rawdeserializedworld_takeNarrowPhase, P1 = w.rawdeserializedworld_takeBodies, F1 = w.rawdeserializedworld_takeColliders, L1 = w.rawdeserializedworld_takeImpulseJoints, k1 = w.rawdeserializedworld_takeMultibodyJoints, N1 = w.__wbg_rawserializationpipeline_free, U1 = w.rawserializationpipeline_new, Q1 = w.rawserializationpipeline_serializeAll, O1 = w.rawserializationpipeline_deserializeAll, z1 = w.rawkinematiccharactercontroller_offset, G1 = w.rawintegrationparameters_minIslandSize, H1 = w.rawrigidbodyset_len, V1 = w.rawshapecontact_distance, W1 = w.rawrayintersection_featureType, j1 = w.rawraycolliderintersection_colliderHandle, q1 = w.rawrayintersection_time_of_impact, X1 = w.rawraycolliderintersection_featureType, Y1 = w.rawraycolliderhit_colliderHandle, K1 = w.rawraycolliderintersection_time_of_impact, J1 = w.rawcollidershapecasthit_colliderHandle, Z1 = w.rawraycolliderhit_timeOfImpact, $1 = w.rawshapecasthit_time_of_impact, tD = w.rawrotation_y, eD = w.rawrotation_z, iD = w.rawvector_x, nD = w.rawvector_y, rD = w.rawvector_z, sD = w.rawcontactforceevent_collider1, aD = w.rawintegrationparameters_normalizedPredictionDistance, oD = w.rawcolliderset_isHandleValid, cD = w.rawrayintersection_featureId, lD = w.rawraycolliderintersection_featureId, hD = w.rawkinematiccharactercontroller_up, dD = w.rawshapecontact_normal2, uD = w.rawshapecontact_point1, fD = w.rawshapecontact_point2, pD = w.rawrayintersection_normal, AD = w.rawraycolliderintersection_normal, gD = w.rawshapecontact_normal1, _D = w.rawcollidershapecasthit_normal1, mD = w.rawcollidershapecasthit_normal2, wD = w.rawshapecasthit_witness2, bD = w.__wbg_rawcontactpair_free, yD = w.__wbg_rawraycolliderintersection_free, xD = w.__wbg_rawrotation_free, vD = w.__wbg_rawvector_free, ED = w.__wbg_rawsdpmatrix3_free, SD = w.__wbg_rawquerypipeline_free, CD = w.rawvector_set_y, ID = w.__wbindgen_export_0, MD = w.__wbindgen_add_to_stack_pointer, TD = w.__wbindgen_export_1, RD = w.__wbindgen_export_2, BD = Object.freeze(Object.defineProperty({
        __proto__: null,
        __wbg_rawbroadphase_free: OM,
        __wbg_rawccdsolver_free: qS,
        __wbg_rawcharactercollision_free: TE,
        __wbg_rawcolliderset_free: iR,
        __wbg_rawcollidershapecasthit_free: RB,
        __wbg_rawcontactforceevent_free: e1,
        __wbg_rawcontactmanifold_free: gR,
        __wbg_rawcontactpair_free: bD,
        __wbg_rawdebugrenderpipeline_free: YB,
        __wbg_rawdeserializedworld_free: I1,
        __wbg_rawdynamicraycastvehiclecontroller_free: KE,
        __wbg_raweventqueue_free: t1,
        __wbg_rawgenericjoint_free: XC,
        __wbg_rawimpulsejointset_free: pC,
        __wbg_rawintegrationparameters_free: xC,
        __wbg_rawislandmanager_free: WC,
        __wbg_rawkinematiccharactercontroller_free: iE,
        __wbg_rawmultibodyjointset_free: uI,
        __wbg_rawnarrowphase_free: hR,
        __wbg_rawphysicspipeline_free: d1,
        __wbg_rawpidcontroller_free: QE,
        __wbg_rawpointcolliderprojection_free: VR,
        __wbg_rawpointprojection_free: zR,
        __wbg_rawquerypipeline_free: SD,
        __wbg_rawraycolliderhit_free: JR,
        __wbg_rawraycolliderintersection_free: yD,
        __wbg_rawrayintersection_free: KR,
        __wbg_rawrigidbodyset_free: PM,
        __wbg_rawrotation_free: xD,
        __wbg_rawsdpmatrix3_free: ED,
        __wbg_rawserializationpipeline_free: N1,
        __wbg_rawshape_free: ZR,
        __wbg_rawshapecasthit_free: CB,
        __wbg_rawshapecontact_free: lR,
        __wbg_rawvector_free: vD,
        __wbindgen_add_to_stack_pointer: MD,
        __wbindgen_export_0: ID,
        __wbindgen_export_1: TD,
        __wbindgen_export_2: RD,
        memory: tE,
        rawbroadphase_new: zM,
        rawccdsolver_new: XS,
        rawcharactercollision_handle: BE,
        rawcharactercollision_new: RE,
        rawcharactercollision_toi: FE,
        rawcharactercollision_translationDeltaApplied: DE,
        rawcharactercollision_translationDeltaRemaining: PE,
        rawcharactercollision_worldNormal1: NE,
        rawcharactercollision_worldNormal2: UE,
        rawcharactercollision_worldWitness1: LE,
        rawcharactercollision_worldWitness2: kE,
        rawcolliderset_coActiveCollisionTypes: CT,
        rawcolliderset_coActiveEvents: IT,
        rawcolliderset_coActiveHooks: ST,
        rawcolliderset_coCastCollider: BT,
        rawcolliderset_coCastRay: NT,
        rawcolliderset_coCastRayAndGetNormal: UT,
        rawcolliderset_coCastShape: RT,
        rawcolliderset_coCollisionGroups: vT,
        rawcolliderset_coContactCollider: FT,
        rawcolliderset_coContactForceEventThreshold: MT,
        rawcolliderset_coContactShape: PT,
        rawcolliderset_coContactSkin: _T,
        rawcolliderset_coContainsPoint: TT,
        rawcolliderset_coDensity: bT,
        rawcolliderset_coFriction: mT,
        rawcolliderset_coFrictionCombineRule: GT,
        rawcolliderset_coHalfExtents: JM,
        rawcolliderset_coHalfHeight: eT,
        rawcolliderset_coHalfspaceNormal: KM,
        rawcolliderset_coHeightFieldFlags: cT,
        rawcolliderset_coHeightfieldHeights: lT,
        rawcolliderset_coHeightfieldNCols: uT,
        rawcolliderset_coHeightfieldNRows: dT,
        rawcolliderset_coHeightfieldScale: hT,
        rawcolliderset_coIndices: aT,
        rawcolliderset_coIntersectsRay: kT,
        rawcolliderset_coIntersectsShape: DT,
        rawcolliderset_coIsEnabled: AT,
        rawcolliderset_coIsSensor: XM,
        rawcolliderset_coMass: yT,
        rawcolliderset_coParent: fT,
        rawcolliderset_coProjectPoint: LT,
        rawcolliderset_coRadius: $M,
        rawcolliderset_coRestitution: wT,
        rawcolliderset_coRestitutionCombineRule: VT,
        rawcolliderset_coRotation: HM,
        rawcolliderset_coRoundRadius: nT,
        rawcolliderset_coSetActiveCollisionTypes: KT,
        rawcolliderset_coSetActiveEvents: YT,
        rawcolliderset_coSetActiveHooks: XT,
        rawcolliderset_coSetCollisionGroups: jT,
        rawcolliderset_coSetContactForceEventThreshold: ZT,
        rawcolliderset_coSetContactSkin: gT,
        rawcolliderset_coSetDensity: $T,
        rawcolliderset_coSetEnabled: pT,
        rawcolliderset_coSetFriction: zT,
        rawcolliderset_coSetFrictionCombineRule: HT,
        rawcolliderset_coSetHalfExtents: ZM,
        rawcolliderset_coSetHalfHeight: iT,
        rawcolliderset_coSetMass: tR,
        rawcolliderset_coSetMassProperties: eR,
        rawcolliderset_coSetRadius: tT,
        rawcolliderset_coSetRestitution: OT,
        rawcolliderset_coSetRestitutionCombineRule: WT,
        rawcolliderset_coSetRotation: jM,
        rawcolliderset_coSetRotationWrtParent: qM,
        rawcolliderset_coSetRoundRadius: rT,
        rawcolliderset_coSetSensor: QT,
        rawcolliderset_coSetShape: JT,
        rawcolliderset_coSetSolverGroups: qT,
        rawcolliderset_coSetTranslation: VM,
        rawcolliderset_coSetTranslationWrtParent: WM,
        rawcolliderset_coShapeType: YM,
        rawcolliderset_coSolverGroups: ET,
        rawcolliderset_coTranslation: GM,
        rawcolliderset_coTriMeshFlags: oT,
        rawcolliderset_coVertices: sT,
        rawcolliderset_coVolume: xT,
        rawcolliderset_contains: sR,
        rawcolliderset_createCollider: aR,
        rawcolliderset_forEachColliderHandle: cR,
        rawcolliderset_isHandleValid: oD,
        rawcolliderset_len: rR,
        rawcolliderset_new: nR,
        rawcolliderset_remove: oR,
        rawcollidershapecasthit_colliderHandle: J1,
        rawcollidershapecasthit_normal1: _D,
        rawcollidershapecasthit_normal2: mD,
        rawcollidershapecasthit_time_of_impact: BB,
        rawcollidershapecasthit_witness1: DB,
        rawcollidershapecasthit_witness2: PB,
        rawcontactforceevent_collider1: sD,
        rawcontactforceevent_collider2: i1,
        rawcontactforceevent_max_force_direction: s1,
        rawcontactforceevent_max_force_magnitude: a1,
        rawcontactforceevent_total_force: n1,
        rawcontactforceevent_total_force_magnitude: r1,
        rawcontactmanifold_contact_dist: TR,
        rawcontactmanifold_contact_fid1: RR,
        rawcontactmanifold_contact_fid2: BR,
        rawcontactmanifold_contact_impulse: DR,
        rawcontactmanifold_contact_local_p1: IR,
        rawcontactmanifold_contact_local_p2: MR,
        rawcontactmanifold_contact_tangent_impulse_x: PR,
        rawcontactmanifold_contact_tangent_impulse_y: FR,
        rawcontactmanifold_local_n1: xR,
        rawcontactmanifold_local_n2: vR,
        rawcontactmanifold_normal: yR,
        rawcontactmanifold_num_contacts: CR,
        rawcontactmanifold_num_solver_contacts: LR,
        rawcontactmanifold_solver_contact_dist: NR,
        rawcontactmanifold_solver_contact_friction: UR,
        rawcontactmanifold_solver_contact_point: kR,
        rawcontactmanifold_solver_contact_restitution: QR,
        rawcontactmanifold_solver_contact_tangent_velocity: OR,
        rawcontactmanifold_subshape1: ER,
        rawcontactmanifold_subshape2: SR,
        rawcontactpair_collider1: _R,
        rawcontactpair_collider2: mR,
        rawcontactpair_contactManifold: bR,
        rawcontactpair_numContactManifolds: wR,
        rawdebugrenderpipeline_colors: ZB,
        rawdebugrenderpipeline_new: KB,
        rawdebugrenderpipeline_render: $B,
        rawdebugrenderpipeline_vertices: JB,
        rawdeserializedworld_takeBodies: P1,
        rawdeserializedworld_takeBroadPhase: B1,
        rawdeserializedworld_takeColliders: F1,
        rawdeserializedworld_takeGravity: M1,
        rawdeserializedworld_takeImpulseJoints: L1,
        rawdeserializedworld_takeIntegrationParameters: T1,
        rawdeserializedworld_takeIslandManager: R1,
        rawdeserializedworld_takeMultibodyJoints: k1,
        rawdeserializedworld_takeNarrowPhase: D1,
        rawdynamicraycastvehiclecontroller_add_wheel: rS,
        rawdynamicraycastvehiclecontroller_chassis: $E,
        rawdynamicraycastvehiclecontroller_current_vehicle_speed: ZE,
        rawdynamicraycastvehiclecontroller_index_forward_axis: iS,
        rawdynamicraycastvehiclecontroller_index_up_axis: tS,
        rawdynamicraycastvehiclecontroller_new: JE,
        rawdynamicraycastvehiclecontroller_num_wheels: sS,
        rawdynamicraycastvehiclecontroller_set_index_forward_axis: nS,
        rawdynamicraycastvehiclecontroller_set_index_up_axis: eS,
        rawdynamicraycastvehiclecontroller_set_wheel_axle_cs: DS,
        rawdynamicraycastvehiclecontroller_set_wheel_brake: ES,
        rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs: cS,
        rawdynamicraycastvehiclecontroller_set_wheel_direction_cs: RS,
        rawdynamicraycastvehiclecontroller_set_wheel_engine_force: MS,
        rawdynamicraycastvehiclecontroller_set_wheel_friction_slip: FS,
        rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force: xS,
        rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel: uS,
        rawdynamicraycastvehiclecontroller_set_wheel_radius: pS,
        rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness: kS,
        rawdynamicraycastvehiclecontroller_set_wheel_steering: CS,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression: mS,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation: bS,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length: hS,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness: gS,
        rawdynamicraycastvehiclecontroller_update_vehicle: aS,
        rawdynamicraycastvehiclecontroller_wheel_axle_cs: BS,
        rawdynamicraycastvehiclecontroller_wheel_brake: vS,
        rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs: oS,
        rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws: zS,
        rawdynamicraycastvehiclecontroller_wheel_contact_point_ws: GS,
        rawdynamicraycastvehiclecontroller_wheel_direction_cs: TS,
        rawdynamicraycastvehiclecontroller_wheel_engine_force: IS,
        rawdynamicraycastvehiclecontroller_wheel_forward_impulse: US,
        rawdynamicraycastvehiclecontroller_wheel_friction_slip: PS,
        rawdynamicraycastvehiclecontroller_wheel_ground_object: jS,
        rawdynamicraycastvehiclecontroller_wheel_hard_point_ws: VS,
        rawdynamicraycastvehiclecontroller_wheel_is_in_contact: WS,
        rawdynamicraycastvehiclecontroller_wheel_max_suspension_force: yS,
        rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel: dS,
        rawdynamicraycastvehiclecontroller_wheel_radius: fS,
        rawdynamicraycastvehiclecontroller_wheel_rotation: NS,
        rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness: LS,
        rawdynamicraycastvehiclecontroller_wheel_side_impulse: QS,
        rawdynamicraycastvehiclecontroller_wheel_steering: SS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_compression: _S,
        rawdynamicraycastvehiclecontroller_wheel_suspension_force: OS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_length: HS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation: wS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length: lS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness: AS,
        raweventqueue_clear: h1,
        raweventqueue_drainCollisionEvents: c1,
        raweventqueue_drainContactForceEvents: l1,
        raweventqueue_new: o1,
        rawgenericjoint_fixed: tI,
        rawgenericjoint_generic: YC,
        rawgenericjoint_prismatic: $C,
        rawgenericjoint_revolute: eI,
        rawgenericjoint_rope: JC,
        rawgenericjoint_spherical: ZC,
        rawgenericjoint_spring: KC,
        rawimpulsejointset_contains: wC,
        rawimpulsejointset_createJoint: gC,
        rawimpulsejointset_forEachJointAttachedToRigidBody: yC,
        rawimpulsejointset_forEachJointHandle: bC,
        rawimpulsejointset_jointAnchor1: tC,
        rawimpulsejointset_jointAnchor2: eC,
        rawimpulsejointset_jointBodyHandle1: KS,
        rawimpulsejointset_jointBodyHandle2: JS,
        rawimpulsejointset_jointConfigureMotor: fC,
        rawimpulsejointset_jointConfigureMotorModel: hC,
        rawimpulsejointset_jointConfigureMotorPosition: uC,
        rawimpulsejointset_jointConfigureMotorVelocity: dC,
        rawimpulsejointset_jointContactsEnabled: rC,
        rawimpulsejointset_jointFrameX1: ZS,
        rawimpulsejointset_jointFrameX2: $S,
        rawimpulsejointset_jointLimitsEnabled: aC,
        rawimpulsejointset_jointLimitsMax: cC,
        rawimpulsejointset_jointLimitsMin: oC,
        rawimpulsejointset_jointSetAnchor1: iC,
        rawimpulsejointset_jointSetAnchor2: nC,
        rawimpulsejointset_jointSetContactsEnabled: sC,
        rawimpulsejointset_jointSetLimits: lC,
        rawimpulsejointset_jointType: YS,
        rawimpulsejointset_len: mC,
        rawimpulsejointset_new: AC,
        rawimpulsejointset_remove: _C,
        rawintegrationparameters_contact_erp: SC,
        rawintegrationparameters_dt: EC,
        rawintegrationparameters_lengthUnit: BC,
        rawintegrationparameters_maxCcdSubsteps: RC,
        rawintegrationparameters_minIslandSize: G1,
        rawintegrationparameters_new: vC,
        rawintegrationparameters_normalizedAllowedLinearError: CC,
        rawintegrationparameters_normalizedPredictionDistance: aD,
        rawintegrationparameters_numAdditionalFrictionIterations: MC,
        rawintegrationparameters_numInternalPgsIterations: TC,
        rawintegrationparameters_numSolverIterations: IC,
        rawintegrationparameters_set_contact_natural_frequency: PC,
        rawintegrationparameters_set_dt: DC,
        rawintegrationparameters_set_lengthUnit: zC,
        rawintegrationparameters_set_maxCcdSubsteps: OC,
        rawintegrationparameters_set_minIslandSize: QC,
        rawintegrationparameters_set_normalizedAllowedLinearError: FC,
        rawintegrationparameters_set_normalizedPredictionDistance: LC,
        rawintegrationparameters_set_numAdditionalFrictionIterations: NC,
        rawintegrationparameters_set_numInternalPgsIterations: UC,
        rawintegrationparameters_set_numSolverIterations: kC,
        rawintegrationparameters_switchToSmallStepsPgsSolver: HC,
        rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart: VC,
        rawintegrationparameters_switchToStandardPgsSolver: GC,
        rawislandmanager_forEachActiveRigidBodyHandle: qC,
        rawislandmanager_new: jC,
        rawkinematiccharactercontroller_autostepEnabled: fE,
        rawkinematiccharactercontroller_autostepIncludesDynamicBodies: uE,
        rawkinematiccharactercontroller_autostepMaxHeight: hE,
        rawkinematiccharactercontroller_autostepMinWidth: dE,
        rawkinematiccharactercontroller_computeColliderMovement: EE,
        rawkinematiccharactercontroller_computedCollision: ME,
        rawkinematiccharactercontroller_computedGrounded: CE,
        rawkinematiccharactercontroller_computedMovement: SE,
        rawkinematiccharactercontroller_disableAutostep: AE,
        rawkinematiccharactercontroller_disableSnapToGround: xE,
        rawkinematiccharactercontroller_enableAutostep: pE,
        rawkinematiccharactercontroller_enableSnapToGround: yE,
        rawkinematiccharactercontroller_maxSlopeClimbAngle: gE,
        rawkinematiccharactercontroller_minSlopeSlideAngle: mE,
        rawkinematiccharactercontroller_new: nE,
        rawkinematiccharactercontroller_normalNudgeFactor: sE,
        rawkinematiccharactercontroller_numComputedCollisions: IE,
        rawkinematiccharactercontroller_offset: z1,
        rawkinematiccharactercontroller_setMaxSlopeClimbAngle: _E,
        rawkinematiccharactercontroller_setMinSlopeSlideAngle: wE,
        rawkinematiccharactercontroller_setNormalNudgeFactor: aE,
        rawkinematiccharactercontroller_setOffset: oE,
        rawkinematiccharactercontroller_setSlideEnabled: lE,
        rawkinematiccharactercontroller_setUp: rE,
        rawkinematiccharactercontroller_slideEnabled: cE,
        rawkinematiccharactercontroller_snapToGroundDistance: bE,
        rawkinematiccharactercontroller_snapToGroundEnabled: vE,
        rawkinematiccharactercontroller_up: hD,
        rawmultibodyjointset_contains: gI,
        rawmultibodyjointset_createJoint: pI,
        rawmultibodyjointset_forEachJointAttachedToRigidBody: mI,
        rawmultibodyjointset_forEachJointHandle: _I,
        rawmultibodyjointset_jointAnchor1: sI,
        rawmultibodyjointset_jointAnchor2: aI,
        rawmultibodyjointset_jointContactsEnabled: oI,
        rawmultibodyjointset_jointFrameX1: nI,
        rawmultibodyjointset_jointFrameX2: rI,
        rawmultibodyjointset_jointLimitsEnabled: lI,
        rawmultibodyjointset_jointLimitsMax: dI,
        rawmultibodyjointset_jointLimitsMin: hI,
        rawmultibodyjointset_jointSetContactsEnabled: cI,
        rawmultibodyjointset_jointType: iI,
        rawmultibodyjointset_new: fI,
        rawmultibodyjointset_remove: AI,
        rawnarrowphase_contact_pair: fR,
        rawnarrowphase_contact_pairs_with: uR,
        rawnarrowphase_intersection_pair: AR,
        rawnarrowphase_intersection_pairs_with: pR,
        rawnarrowphase_new: dR,
        rawphysicspipeline_new: u1,
        rawphysicspipeline_step: f1,
        rawphysicspipeline_stepWithEvents: p1,
        rawpidcontroller_angular_correction: YE,
        rawpidcontroller_apply_angular_correction: qE,
        rawpidcontroller_apply_linear_correction: jE,
        rawpidcontroller_linear_correction: XE,
        rawpidcontroller_new: OE,
        rawpidcontroller_reset_integrals: WE,
        rawpidcontroller_set_axes_mask: VE,
        rawpidcontroller_set_kd: HE,
        rawpidcontroller_set_ki: GE,
        rawpidcontroller_set_kp: zE,
        rawpointcolliderprojection_colliderHandle: WR,
        rawpointcolliderprojection_featureId: YR,
        rawpointcolliderprojection_featureType: XR,
        rawpointcolliderprojection_isInside: qR,
        rawpointcolliderprojection_point: jR,
        rawpointprojection_isInside: HR,
        rawpointprojection_point: GR,
        rawquerypipeline_castRay: _1,
        rawquerypipeline_castRayAndGetNormal: m1,
        rawquerypipeline_castShape: E1,
        rawquerypipeline_collidersWithAabbIntersectingAabb: C1,
        rawquerypipeline_intersectionWithShape: b1,
        rawquerypipeline_intersectionsWithPoint: v1,
        rawquerypipeline_intersectionsWithRay: w1,
        rawquerypipeline_intersectionsWithShape: S1,
        rawquerypipeline_new: A1,
        rawquerypipeline_projectPoint: y1,
        rawquerypipeline_projectPointAndGetFeature: x1,
        rawquerypipeline_update: g1,
        rawraycolliderhit_colliderHandle: Y1,
        rawraycolliderhit_timeOfImpact: Z1,
        rawraycolliderintersection_colliderHandle: j1,
        rawraycolliderintersection_featureId: lD,
        rawraycolliderintersection_featureType: X1,
        rawraycolliderintersection_normal: AD,
        rawraycolliderintersection_time_of_impact: K1,
        rawrayintersection_featureId: cD,
        rawrayintersection_featureType: W1,
        rawrayintersection_normal: pD,
        rawrayintersection_time_of_impact: q1,
        rawrigidbodyset_contains: NM,
        rawrigidbodyset_createRigidBody: LM,
        rawrigidbodyset_forEachRigidBodyHandle: UM,
        rawrigidbodyset_len: H1,
        rawrigidbodyset_new: FM,
        rawrigidbodyset_propagateModifiedBodyPositionsToColliders: QM,
        rawrigidbodyset_rbAddForce: yM,
        rawrigidbodyset_rbAddForceAtPoint: SM,
        rawrigidbodyset_rbAddTorque: vM,
        rawrigidbodyset_rbAdditionalSolverIterations: IM,
        rawrigidbodyset_rbAngularDamping: uM,
        rawrigidbodyset_rbAngvel: kI,
        rawrigidbodyset_rbApplyImpulse: xM,
        rawrigidbodyset_rbApplyImpulseAtPoint: CM,
        rawrigidbodyset_rbApplyTorqueImpulse: EM,
        rawrigidbodyset_rbBodyType: aM,
        rawrigidbodyset_rbCollider: sM,
        rawrigidbodyset_rbDominanceGroup: zI,
        rawrigidbodyset_rbEffectiveAngularInertia: tM,
        rawrigidbodyset_rbEffectiveInvMass: qI,
        rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt: $I,
        rawrigidbodyset_rbEnableCcd: HI,
        rawrigidbodyset_rbGravityScale: _M,
        rawrigidbodyset_rbInvMass: jI,
        rawrigidbodyset_rbInvPrincipalInertiaSqrt: KI,
        rawrigidbodyset_rbIsCcdEnabled: iM,
        rawrigidbodyset_rbIsDynamic: hM,
        rawrigidbodyset_rbIsEnabled: gM,
        rawrigidbodyset_rbIsFixed: cM,
        rawrigidbodyset_rbIsKinematic: lM,
        rawrigidbodyset_rbIsMoving: vI,
        rawrigidbodyset_rbIsSleeping: xI,
        rawrigidbodyset_rbLinearDamping: dM,
        rawrigidbodyset_rbLinvel: LI,
        rawrigidbodyset_rbLocalCom: XI,
        rawrigidbodyset_rbLockRotations: QI,
        rawrigidbodyset_rbLockTranslations: NI,
        rawrigidbodyset_rbMass: WI,
        rawrigidbodyset_rbNextRotation: SI,
        rawrigidbodyset_rbNextTranslation: EI,
        rawrigidbodyset_rbNumColliders: rM,
        rawrigidbodyset_rbPrincipalInertia: ZI,
        rawrigidbodyset_rbPrincipalInertiaLocalFrame: JI,
        rawrigidbodyset_rbRecomputeMassPropertiesFromColliders: DI,
        rawrigidbodyset_rbResetForces: wM,
        rawrigidbodyset_rbResetTorques: bM,
        rawrigidbodyset_rbRotation: bI,
        rawrigidbodyset_rbSetAdditionalMass: PI,
        rawrigidbodyset_rbSetAdditionalMassProperties: FI,
        rawrigidbodyset_rbSetAdditionalSolverIterations: MM,
        rawrigidbodyset_rbSetAngularDamping: pM,
        rawrigidbodyset_rbSetAngvel: TI,
        rawrigidbodyset_rbSetBodyType: oM,
        rawrigidbodyset_rbSetDominanceGroup: GI,
        rawrigidbodyset_rbSetEnabled: AM,
        rawrigidbodyset_rbSetEnabledRotations: OI,
        rawrigidbodyset_rbSetEnabledTranslations: UI,
        rawrigidbodyset_rbSetGravityScale: mM,
        rawrigidbodyset_rbSetLinearDamping: fM,
        rawrigidbodyset_rbSetLinvel: MI,
        rawrigidbodyset_rbSetNextKinematicRotation: BI,
        rawrigidbodyset_rbSetNextKinematicTranslation: RI,
        rawrigidbodyset_rbSetRotation: II,
        rawrigidbodyset_rbSetSoftCcdPrediction: VI,
        rawrigidbodyset_rbSetTranslation: CI,
        rawrigidbodyset_rbSetUserData: RM,
        rawrigidbodyset_rbSleep: yI,
        rawrigidbodyset_rbSoftCcdPrediction: nM,
        rawrigidbodyset_rbTranslation: wI,
        rawrigidbodyset_rbUserData: TM,
        rawrigidbodyset_rbUserForce: BM,
        rawrigidbodyset_rbUserTorque: DM,
        rawrigidbodyset_rbWakeUp: eM,
        rawrigidbodyset_rbWorldCom: YI,
        rawrigidbodyset_remove: kM,
        rawrotation_identity: LB,
        rawrotation_new: FB,
        rawrotation_w: NB,
        rawrotation_x: kB,
        rawrotation_y: tD,
        rawrotation_z: eD,
        rawsdpmatrix3_elements: XB,
        rawserializationpipeline_deserializeAll: O1,
        rawserializationpipeline_new: U1,
        rawserializationpipeline_serializeAll: Q1,
        rawshape_ball: eB,
        rawshape_capsule: nB,
        rawshape_castRay: EB,
        rawshape_castRayAndGetNormal: SB,
        rawshape_castShape: mB,
        rawshape_cone: aB,
        rawshape_contactShape: bB,
        rawshape_containsPoint: yB,
        rawshape_convexHull: pB,
        rawshape_convexMesh: gB,
        rawshape_cuboid: $R,
        rawshape_cylinder: rB,
        rawshape_halfspace: iB,
        rawshape_heightfield: hB,
        rawshape_intersectsRay: vB,
        rawshape_intersectsShape: wB,
        rawshape_polyline: cB,
        rawshape_projectPoint: xB,
        rawshape_roundCone: oB,
        rawshape_roundConvexHull: AB,
        rawshape_roundConvexMesh: _B,
        rawshape_roundCuboid: tB,
        rawshape_roundCylinder: sB,
        rawshape_roundTriangle: fB,
        rawshape_segment: dB,
        rawshape_triangle: uB,
        rawshape_trimesh: lB,
        rawshapecasthit_normal1: MB,
        rawshapecasthit_normal2: TB,
        rawshapecasthit_time_of_impact: $1,
        rawshapecasthit_witness1: IB,
        rawshapecasthit_witness2: wD,
        rawshapecontact_distance: V1,
        rawshapecontact_normal1: gD,
        rawshapecontact_normal2: dD,
        rawshapecontact_point1: uD,
        rawshapecontact_point2: fD,
        rawvector_new: QB,
        rawvector_set_x: OB,
        rawvector_set_y: CD,
        rawvector_set_z: zB,
        rawvector_x: iD,
        rawvector_xyz: GB,
        rawvector_xzy: WB,
        rawvector_y: nD,
        rawvector_yxz: HB,
        rawvector_yzx: jB,
        rawvector_z: rD,
        rawvector_zero: UB,
        rawvector_zxy: VB,
        rawvector_zyx: qB,
        version: eE
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      bv(BD);
      class cA {
        constructor(t, e, i) {
          this.x = t, this.y = e, this.z = i;
        }
      }
      class k {
        static new(t, e, i) {
          return new cA(t, e, i);
        }
        static intoRaw(t) {
          return new N(t.x, t.y, t.z);
        }
        static zeros() {
          return k.new(0, 0, 0);
        }
        static fromRaw(t) {
          if (!t) return null;
          let e = k.new(t.x, t.y, t.z);
          return t.free(), e;
        }
        static copy(t, e) {
          t.x = e.x, t.y = e.y, t.z = e.z;
        }
      }
      class ph {
        constructor(t, e, i, n) {
          this.x = t, this.y = e, this.z = i, this.w = n;
        }
      }
      class Gt {
        static identity() {
          return new ph(0, 0, 0, 1);
        }
        static fromRaw(t) {
          if (!t) return null;
          let e = new ph(t.x, t.y, t.z, t.w);
          return t.free(), e;
        }
        static intoRaw(t) {
          return new Yt(t.x, t.y, t.z, t.w);
        }
        static copy(t, e) {
          t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w;
        }
      }
      class lA {
        get m11() {
          return this.elements[0];
        }
        get m12() {
          return this.elements[1];
        }
        get m21() {
          return this.m12;
        }
        get m13() {
          return this.elements[2];
        }
        get m31() {
          return this.m13;
        }
        get m22() {
          return this.elements[3];
        }
        get m23() {
          return this.elements[4];
        }
        get m32() {
          return this.m23;
        }
        get m33() {
          return this.elements[5];
        }
        constructor(t) {
          this.elements = t;
        }
      }
      class Ah {
        static fromRaw(t) {
          const e = new lA(t.elements());
          return t.free(), e;
        }
      }
      var ji;
      (function(s) {
        s[s.Dynamic = 0] = "Dynamic", s[s.Fixed = 1] = "Fixed", s[s.KinematicPositionBased = 2] = "KinematicPositionBased", s[s.KinematicVelocityBased = 3] = "KinematicVelocityBased";
      })(ji || (ji = {}));
      class gh {
        constructor(t, e, i) {
          this.rawSet = t, this.colliderSet = e, this.handle = i;
        }
        finalizeDeserialization(t) {
          this.colliderSet = t;
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        lockTranslations(t, e) {
          return this.rawSet.rbLockTranslations(this.handle, t, e);
        }
        lockRotations(t, e) {
          return this.rawSet.rbLockRotations(this.handle, t, e);
        }
        setEnabledTranslations(t, e, i, n) {
          return this.rawSet.rbSetEnabledTranslations(this.handle, t, e, i, n);
        }
        restrictTranslations(t, e, i, n) {
          this.setEnabledTranslations(t, e, i, n);
        }
        setEnabledRotations(t, e, i, n) {
          return this.rawSet.rbSetEnabledRotations(this.handle, t, e, i, n);
        }
        restrictRotations(t, e, i, n) {
          this.setEnabledRotations(t, e, i, n);
        }
        dominanceGroup() {
          return this.rawSet.rbDominanceGroup(this.handle);
        }
        setDominanceGroup(t) {
          this.rawSet.rbSetDominanceGroup(this.handle, t);
        }
        additionalSolverIterations() {
          return this.rawSet.rbAdditionalSolverIterations(this.handle);
        }
        setAdditionalSolverIterations(t) {
          this.rawSet.rbSetAdditionalSolverIterations(this.handle, t);
        }
        enableCcd(t) {
          this.rawSet.rbEnableCcd(this.handle, t);
        }
        setSoftCcdPrediction(t) {
          this.rawSet.rbSetSoftCcdPrediction(this.handle, t);
        }
        softCcdPrediction() {
          return this.rawSet.rbSoftCcdPrediction(this.handle);
        }
        translation() {
          let t = this.rawSet.rbTranslation(this.handle);
          return k.fromRaw(t);
        }
        rotation() {
          let t = this.rawSet.rbRotation(this.handle);
          return Gt.fromRaw(t);
        }
        nextTranslation() {
          let t = this.rawSet.rbNextTranslation(this.handle);
          return k.fromRaw(t);
        }
        nextRotation() {
          let t = this.rawSet.rbNextRotation(this.handle);
          return Gt.fromRaw(t);
        }
        setTranslation(t, e) {
          this.rawSet.rbSetTranslation(this.handle, t.x, t.y, t.z, e);
        }
        setLinvel(t, e) {
          let i = k.intoRaw(t);
          this.rawSet.rbSetLinvel(this.handle, i, e), i.free();
        }
        gravityScale() {
          return this.rawSet.rbGravityScale(this.handle);
        }
        setGravityScale(t, e) {
          this.rawSet.rbSetGravityScale(this.handle, t, e);
        }
        setRotation(t, e) {
          this.rawSet.rbSetRotation(this.handle, t.x, t.y, t.z, t.w, e);
        }
        setAngvel(t, e) {
          let i = k.intoRaw(t);
          this.rawSet.rbSetAngvel(this.handle, i, e), i.free();
        }
        setNextKinematicTranslation(t) {
          this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);
        }
        setNextKinematicRotation(t) {
          this.rawSet.rbSetNextKinematicRotation(this.handle, t.x, t.y, t.z, t.w);
        }
        linvel() {
          return k.fromRaw(this.rawSet.rbLinvel(this.handle));
        }
        angvel() {
          return k.fromRaw(this.rawSet.rbAngvel(this.handle));
        }
        mass() {
          return this.rawSet.rbMass(this.handle);
        }
        effectiveInvMass() {
          return k.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
        }
        invMass() {
          return this.rawSet.rbInvMass(this.handle);
        }
        localCom() {
          return k.fromRaw(this.rawSet.rbLocalCom(this.handle));
        }
        worldCom() {
          return k.fromRaw(this.rawSet.rbWorldCom(this.handle));
        }
        invPrincipalInertiaSqrt() {
          return k.fromRaw(this.rawSet.rbInvPrincipalInertiaSqrt(this.handle));
        }
        principalInertia() {
          return k.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));
        }
        principalInertiaLocalFrame() {
          return Gt.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));
        }
        effectiveWorldInvInertiaSqrt() {
          return Ah.fromRaw(this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle));
        }
        effectiveAngularInertia() {
          return Ah.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));
        }
        sleep() {
          this.rawSet.rbSleep(this.handle);
        }
        wakeUp() {
          this.rawSet.rbWakeUp(this.handle);
        }
        isCcdEnabled() {
          return this.rawSet.rbIsCcdEnabled(this.handle);
        }
        numColliders() {
          return this.rawSet.rbNumColliders(this.handle);
        }
        collider(t) {
          return this.colliderSet.get(this.rawSet.rbCollider(this.handle, t));
        }
        setEnabled(t) {
          this.rawSet.rbSetEnabled(this.handle, t);
        }
        isEnabled() {
          return this.rawSet.rbIsEnabled(this.handle);
        }
        bodyType() {
          return this.rawSet.rbBodyType(this.handle);
        }
        setBodyType(t, e) {
          return this.rawSet.rbSetBodyType(this.handle, t, e);
        }
        isSleeping() {
          return this.rawSet.rbIsSleeping(this.handle);
        }
        isMoving() {
          return this.rawSet.rbIsMoving(this.handle);
        }
        isFixed() {
          return this.rawSet.rbIsFixed(this.handle);
        }
        isKinematic() {
          return this.rawSet.rbIsKinematic(this.handle);
        }
        isDynamic() {
          return this.rawSet.rbIsDynamic(this.handle);
        }
        linearDamping() {
          return this.rawSet.rbLinearDamping(this.handle);
        }
        angularDamping() {
          return this.rawSet.rbAngularDamping(this.handle);
        }
        setLinearDamping(t) {
          this.rawSet.rbSetLinearDamping(this.handle, t);
        }
        recomputeMassPropertiesFromColliders() {
          this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
        }
        setAdditionalMass(t, e) {
          this.rawSet.rbSetAdditionalMass(this.handle, t, e);
        }
        setAdditionalMassProperties(t, e, i, n, r) {
          let a = k.intoRaw(e), o = k.intoRaw(i), c = Gt.intoRaw(n);
          this.rawSet.rbSetAdditionalMassProperties(this.handle, t, a, o, c, r), a.free(), o.free(), c.free();
        }
        setAngularDamping(t) {
          this.rawSet.rbSetAngularDamping(this.handle, t);
        }
        resetForces(t) {
          this.rawSet.rbResetForces(this.handle, t);
        }
        resetTorques(t) {
          this.rawSet.rbResetTorques(this.handle, t);
        }
        addForce(t, e) {
          const i = k.intoRaw(t);
          this.rawSet.rbAddForce(this.handle, i, e), i.free();
        }
        applyImpulse(t, e) {
          const i = k.intoRaw(t);
          this.rawSet.rbApplyImpulse(this.handle, i, e), i.free();
        }
        addTorque(t, e) {
          const i = k.intoRaw(t);
          this.rawSet.rbAddTorque(this.handle, i, e), i.free();
        }
        applyTorqueImpulse(t, e) {
          const i = k.intoRaw(t);
          this.rawSet.rbApplyTorqueImpulse(this.handle, i, e), i.free();
        }
        addForceAtPoint(t, e, i) {
          const n = k.intoRaw(t), r = k.intoRaw(e);
          this.rawSet.rbAddForceAtPoint(this.handle, n, r, i), n.free(), r.free();
        }
        applyImpulseAtPoint(t, e, i) {
          const n = k.intoRaw(t), r = k.intoRaw(e);
          this.rawSet.rbApplyImpulseAtPoint(this.handle, n, r, i), n.free(), r.free();
        }
        userForce() {
          return k.fromRaw(this.rawSet.rbUserForce(this.handle));
        }
        userTorque() {
          return k.fromRaw(this.rawSet.rbUserTorque(this.handle));
        }
      }
      class rn {
        constructor(t) {
          this.enabled = true, this.status = t, this.translation = k.zeros(), this.rotation = Gt.identity(), this.gravityScale = 1, this.linvel = k.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = k.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = k.zeros(), this.principalAngularInertia = k.zeros(), this.angularInertiaLocalFrame = Gt.identity(), this.translationsEnabledZ = true, this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.softCcdPrediction = 0, this.dominanceGroup = 0, this.additionalSolverIterations = 0;
        }
        static dynamic() {
          return new rn(ji.Dynamic);
        }
        static kinematicPositionBased() {
          return new rn(ji.KinematicPositionBased);
        }
        static kinematicVelocityBased() {
          return new rn(ji.KinematicVelocityBased);
        }
        static fixed() {
          return new rn(ji.Fixed);
        }
        static newDynamic() {
          return new rn(ji.Dynamic);
        }
        static newKinematicPositionBased() {
          return new rn(ji.KinematicPositionBased);
        }
        static newKinematicVelocityBased() {
          return new rn(ji.KinematicVelocityBased);
        }
        static newStatic() {
          return new rn(ji.Fixed);
        }
        setDominanceGroup(t) {
          return this.dominanceGroup = t, this;
        }
        setAdditionalSolverIterations(t) {
          return this.additionalSolverIterations = t, this;
        }
        setEnabled(t) {
          return this.enabled = t, this;
        }
        setTranslation(t, e, i) {
          if (typeof t != "number" || typeof e != "number" || typeof i != "number") throw TypeError("The translation components must be numbers.");
          return this.translation = {
            x: t,
            y: e,
            z: i
          }, this;
        }
        setRotation(t) {
          return Gt.copy(this.rotation, t), this;
        }
        setGravityScale(t) {
          return this.gravityScale = t, this;
        }
        setAdditionalMass(t) {
          return this.mass = t, this.massOnly = true, this;
        }
        setLinvel(t, e, i) {
          if (typeof t != "number" || typeof e != "number" || typeof i != "number") throw TypeError("The linvel components must be numbers.");
          return this.linvel = {
            x: t,
            y: e,
            z: i
          }, this;
        }
        setAngvel(t) {
          return k.copy(this.angvel, t), this;
        }
        setAdditionalMassProperties(t, e, i, n) {
          return this.mass = t, k.copy(this.centerOfMass, e), k.copy(this.principalAngularInertia, i), Gt.copy(this.angularInertiaLocalFrame, n), this.massOnly = false, this;
        }
        enabledTranslations(t, e, i) {
          return this.translationsEnabledX = t, this.translationsEnabledY = e, this.translationsEnabledZ = i, this;
        }
        restrictTranslations(t, e, i) {
          return this.enabledTranslations(t, e, i);
        }
        lockTranslations() {
          return this.enabledTranslations(false, false, false);
        }
        enabledRotations(t, e, i) {
          return this.rotationsEnabledX = t, this.rotationsEnabledY = e, this.rotationsEnabledZ = i, this;
        }
        restrictRotations(t, e, i) {
          return this.enabledRotations(t, e, i);
        }
        lockRotations() {
          return this.restrictRotations(false, false, false);
        }
        setLinearDamping(t) {
          return this.linearDamping = t, this;
        }
        setAngularDamping(t) {
          return this.angularDamping = t, this;
        }
        setCanSleep(t) {
          return this.canSleep = t, this;
        }
        setSleeping(t) {
          return this.sleeping = t, this;
        }
        setCcdEnabled(t) {
          return this.ccdEnabled = t, this;
        }
        setSoftCcdPrediction(t) {
          return this.softCcdPrediction = t, this;
        }
        setUserData(t) {
          return this.userData = t, this;
        }
      }
      class hc {
        constructor() {
          this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array(), this.size = 0;
        }
        set(t, e) {
          let i = this.index(t);
          for (; this.data.length <= i; ) this.data.push(null);
          this.data[i] == null && (this.size += 1), this.data[i] = e;
        }
        len() {
          return this.size;
        }
        delete(t) {
          let e = this.index(t);
          e < this.data.length && (this.data[e] != null && (this.size -= 1), this.data[e] = null);
        }
        clear() {
          this.data = new Array();
        }
        get(t) {
          let e = this.index(t);
          return e < this.data.length ? this.data[e] : null;
        }
        forEach(t) {
          for (const e of this.data) e != null && t(e);
        }
        getAll() {
          return this.data.filter((t) => t != null);
        }
        index(t) {
          return this.fconv[0] = t, this.uconv[0];
        }
      }
      class hA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(t) {
          this.raw = t || new ve(), this.map = new hc(), t && t.forEachRigidBodyHandle((e) => {
            this.map.set(e, new gh(t, null, e));
          });
        }
        finalizeDeserialization(t) {
          this.map.forEach((e) => e.finalizeDeserialization(t));
        }
        createRigidBody(t, e) {
          let i = k.intoRaw(e.translation), n = Gt.intoRaw(e.rotation), r = k.intoRaw(e.linvel), a = k.intoRaw(e.centerOfMass), o = k.intoRaw(e.angvel), c = k.intoRaw(e.principalAngularInertia), l = Gt.intoRaw(e.angularInertiaLocalFrame), h = this.raw.createRigidBody(e.enabled, i, n, e.gravityScale, e.mass, e.massOnly, a, r, o, c, l, e.translationsEnabledX, e.translationsEnabledY, e.translationsEnabledZ, e.rotationsEnabledX, e.rotationsEnabledY, e.rotationsEnabledZ, e.linearDamping, e.angularDamping, e.status, e.canSleep, e.sleeping, e.softCcdPrediction, e.ccdEnabled, e.dominanceGroup, e.additionalSolverIterations);
          i.free(), n.free(), r.free(), a.free(), o.free(), c.free(), l.free();
          const d = new gh(this.raw, t, h);
          return d.userData = e.userData, this.map.set(h, d), d;
        }
        remove(t, e, i, n, r) {
          for (let a = 0; a < this.raw.rbNumColliders(t); a += 1) i.unmap(this.raw.rbCollider(t, a));
          n.forEachJointHandleAttachedToRigidBody(t, (a) => n.unmap(a)), r.forEachJointHandleAttachedToRigidBody(t, (a) => r.unmap(a)), this.raw.remove(t, e.raw, i.raw, n.raw, r.raw), this.map.delete(t);
        }
        len() {
          return this.map.len();
        }
        contains(t) {
          return this.get(t) != null;
        }
        get(t) {
          return this.map.get(t);
        }
        forEach(t) {
          this.map.forEach(t);
        }
        forEachActiveRigidBody(t, e) {
          t.forEachActiveRigidBodyHandle((i) => {
            e(this.get(i));
          });
        }
        getAll() {
          return this.map.getAll();
        }
      }
      class dA {
        constructor(t) {
          this.raw = t || new xr();
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        get dt() {
          return this.raw.dt;
        }
        get contact_erp() {
          return this.raw.contact_erp;
        }
        get lengthUnit() {
          return this.raw.lengthUnit;
        }
        get normalizedAllowedLinearError() {
          return this.raw.normalizedAllowedLinearError;
        }
        get normalizedPredictionDistance() {
          return this.raw.normalizedPredictionDistance;
        }
        get numSolverIterations() {
          return this.raw.numSolverIterations;
        }
        get numAdditionalFrictionIterations() {
          return this.raw.numAdditionalFrictionIterations;
        }
        get numInternalPgsIterations() {
          return this.raw.numInternalPgsIterations;
        }
        get minIslandSize() {
          return this.raw.minIslandSize;
        }
        get maxCcdSubsteps() {
          return this.raw.maxCcdSubsteps;
        }
        set dt(t) {
          this.raw.dt = t;
        }
        set contact_natural_frequency(t) {
          this.raw.contact_natural_frequency = t;
        }
        set lengthUnit(t) {
          this.raw.lengthUnit = t;
        }
        set normalizedAllowedLinearError(t) {
          this.raw.normalizedAllowedLinearError = t;
        }
        set normalizedPredictionDistance(t) {
          this.raw.normalizedPredictionDistance = t;
        }
        set numSolverIterations(t) {
          this.raw.numSolverIterations = t;
        }
        set numAdditionalFrictionIterations(t) {
          this.raw.numAdditionalFrictionIterations = t;
        }
        set numInternalPgsIterations(t) {
          this.raw.numInternalPgsIterations = t;
        }
        set minIslandSize(t) {
          this.raw.minIslandSize = t;
        }
        set maxCcdSubsteps(t) {
          this.raw.maxCcdSubsteps = t;
        }
        switchToStandardPgsSolver() {
          this.raw.switchToStandardPgsSolver();
        }
        switchToSmallStepsPgsSolver() {
          this.raw.switchToSmallStepsPgsSolver();
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();
        }
      }
      var ei;
      (function(s) {
        s[s.Revolute = 0] = "Revolute", s[s.Fixed = 1] = "Fixed", s[s.Prismatic = 2] = "Prismatic", s[s.Rope = 3] = "Rope", s[s.Spring = 4] = "Spring", s[s.Spherical = 5] = "Spherical", s[s.Generic = 6] = "Generic";
      })(ei || (ei = {}));
      var _h;
      (function(s) {
        s[s.AccelerationBased = 0] = "AccelerationBased", s[s.ForceBased = 1] = "ForceBased";
      })(_h || (_h = {}));
      var mh;
      (function(s) {
        s[s.LinX = 1] = "LinX", s[s.LinY = 2] = "LinY", s[s.LinZ = 4] = "LinZ", s[s.AngX = 8] = "AngX", s[s.AngY = 16] = "AngY", s[s.AngZ = 32] = "AngZ";
      })(mh || (mh = {}));
      class tn {
        constructor(t, e, i) {
          this.rawSet = t, this.bodySet = e, this.handle = i;
        }
        static newTyped(t, e, i) {
          switch (t.jointType(i)) {
            case Xi.Revolute:
              return new gA(t, e, i);
            case Xi.Prismatic:
              return new AA(t, e, i);
            case Xi.Fixed:
              return new uA(t, e, i);
            case Xi.Spring:
              return new pA(t, e, i);
            case Xi.Rope:
              return new fA(t, e, i);
            case Xi.Spherical:
              return new mA(t, e, i);
            case Xi.Generic:
              return new _A(t, e, i);
            default:
              return new tn(t, e, i);
          }
        }
        finalizeDeserialization(t) {
          this.bodySet = t;
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        body1() {
          return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
        }
        body2() {
          return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
        }
        type() {
          return this.rawSet.jointType(this.handle);
        }
        frameX1() {
          return Gt.fromRaw(this.rawSet.jointFrameX1(this.handle));
        }
        frameX2() {
          return Gt.fromRaw(this.rawSet.jointFrameX2(this.handle));
        }
        anchor1() {
          return k.fromRaw(this.rawSet.jointAnchor1(this.handle));
        }
        anchor2() {
          return k.fromRaw(this.rawSet.jointAnchor2(this.handle));
        }
        setAnchor1(t) {
          const e = k.intoRaw(t);
          this.rawSet.jointSetAnchor1(this.handle, e), e.free();
        }
        setAnchor2(t) {
          const e = k.intoRaw(t);
          this.rawSet.jointSetAnchor2(this.handle, e), e.free();
        }
        setContactsEnabled(t) {
          this.rawSet.jointSetContactsEnabled(this.handle, t);
        }
        contactsEnabled() {
          return this.rawSet.jointContactsEnabled(this.handle);
        }
      }
      class fd extends tn {
        limitsEnabled() {
          return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
        }
        limitsMin() {
          return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
        }
        limitsMax() {
          return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
        }
        setLimits(t, e) {
          this.rawSet.jointSetLimits(this.handle, this.rawAxis(), t, e);
        }
        configureMotorModel(t) {
          this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), t);
        }
        configureMotorVelocity(t, e) {
          this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), t, e);
        }
        configureMotorPosition(t, e, i) {
          this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), t, e, i);
        }
        configureMotor(t, e, i, n) {
          this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), t, e, i, n);
        }
      }
      class uA extends tn {
      }
      class fA extends tn {
      }
      class pA extends tn {
      }
      class AA extends fd {
        rawAxis() {
          return rc.LinX;
        }
      }
      class gA extends fd {
        rawAxis() {
          return rc.AngX;
        }
      }
      class _A extends tn {
      }
      class mA extends tn {
      }
      class bn {
        constructor() {
        }
        static fixed(t, e, i, n) {
          let r = new bn();
          return r.anchor1 = t, r.anchor2 = i, r.frame1 = e, r.frame2 = n, r.jointType = ei.Fixed, r;
        }
        static spring(t, e, i, n, r) {
          let a = new bn();
          return a.anchor1 = n, a.anchor2 = r, a.length = t, a.stiffness = e, a.damping = i, a.jointType = ei.Spring, a;
        }
        static rope(t, e, i) {
          let n = new bn();
          return n.anchor1 = e, n.anchor2 = i, n.length = t, n.jointType = ei.Rope, n;
        }
        static generic(t, e, i, n) {
          let r = new bn();
          return r.anchor1 = t, r.anchor2 = e, r.axis = i, r.axesMask = n, r.jointType = ei.Generic, r;
        }
        static spherical(t, e) {
          let i = new bn();
          return i.anchor1 = t, i.anchor2 = e, i.jointType = ei.Spherical, i;
        }
        static prismatic(t, e, i) {
          let n = new bn();
          return n.anchor1 = t, n.anchor2 = e, n.axis = i, n.jointType = ei.Prismatic, n;
        }
        static revolute(t, e, i) {
          let n = new bn();
          return n.anchor1 = t, n.anchor2 = e, n.axis = i, n.jointType = ei.Revolute, n;
        }
        intoRaw() {
          let t = k.intoRaw(this.anchor1), e = k.intoRaw(this.anchor2), i, n, r = false, a = 0, o = 0;
          switch (this.jointType) {
            case ei.Fixed:
              let c = Gt.intoRaw(this.frame1), l = Gt.intoRaw(this.frame2);
              n = Ze.fixed(t, c, e, l), c.free(), l.free();
              break;
            case ei.Spring:
              n = Ze.spring(this.length, this.stiffness, this.damping, t, e);
              break;
            case ei.Rope:
              n = Ze.rope(this.length, t, e);
              break;
            case ei.Prismatic:
              i = k.intoRaw(this.axis), this.limitsEnabled && (r = true, a = this.limits[0], o = this.limits[1]), n = Ze.prismatic(t, e, i, r, a, o), i.free();
              break;
            case ei.Generic:
              i = k.intoRaw(this.axis);
              let h = this.axesMask;
              n = Ze.generic(t, e, i, h);
              break;
            case ei.Spherical:
              n = Ze.spherical(t, e);
              break;
            case ei.Revolute:
              i = k.intoRaw(this.axis), n = Ze.revolute(t, e, i), i.free();
              break;
          }
          return t.free(), e.free(), n;
        }
      }
      class wA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(t) {
          this.raw = t || new Mn(), this.map = new hc(), t && t.forEachJointHandle((e) => {
            this.map.set(e, tn.newTyped(t, null, e));
          });
        }
        finalizeDeserialization(t) {
          this.map.forEach((e) => e.finalizeDeserialization(t));
        }
        createJoint(t, e, i, n, r) {
          const a = e.intoRaw(), o = this.raw.createJoint(a, i, n, r);
          a.free();
          let c = tn.newTyped(this.raw, t, o);
          return this.map.set(o, c), c;
        }
        remove(t, e) {
          this.raw.remove(t, e), this.unmap(t);
        }
        forEachJointHandleAttachedToRigidBody(t, e) {
          this.raw.forEachJointAttachedToRigidBody(t, e);
        }
        unmap(t) {
          this.map.delete(t);
        }
        len() {
          return this.map.len();
        }
        contains(t) {
          return this.get(t) != null;
        }
        get(t) {
          return this.map.get(t);
        }
        forEach(t) {
          this.map.forEach(t);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      class qn {
        constructor(t, e) {
          this.rawSet = t, this.handle = e;
        }
        static newTyped(t, e) {
          switch (t.jointType(e)) {
            case Xi.Revolute:
              return new xA(t, e);
            case Xi.Prismatic:
              return new yA(t, e);
            case Xi.Fixed:
              return new bA(t, e);
            case Xi.Spherical:
              return new vA(t, e);
            default:
              return new qn(t, e);
          }
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        setContactsEnabled(t) {
          this.rawSet.jointSetContactsEnabled(this.handle, t);
        }
        contactsEnabled() {
          return this.rawSet.jointContactsEnabled(this.handle);
        }
      }
      class pd extends qn {
      }
      class bA extends qn {
      }
      class yA extends pd {
        rawAxis() {
          return rc.LinX;
        }
      }
      class xA extends pd {
        rawAxis() {
          return rc.AngX;
        }
      }
      class vA extends qn {
      }
      class EA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(t) {
          this.raw = t || new Rn(), this.map = new hc(), t && t.forEachJointHandle((e) => {
            this.map.set(e, qn.newTyped(this.raw, e));
          });
        }
        createJoint(t, e, i, n) {
          const r = t.intoRaw(), a = this.raw.createJoint(r, e, i, n);
          r.free();
          let o = qn.newTyped(this.raw, a);
          return this.map.set(a, o), o;
        }
        remove(t, e) {
          this.raw.remove(t, e), this.map.delete(t);
        }
        unmap(t) {
          this.map.delete(t);
        }
        len() {
          return this.map.len();
        }
        contains(t) {
          return this.get(t) != null;
        }
        get(t) {
          return this.map.get(t);
        }
        forEach(t) {
          this.map.forEach(t);
        }
        forEachJointHandleAttachedToRigidBody(t, e) {
          this.raw.forEachJointAttachedToRigidBody(t, e);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      var ca;
      (function(s) {
        s[s.Average = 0] = "Average", s[s.Min = 1] = "Min", s[s.Multiply = 2] = "Multiply", s[s.Max = 3] = "Max";
      })(ca || (ca = {}));
      class SA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new fh();
        }
      }
      class CA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new Tn();
        }
        forEachActiveRigidBodyHandle(t) {
          this.raw.forEachActiveRigidBodyHandle(t);
        }
      }
      class IA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new yr();
        }
      }
      class MA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new jn(), this.tempManifold = new TA(null);
        }
        contactPairsWith(t, e) {
          this.raw.contact_pairs_with(t, e);
        }
        intersectionPairsWith(t, e) {
          this.raw.intersection_pairs_with(t, e);
        }
        contactPair(t, e, i) {
          const n = this.raw.contact_pair(t, e);
          if (n) {
            const r = n.collider1() != t;
            let a;
            for (a = 0; a < n.numContactManifolds(); ++a) this.tempManifold.raw = n.contactManifold(a), this.tempManifold.raw && i(this.tempManifold, r), this.tempManifold.free();
            n.free();
          }
        }
        intersectionPair(t, e) {
          return this.raw.intersection_pair(t, e);
        }
      }
      class TA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t;
        }
        normal() {
          return k.fromRaw(this.raw.normal());
        }
        localNormal1() {
          return k.fromRaw(this.raw.local_n1());
        }
        localNormal2() {
          return k.fromRaw(this.raw.local_n2());
        }
        subshape1() {
          return this.raw.subshape1();
        }
        subshape2() {
          return this.raw.subshape2();
        }
        numContacts() {
          return this.raw.num_contacts();
        }
        localContactPoint1(t) {
          return k.fromRaw(this.raw.contact_local_p1(t));
        }
        localContactPoint2(t) {
          return k.fromRaw(this.raw.contact_local_p2(t));
        }
        contactDist(t) {
          return this.raw.contact_dist(t);
        }
        contactFid1(t) {
          return this.raw.contact_fid1(t);
        }
        contactFid2(t) {
          return this.raw.contact_fid2(t);
        }
        contactImpulse(t) {
          return this.raw.contact_impulse(t);
        }
        contactTangentImpulseX(t) {
          return this.raw.contact_tangent_impulse_x(t);
        }
        contactTangentImpulseY(t) {
          return this.raw.contact_tangent_impulse_y(t);
        }
        numSolverContacts() {
          return this.raw.num_solver_contacts();
        }
        solverContactPoint(t) {
          return k.fromRaw(this.raw.solver_contact_point(t));
        }
        solverContactDist(t) {
          return this.raw.solver_contact_dist(t);
        }
        solverContactFriction(t) {
          return this.raw.solver_contact_friction(t);
        }
        solverContactRestitution(t) {
          return this.raw.solver_contact_restitution(t);
        }
        solverContactTangentVelocity(t) {
          return k.fromRaw(this.raw.solver_contact_tangent_velocity(t));
        }
      }
      class ds {
        constructor(t, e, i, n, r) {
          this.distance = t, this.point1 = e, this.point2 = i, this.normal1 = n, this.normal2 = r;
        }
        static fromRaw(t) {
          if (!t) return null;
          const e = new ds(t.distance(), k.fromRaw(t.point1()), k.fromRaw(t.point2()), k.fromRaw(t.normal1()), k.fromRaw(t.normal2()));
          return t.free(), e;
        }
      }
      var us;
      (function(s) {
        s[s.Vertex = 0] = "Vertex", s[s.Edge = 1] = "Edge", s[s.Face = 2] = "Face", s[s.Unknown = 3] = "Unknown";
      })(us || (us = {}));
      class ba {
        constructor(t, e) {
          this.point = t, this.isInside = e;
        }
        static fromRaw(t) {
          if (!t) return null;
          const e = new ba(k.fromRaw(t.point()), t.isInside());
          return t.free(), e;
        }
      }
      class la {
        constructor(t, e, i, n, r) {
          this.featureType = us.Unknown, this.featureId = void 0, this.collider = t, this.point = e, this.isInside = i, r !== void 0 && (this.featureId = r), n !== void 0 && (this.featureType = n);
        }
        static fromRaw(t, e) {
          if (!e) return null;
          const i = new la(t.get(e.colliderHandle()), k.fromRaw(e.point()), e.isInside(), e.featureType(), e.featureId());
          return e.free(), i;
        }
      }
      class DD {
        constructor(t, e) {
          this.origin = t, this.dir = e;
        }
        pointAt(t) {
          return {
            x: this.origin.x + this.dir.x * t,
            y: this.origin.y + this.dir.y * t,
            z: this.origin.z + this.dir.z * t
          };
        }
      }
      class ya {
        constructor(t, e, i, n) {
          this.featureType = us.Unknown, this.featureId = void 0, this.timeOfImpact = t, this.normal = e, n !== void 0 && (this.featureId = n), i !== void 0 && (this.featureType = i);
        }
        static fromRaw(t) {
          if (!t) return null;
          const e = new ya(t.time_of_impact(), k.fromRaw(t.normal()), t.featureType(), t.featureId());
          return t.free(), e;
        }
      }
      class ha {
        constructor(t, e, i, n, r) {
          this.featureType = us.Unknown, this.featureId = void 0, this.collider = t, this.timeOfImpact = e, this.normal = i, r !== void 0 && (this.featureId = r), n !== void 0 && (this.featureType = n);
        }
        static fromRaw(t, e) {
          if (!e) return null;
          const i = new ha(t.get(e.colliderHandle()), e.time_of_impact(), k.fromRaw(e.normal()), e.featureType(), e.featureId());
          return e.free(), i;
        }
      }
      class dc {
        constructor(t, e) {
          this.collider = t, this.timeOfImpact = e;
        }
        static fromRaw(t, e) {
          if (!e) return null;
          const i = new dc(t.get(e.colliderHandle()), e.timeOfImpact());
          return e.free(), i;
        }
      }
      class ms {
        constructor(t, e, i, n, r) {
          this.time_of_impact = t, this.witness1 = e, this.witness2 = i, this.normal1 = n, this.normal2 = r;
        }
        static fromRaw(t, e) {
          if (!e) return null;
          const i = new ms(e.time_of_impact(), k.fromRaw(e.witness1()), k.fromRaw(e.witness2()), k.fromRaw(e.normal1()), k.fromRaw(e.normal2()));
          return e.free(), i;
        }
      }
      class xa extends ms {
        constructor(t, e, i, n, r, a) {
          super(e, i, n, r, a), this.collider = t;
        }
        static fromRaw(t, e) {
          if (!e) return null;
          const i = new xa(t.get(e.colliderHandle()), e.time_of_impact(), k.fromRaw(e.witness1()), k.fromRaw(e.witness2()), k.fromRaw(e.normal1()), k.fromRaw(e.normal2()));
          return e.free(), i;
        }
      }
      class Xe {
        static fromRaw(t, e) {
          const i = t.coShapeType(e);
          let n, r, a, o, c, l, h;
          switch (i) {
            case ti.Ball:
              return new Ad(t.coRadius(e));
            case ti.Cuboid:
              return n = t.coHalfExtents(e), new gd(n.x, n.y, n.z);
            case ti.RoundCuboid:
              return n = t.coHalfExtents(e), r = t.coRoundRadius(e), new _d(n.x, n.y, n.z, r);
            case ti.Capsule:
              return c = t.coHalfHeight(e), l = t.coRadius(e), new md(c, l);
            case ti.Segment:
              return a = t.coVertices(e), new wd(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]));
            case ti.Polyline:
              return a = t.coVertices(e), o = t.coIndices(e), new xd(a, o);
            case ti.Triangle:
              return a = t.coVertices(e), new bd(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]), k.new(a[6], a[7], a[8]));
            case ti.RoundTriangle:
              return a = t.coVertices(e), r = t.coRoundRadius(e), new yd(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]), k.new(a[6], a[7], a[8]), r);
            case ti.HalfSpace:
              return h = k.fromRaw(t.coHalfspaceNormal(e)), new RA(h);
            case ti.TriMesh:
              a = t.coVertices(e), o = t.coIndices(e);
              const d = t.coTriMeshFlags(e);
              return new vd(a, o, d);
            case ti.HeightField:
              const u = t.coHeightfieldScale(e), f = t.coHeightfieldHeights(e), p = t.coHeightfieldNRows(e), m = t.coHeightfieldNCols(e), g = t.coHeightFieldFlags(e);
              return new Ed(p, m, f, u, g);
            case ti.ConvexPolyhedron:
              return a = t.coVertices(e), o = t.coIndices(e), new Go(a, o);
            case ti.RoundConvexPolyhedron:
              return a = t.coVertices(e), o = t.coIndices(e), r = t.coRoundRadius(e), new Ho(a, o, r);
            case ti.Cylinder:
              return c = t.coHalfHeight(e), l = t.coRadius(e), new Sd(c, l);
            case ti.RoundCylinder:
              return c = t.coHalfHeight(e), l = t.coRadius(e), r = t.coRoundRadius(e), new Cd(c, l, r);
            case ti.Cone:
              return c = t.coHalfHeight(e), l = t.coRadius(e), new Id(c, l);
            case ti.RoundCone:
              return c = t.coHalfHeight(e), l = t.coRadius(e), r = t.coRoundRadius(e), new Md(c, l, r);
            default:
              throw new Error("unknown shape type: " + i);
          }
        }
        castShape(t, e, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(t), u = Gt.intoRaw(e), f = k.intoRaw(i), p = k.intoRaw(r), m = Gt.intoRaw(a), g = k.intoRaw(o), A = this.intoRaw(), x = n.intoRaw(), b = ms.fromRaw(null, A.castShape(d, u, f, x, p, m, g, c, l, h));
          return d.free(), u.free(), f.free(), p.free(), m.free(), g.free(), A.free(), x.free(), b;
        }
        intersectsShape(t, e, i, n, r) {
          let a = k.intoRaw(t), o = Gt.intoRaw(e), c = k.intoRaw(n), l = Gt.intoRaw(r), h = this.intoRaw(), d = i.intoRaw(), u = h.intersectsShape(a, o, d, c, l);
          return a.free(), o.free(), c.free(), l.free(), h.free(), d.free(), u;
        }
        contactShape(t, e, i, n, r, a) {
          let o = k.intoRaw(t), c = Gt.intoRaw(e), l = k.intoRaw(n), h = Gt.intoRaw(r), d = this.intoRaw(), u = i.intoRaw(), f = ds.fromRaw(d.contactShape(o, c, u, l, h, a));
          return o.free(), c.free(), l.free(), h.free(), d.free(), u.free(), f;
        }
        containsPoint(t, e, i) {
          let n = k.intoRaw(t), r = Gt.intoRaw(e), a = k.intoRaw(i), o = this.intoRaw(), c = o.containsPoint(n, r, a);
          return n.free(), r.free(), a.free(), o.free(), c;
        }
        projectPoint(t, e, i, n) {
          let r = k.intoRaw(t), a = Gt.intoRaw(e), o = k.intoRaw(i), c = this.intoRaw(), l = ba.fromRaw(c.projectPoint(r, a, o, n));
          return r.free(), a.free(), o.free(), c.free(), l;
        }
        intersectsRay(t, e, i, n) {
          let r = k.intoRaw(e), a = Gt.intoRaw(i), o = k.intoRaw(t.origin), c = k.intoRaw(t.dir), l = this.intoRaw(), h = l.intersectsRay(r, a, o, c, n);
          return r.free(), a.free(), o.free(), c.free(), l.free(), h;
        }
        castRay(t, e, i, n, r) {
          let a = k.intoRaw(e), o = Gt.intoRaw(i), c = k.intoRaw(t.origin), l = k.intoRaw(t.dir), h = this.intoRaw(), d = h.castRay(a, o, c, l, n, r);
          return a.free(), o.free(), c.free(), l.free(), h.free(), d;
        }
        castRayAndGetNormal(t, e, i, n, r) {
          let a = k.intoRaw(e), o = Gt.intoRaw(i), c = k.intoRaw(t.origin), l = k.intoRaw(t.dir), h = this.intoRaw(), d = ya.fromRaw(h.castRayAndGetNormal(a, o, c, l, n, r));
          return a.free(), o.free(), c.free(), l.free(), h.free(), d;
        }
      }
      var Ge;
      (function(s) {
        s[s.Ball = 0] = "Ball", s[s.Cuboid = 1] = "Cuboid", s[s.Capsule = 2] = "Capsule", s[s.Segment = 3] = "Segment", s[s.Polyline = 4] = "Polyline", s[s.Triangle = 5] = "Triangle", s[s.TriMesh = 6] = "TriMesh", s[s.HeightField = 7] = "HeightField", s[s.ConvexPolyhedron = 9] = "ConvexPolyhedron", s[s.Cylinder = 10] = "Cylinder", s[s.Cone = 11] = "Cone", s[s.RoundCuboid = 12] = "RoundCuboid", s[s.RoundTriangle = 13] = "RoundTriangle", s[s.RoundCylinder = 14] = "RoundCylinder", s[s.RoundCone = 15] = "RoundCone", s[s.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron", s[s.HalfSpace = 17] = "HalfSpace";
      })(Ge || (Ge = {}));
      var wh;
      (function(s) {
        s[s.FIX_INTERNAL_EDGES = 1] = "FIX_INTERNAL_EDGES";
      })(wh || (wh = {}));
      var bh;
      (function(s) {
        s[s.DELETE_BAD_TOPOLOGY_TRIANGLES = 4] = "DELETE_BAD_TOPOLOGY_TRIANGLES", s[s.ORIENTED = 8] = "ORIENTED", s[s.MERGE_DUPLICATE_VERTICES = 16] = "MERGE_DUPLICATE_VERTICES", s[s.DELETE_DEGENERATE_TRIANGLES = 32] = "DELETE_DEGENERATE_TRIANGLES", s[s.DELETE_DUPLICATE_TRIANGLES = 64] = "DELETE_DUPLICATE_TRIANGLES", s[s.FIX_INTERNAL_EDGES = 152] = "FIX_INTERNAL_EDGES";
      })(bh || (bh = {}));
      class Ad extends Xe {
        constructor(t) {
          super(), this.type = Ge.Ball, this.radius = t;
        }
        intoRaw() {
          return Bt.ball(this.radius);
        }
      }
      class RA extends Xe {
        constructor(t) {
          super(), this.type = Ge.HalfSpace, this.normal = t;
        }
        intoRaw() {
          let t = k.intoRaw(this.normal), e = Bt.halfspace(t);
          return t.free(), e;
        }
      }
      class gd extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.Cuboid, this.halfExtents = k.new(t, e, i);
        }
        intoRaw() {
          return Bt.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
        }
      }
      class _d extends Xe {
        constructor(t, e, i, n) {
          super(), this.type = Ge.RoundCuboid, this.halfExtents = k.new(t, e, i), this.borderRadius = n;
        }
        intoRaw() {
          return Bt.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
        }
      }
      class md extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.Capsule, this.halfHeight = t, this.radius = e;
        }
        intoRaw() {
          return Bt.capsule(this.halfHeight, this.radius);
        }
      }
      class wd extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.Segment, this.a = t, this.b = e;
        }
        intoRaw() {
          let t = k.intoRaw(this.a), e = k.intoRaw(this.b), i = Bt.segment(t, e);
          return t.free(), e.free(), i;
        }
      }
      class bd extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.Triangle, this.a = t, this.b = e, this.c = i;
        }
        intoRaw() {
          let t = k.intoRaw(this.a), e = k.intoRaw(this.b), i = k.intoRaw(this.c), n = Bt.triangle(t, e, i);
          return t.free(), e.free(), i.free(), n;
        }
      }
      class yd extends Xe {
        constructor(t, e, i, n) {
          super(), this.type = Ge.RoundTriangle, this.a = t, this.b = e, this.c = i, this.borderRadius = n;
        }
        intoRaw() {
          let t = k.intoRaw(this.a), e = k.intoRaw(this.b), i = k.intoRaw(this.c), n = Bt.roundTriangle(t, e, i, this.borderRadius);
          return t.free(), e.free(), i.free(), n;
        }
      }
      class xd extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.Polyline, this.vertices = t, this.indices = e ?? new Uint32Array(0);
        }
        intoRaw() {
          return Bt.polyline(this.vertices, this.indices);
        }
      }
      class vd extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.TriMesh, this.vertices = t, this.indices = e, this.flags = i;
        }
        intoRaw() {
          return Bt.trimesh(this.vertices, this.indices, this.flags);
        }
      }
      class Go extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.ConvexPolyhedron, this.vertices = t, this.indices = e;
        }
        intoRaw() {
          return this.indices ? Bt.convexMesh(this.vertices, this.indices) : Bt.convexHull(this.vertices);
        }
      }
      class Ho extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.RoundConvexPolyhedron, this.vertices = t, this.indices = e, this.borderRadius = i;
        }
        intoRaw() {
          return this.indices ? Bt.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : Bt.roundConvexHull(this.vertices, this.borderRadius);
        }
      }
      class Ed extends Xe {
        constructor(t, e, i, n, r) {
          super(), this.type = Ge.HeightField, this.nrows = t, this.ncols = e, this.heights = i, this.scale = n, this.flags = r;
        }
        intoRaw() {
          let t = k.intoRaw(this.scale), e = Bt.heightfield(this.nrows, this.ncols, this.heights, t, this.flags);
          return t.free(), e;
        }
      }
      class Sd extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.Cylinder, this.halfHeight = t, this.radius = e;
        }
        intoRaw() {
          return Bt.cylinder(this.halfHeight, this.radius);
        }
      }
      class Cd extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.RoundCylinder, this.borderRadius = i, this.halfHeight = t, this.radius = e;
        }
        intoRaw() {
          return Bt.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
        }
      }
      class Id extends Xe {
        constructor(t, e) {
          super(), this.type = Ge.Cone, this.halfHeight = t, this.radius = e;
        }
        intoRaw() {
          return Bt.cone(this.halfHeight, this.radius);
        }
      }
      class Md extends Xe {
        constructor(t, e, i) {
          super(), this.type = Ge.RoundCone, this.halfHeight = t, this.radius = e, this.borderRadius = i;
        }
        intoRaw() {
          return Bt.roundCone(this.halfHeight, this.radius, this.borderRadius);
        }
      }
      class BA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new Tv();
        }
        step(t, e, i, n, r, a, o, c, l, h, d, u) {
          let f = k.intoRaw(t);
          d ? this.raw.stepWithEvents(f, e.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw, h.raw, d.raw, u, u ? u.filterContactPair : null, u ? u.filterIntersectionPair : null) : this.raw.step(f, e.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw, h.raw), f.free();
        }
      }
      var yh;
      (function(s) {
        s[s.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", s[s.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", s[s.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", s[s.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", s[s.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", s[s.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", s[s.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", s[s.ONLY_FIXED = 6] = "ONLY_FIXED";
      })(yh || (yh = {}));
      class DA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new dd();
        }
        update(t) {
          this.raw.update(t.raw);
        }
        castRay(t, e, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i.origin), u = k.intoRaw(i.dir), f = dc.fromRaw(e, this.raw.castRay(t.raw, e.raw, d, u, n, r, a, o, c, l, h));
          return d.free(), u.free(), f;
        }
        castRayAndGetNormal(t, e, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i.origin), u = k.intoRaw(i.dir), f = ha.fromRaw(e, this.raw.castRayAndGetNormal(t.raw, e.raw, d, u, n, r, a, o, c, l, h));
          return d.free(), u.free(), f;
        }
        intersectionsWithRay(t, e, i, n, r, a, o, c, l, h, d) {
          let u = k.intoRaw(i.origin), f = k.intoRaw(i.dir), p = (m) => a(ha.fromRaw(e, m));
          this.raw.intersectionsWithRay(t.raw, e.raw, u, f, n, r, p, o, c, l, h, d), u.free(), f.free();
        }
        intersectionWithShape(t, e, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i), u = Gt.intoRaw(n), f = r.intoRaw(), p = this.raw.intersectionWithShape(t.raw, e.raw, d, u, f, a, o, c, l, h);
          return d.free(), u.free(), f.free(), p;
        }
        projectPoint(t, e, i, n, r, a, o, c, l) {
          let h = k.intoRaw(i), d = la.fromRaw(e, this.raw.projectPoint(t.raw, e.raw, h, n, r, a, o, c, l));
          return h.free(), d;
        }
        projectPointAndGetFeature(t, e, i, n, r, a, o, c) {
          let l = k.intoRaw(i), h = la.fromRaw(e, this.raw.projectPointAndGetFeature(t.raw, e.raw, l, n, r, a, o, c));
          return l.free(), h;
        }
        intersectionsWithPoint(t, e, i, n, r, a, o, c, l) {
          let h = k.intoRaw(i);
          this.raw.intersectionsWithPoint(t.raw, e.raw, h, n, r, a, o, c, l), h.free();
        }
        castShape(t, e, i, n, r, a, o, c, l, h, d, u, f, p) {
          let m = k.intoRaw(i), g = Gt.intoRaw(n), A = k.intoRaw(r), x = a.intoRaw(), b = xa.fromRaw(e, this.raw.castShape(t.raw, e.raw, m, g, A, x, o, c, l, h, d, u, f, p));
          return m.free(), g.free(), A.free(), x.free(), b;
        }
        intersectionsWithShape(t, e, i, n, r, a, o, c, l, h, d) {
          let u = k.intoRaw(i), f = Gt.intoRaw(n), p = r.intoRaw();
          this.raw.intersectionsWithShape(t.raw, e.raw, u, f, p, a, o, c, l, h, d), u.free(), f.free(), p.free();
        }
        collidersWithAabbIntersectingAabb(t, e, i) {
          let n = k.intoRaw(t), r = k.intoRaw(e);
          this.raw.collidersWithAabbIntersectingAabb(n, r, i), n.free(), r.free();
        }
      }
      class xh {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(t) {
          this.raw = t || new Bv();
        }
        serializeAll(t, e, i, n, r, a, o, c, l) {
          let h = k.intoRaw(t);
          const d = this.raw.serializeAll(h, e.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw);
          return h.free(), d;
        }
        deserializeAll(t) {
          return uc.fromRaw(this.raw.deserializeAll(t));
        }
      }
      class PA {
        constructor(t, e) {
          this.vertices = t, this.colors = e;
        }
      }
      class FA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.vertices = void 0, this.colors = void 0;
        }
        constructor(t) {
          this.raw = t || new Cv();
        }
        render(t, e, i, n, r) {
          this.raw.render(t.raw, e.raw, i.raw, n.raw, r.raw), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
        }
      }
      class LA {
      }
      class kA {
        constructor(t, e, i, n, r) {
          this.params = e, this.bodies = i, this.colliders = n, this.queries = r, this.raw = new Mv(t), this.rawCharacterCollision = new aA(), this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
        }
        free() {
          this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = void 0, this.rawCharacterCollision = void 0;
        }
        up() {
          return this.raw.up();
        }
        setUp(t) {
          let e = k.intoRaw(t);
          return this.raw.setUp(e);
        }
        applyImpulsesToDynamicBodies() {
          return this._applyImpulsesToDynamicBodies;
        }
        setApplyImpulsesToDynamicBodies(t) {
          this._applyImpulsesToDynamicBodies = t;
        }
        characterMass() {
          return this._characterMass;
        }
        setCharacterMass(t) {
          this._characterMass = t;
        }
        offset() {
          return this.raw.offset();
        }
        setOffset(t) {
          this.raw.setOffset(t);
        }
        normalNudgeFactor() {
          return this.raw.normalNudgeFactor();
        }
        setNormalNudgeFactor(t) {
          this.raw.setNormalNudgeFactor(t);
        }
        slideEnabled() {
          return this.raw.slideEnabled();
        }
        setSlideEnabled(t) {
          this.raw.setSlideEnabled(t);
        }
        autostepMaxHeight() {
          return this.raw.autostepMaxHeight();
        }
        autostepMinWidth() {
          return this.raw.autostepMinWidth();
        }
        autostepIncludesDynamicBodies() {
          return this.raw.autostepIncludesDynamicBodies();
        }
        autostepEnabled() {
          return this.raw.autostepEnabled();
        }
        enableAutostep(t, e, i) {
          this.raw.enableAutostep(t, e, i);
        }
        disableAutostep() {
          return this.raw.disableAutostep();
        }
        maxSlopeClimbAngle() {
          return this.raw.maxSlopeClimbAngle();
        }
        setMaxSlopeClimbAngle(t) {
          this.raw.setMaxSlopeClimbAngle(t);
        }
        minSlopeSlideAngle() {
          return this.raw.minSlopeSlideAngle();
        }
        setMinSlopeSlideAngle(t) {
          this.raw.setMinSlopeSlideAngle(t);
        }
        snapToGroundDistance() {
          return this.raw.snapToGroundDistance();
        }
        enableSnapToGround(t) {
          this.raw.enableSnapToGround(t);
        }
        disableSnapToGround() {
          this.raw.disableSnapToGround();
        }
        snapToGroundEnabled() {
          return this.raw.snapToGroundEnabled();
        }
        computeColliderMovement(t, e, i, n, r) {
          let a = k.intoRaw(e);
          this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, t.handle, a, this._applyImpulsesToDynamicBodies, this._characterMass, i, n, this.colliders.castClosure(r)), a.free();
        }
        computedMovement() {
          return k.fromRaw(this.raw.computedMovement());
        }
        computedGrounded() {
          return this.raw.computedGrounded();
        }
        numComputedCollisions() {
          return this.raw.numComputedCollisions();
        }
        computedCollision(t, e) {
          if (this.raw.computedCollision(t, this.rawCharacterCollision)) {
            let i = this.rawCharacterCollision;
            return e = e ?? new LA(), e.translationDeltaApplied = k.fromRaw(i.translationDeltaApplied()), e.translationDeltaRemaining = k.fromRaw(i.translationDeltaRemaining()), e.toi = i.toi(), e.witness1 = k.fromRaw(i.worldWitness1()), e.witness2 = k.fromRaw(i.worldWitness2()), e.normal1 = k.fromRaw(i.worldNormal1()), e.normal2 = k.fromRaw(i.worldNormal2()), e.collider = this.colliders.get(i.handle()), e;
          } else return null;
        }
      }
      var vh;
      (function(s) {
        s[s.None = 0] = "None", s[s.LinX = 1] = "LinX", s[s.LinY = 2] = "LinY", s[s.LinZ = 4] = "LinZ", s[s.AngX = 8] = "AngX", s[s.AngY = 16] = "AngY", s[s.AngZ = 32] = "AngZ", s[s.AllLin = 7] = "AllLin", s[s.AllAng = 56] = "AllAng", s[s.All = 63] = "All";
      })(vh || (vh = {}));
      class NA {
        constructor(t, e, i, n, r, a) {
          this.params = t, this.bodies = e, this.raw = new Rv(i, n, r, a);
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        setKp(t, e) {
          this.raw.set_kp(t, e);
        }
        setKi(t, e) {
          this.raw.set_kp(t, e);
        }
        setKd(t, e) {
          this.raw.set_kp(t, e);
        }
        setAxes(t) {
          this.raw.set_axes_mask(t);
        }
        resetIntegrals() {
          this.raw.reset_integrals();
        }
        applyLinearCorrection(t, e, i) {
          let n = k.intoRaw(e), r = k.intoRaw(i);
          this.raw.apply_linear_correction(this.params.dt, this.bodies.raw, t.handle, n, r), n.free(), r.free();
        }
        applyAngularCorrection(t, e, i) {
          let n = Gt.intoRaw(e), r = k.intoRaw(i);
          this.raw.apply_angular_correction(this.params.dt, this.bodies.raw, t.handle, n, r), n.free(), r.free();
        }
        linearCorrection(t, e, i) {
          let n = k.intoRaw(e), r = k.intoRaw(i), a = this.raw.linear_correction(this.params.dt, this.bodies.raw, t.handle, n, r);
          return n.free(), r.free(), k.fromRaw(a);
        }
        angularCorrection(t, e, i) {
          let n = Gt.intoRaw(e), r = k.intoRaw(i), a = this.raw.angular_correction(this.params.dt, this.bodies.raw, t.handle, n, r);
          return n.free(), r.free(), k.fromRaw(a);
        }
      }
      class UA {
        constructor(t, e, i, n) {
          this.raw = new Iv(t.handle), this.bodies = e, this.colliders = i, this.queries = n, this._chassis = t;
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        updateVehicle(t, e, i, n) {
          this.raw.update_vehicle(t, this.bodies.raw, this.colliders.raw, this.queries.raw, e, i, this.colliders.castClosure(n));
        }
        currentVehicleSpeed() {
          return this.raw.current_vehicle_speed();
        }
        chassis() {
          return this._chassis;
        }
        get indexUpAxis() {
          return this.raw.index_up_axis();
        }
        set indexUpAxis(t) {
          this.raw.set_index_up_axis(t);
        }
        get indexForwardAxis() {
          return this.raw.index_forward_axis();
        }
        set setIndexForwardAxis(t) {
          this.raw.set_index_forward_axis(t);
        }
        addWheel(t, e, i, n, r) {
          let a = k.intoRaw(t), o = k.intoRaw(e), c = k.intoRaw(i);
          this.raw.add_wheel(a, o, c, n, r), a.free(), o.free(), c.free();
        }
        numWheels() {
          return this.raw.num_wheels();
        }
        wheelChassisConnectionPointCs(t) {
          return k.fromRaw(this.raw.wheel_chassis_connection_point_cs(t));
        }
        setWheelChassisConnectionPointCs(t, e) {
          let i = k.intoRaw(e);
          this.raw.set_wheel_chassis_connection_point_cs(t, i), i.free();
        }
        wheelSuspensionRestLength(t) {
          return this.raw.wheel_suspension_rest_length(t);
        }
        setWheelSuspensionRestLength(t, e) {
          this.raw.set_wheel_suspension_rest_length(t, e);
        }
        wheelMaxSuspensionTravel(t) {
          return this.raw.wheel_max_suspension_travel(t);
        }
        setWheelMaxSuspensionTravel(t, e) {
          this.raw.set_wheel_max_suspension_travel(t, e);
        }
        wheelRadius(t) {
          return this.raw.wheel_radius(t);
        }
        setWheelRadius(t, e) {
          this.raw.set_wheel_radius(t, e);
        }
        wheelSuspensionStiffness(t) {
          return this.raw.wheel_suspension_stiffness(t);
        }
        setWheelSuspensionStiffness(t, e) {
          this.raw.set_wheel_suspension_stiffness(t, e);
        }
        wheelSuspensionCompression(t) {
          return this.raw.wheel_suspension_compression(t);
        }
        setWheelSuspensionCompression(t, e) {
          this.raw.set_wheel_suspension_compression(t, e);
        }
        wheelSuspensionRelaxation(t) {
          return this.raw.wheel_suspension_relaxation(t);
        }
        setWheelSuspensionRelaxation(t, e) {
          this.raw.set_wheel_suspension_relaxation(t, e);
        }
        wheelMaxSuspensionForce(t) {
          return this.raw.wheel_max_suspension_force(t);
        }
        setWheelMaxSuspensionForce(t, e) {
          this.raw.set_wheel_max_suspension_force(t, e);
        }
        wheelBrake(t) {
          return this.raw.wheel_brake(t);
        }
        setWheelBrake(t, e) {
          this.raw.set_wheel_brake(t, e);
        }
        wheelSteering(t) {
          return this.raw.wheel_steering(t);
        }
        setWheelSteering(t, e) {
          this.raw.set_wheel_steering(t, e);
        }
        wheelEngineForce(t) {
          return this.raw.wheel_engine_force(t);
        }
        setWheelEngineForce(t, e) {
          this.raw.set_wheel_engine_force(t, e);
        }
        wheelDirectionCs(t) {
          return k.fromRaw(this.raw.wheel_direction_cs(t));
        }
        setWheelDirectionCs(t, e) {
          let i = k.intoRaw(e);
          this.raw.set_wheel_direction_cs(t, i), i.free();
        }
        wheelAxleCs(t) {
          return k.fromRaw(this.raw.wheel_axle_cs(t));
        }
        setWheelAxleCs(t, e) {
          let i = k.intoRaw(e);
          this.raw.set_wheel_axle_cs(t, i), i.free();
        }
        wheelFrictionSlip(t) {
          return this.raw.wheel_friction_slip(t);
        }
        setWheelFrictionSlip(t, e) {
          this.raw.set_wheel_friction_slip(t, e);
        }
        wheelSideFrictionStiffness(t) {
          return this.raw.wheel_side_friction_stiffness(t);
        }
        setWheelSideFrictionStiffness(t, e) {
          this.raw.set_wheel_side_friction_stiffness(t, e);
        }
        wheelRotation(t) {
          return this.raw.wheel_rotation(t);
        }
        wheelForwardImpulse(t) {
          return this.raw.wheel_forward_impulse(t);
        }
        wheelSideImpulse(t) {
          return this.raw.wheel_side_impulse(t);
        }
        wheelSuspensionForce(t) {
          return this.raw.wheel_suspension_force(t);
        }
        wheelContactNormal(t) {
          return k.fromRaw(this.raw.wheel_contact_normal_ws(t));
        }
        wheelContactPoint(t) {
          return k.fromRaw(this.raw.wheel_contact_point_ws(t));
        }
        wheelSuspensionLength(t) {
          return this.raw.wheel_suspension_length(t);
        }
        wheelHardPoint(t) {
          return k.fromRaw(this.raw.wheel_hard_point_ws(t));
        }
        wheelIsInContact(t) {
          return this.raw.wheel_is_in_contact(t);
        }
        wheelGroundObject(t) {
          return this.colliders.get(this.raw.wheel_ground_object(t));
        }
      }
      class uc {
        free() {
          this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((t) => t.free()), this.pidControllers.forEach((t) => t.free()), this.vehicleControllers.forEach((t) => t.free()), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.impulseJoints = void 0, this.multibodyJoints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0, this.debugRenderPipeline = void 0, this.characterControllers = void 0, this.pidControllers = void 0, this.vehicleControllers = void 0;
        }
        constructor(t, e, i, n, r, a, o, c, l, h, d, u, f, p) {
          this.gravity = t, this.integrationParameters = new dA(e), this.islands = new CA(i), this.broadPhase = new IA(n), this.narrowPhase = new MA(r), this.bodies = new hA(a), this.colliders = new OA(o), this.impulseJoints = new wA(c), this.multibodyJoints = new EA(l), this.ccdSolver = new SA(h), this.queryPipeline = new DA(d), this.physicsPipeline = new BA(u), this.serializationPipeline = new xh(f), this.debugRenderPipeline = new FA(p), this.characterControllers = /* @__PURE__ */ new Set(), this.pidControllers = /* @__PURE__ */ new Set(), this.vehicleControllers = /* @__PURE__ */ new Set(), this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
        }
        static fromRaw(t) {
          return t ? new uc(k.fromRaw(t.takeGravity()), t.takeIntegrationParameters(), t.takeIslandManager(), t.takeBroadPhase(), t.takeNarrowPhase(), t.takeBodies(), t.takeColliders(), t.takeImpulseJoints(), t.takeMultibodyJoints()) : null;
        }
        takeSnapshot() {
          return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
        }
        static restoreSnapshot(t) {
          return new xh().deserializeAll(t);
        }
        debugRender() {
          return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase), new PA(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
        }
        step(t, e) {
          this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, t, e), this.queryPipeline.update(this.colliders);
        }
        propagateModifiedBodyPositionsToColliders() {
          this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
        }
        updateSceneQueries() {
          this.propagateModifiedBodyPositionsToColliders(), this.queryPipeline.update(this.colliders);
        }
        get timestep() {
          return this.integrationParameters.dt;
        }
        set timestep(t) {
          this.integrationParameters.dt = t;
        }
        get lengthUnit() {
          return this.integrationParameters.lengthUnit;
        }
        set lengthUnit(t) {
          this.integrationParameters.lengthUnit = t;
        }
        get numSolverIterations() {
          return this.integrationParameters.numSolverIterations;
        }
        set numSolverIterations(t) {
          this.integrationParameters.numSolverIterations = t;
        }
        get numAdditionalFrictionIterations() {
          return this.integrationParameters.numAdditionalFrictionIterations;
        }
        set numAdditionalFrictionIterations(t) {
          this.integrationParameters.numAdditionalFrictionIterations = t;
        }
        get numInternalPgsIterations() {
          return this.integrationParameters.numInternalPgsIterations;
        }
        set numInternalPgsIterations(t) {
          this.integrationParameters.numInternalPgsIterations = t;
        }
        switchToStandardPgsSolver() {
          this.integrationParameters.switchToStandardPgsSolver();
        }
        switchToSmallStepsPgsSolver() {
          this.integrationParameters.switchToSmallStepsPgsSolver();
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();
        }
        createRigidBody(t) {
          return this.bodies.createRigidBody(this.colliders, t);
        }
        createCharacterController(t) {
          let e = new kA(t, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
          return this.characterControllers.add(e), e;
        }
        removeCharacterController(t) {
          this.characterControllers.delete(t), t.free();
        }
        createPidController(t, e, i, n) {
          let r = new NA(this.integrationParameters, this.bodies, t, e, i, n);
          return this.pidControllers.add(r), r;
        }
        removePidController(t) {
          this.pidControllers.delete(t), t.free();
        }
        createVehicleController(t) {
          let e = new UA(t, this.bodies, this.colliders, this.queryPipeline);
          return this.vehicleControllers.add(e), e;
        }
        removeVehicleController(t) {
          this.vehicleControllers.delete(t), t.free();
        }
        createCollider(t, e) {
          let i = e ? e.handle : void 0;
          return this.colliders.createCollider(this.bodies, t, i);
        }
        createImpulseJoint(t, e, i, n) {
          return this.impulseJoints.createJoint(this.bodies, t, e.handle, i.handle, n);
        }
        createMultibodyJoint(t, e, i, n) {
          return this.multibodyJoints.createJoint(t, e.handle, i.handle, n);
        }
        getRigidBody(t) {
          return this.bodies.get(t);
        }
        getCollider(t) {
          return this.colliders.get(t);
        }
        getImpulseJoint(t) {
          return this.impulseJoints.get(t);
        }
        getMultibodyJoint(t) {
          return this.multibodyJoints.get(t);
        }
        removeRigidBody(t) {
          this.bodies && this.bodies.remove(t.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
        }
        removeCollider(t, e) {
          this.colliders && this.colliders.remove(t.handle, this.islands, this.bodies, e);
        }
        removeImpulseJoint(t, e) {
          this.impulseJoints && this.impulseJoints.remove(t.handle, e);
        }
        removeMultibodyJoint(t, e) {
          this.impulseJoints && this.multibodyJoints.remove(t.handle, e);
        }
        forEachCollider(t) {
          this.colliders.forEach(t);
        }
        forEachRigidBody(t) {
          this.bodies.forEach(t);
        }
        forEachActiveRigidBody(t) {
          this.bodies.forEachActiveRigidBody(this.islands, t);
        }
        castRay(t, e, i, n, r, a, o, c) {
          return this.queryPipeline.castRay(this.bodies, this.colliders, t, e, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
        }
        castRayAndGetNormal(t, e, i, n, r, a, o, c) {
          return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, t, e, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
        }
        intersectionsWithRay(t, e, i, n, r, a, o, c, l) {
          this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, t, e, i, n, r, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
        }
        intersectionWithShape(t, e, i, n, r, a, o, c) {
          let l = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, t, e, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
          return l != null ? this.colliders.get(l) : null;
        }
        projectPoint(t, e, i, n, r, a, o) {
          return this.queryPipeline.projectPoint(this.bodies, this.colliders, t, e, i, n, r ? r.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
        }
        projectPointAndGetFeature(t, e, i, n, r, a) {
          return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, t, e, i, n ? n.handle : null, r ? r.handle : null, this.colliders.castClosure(a));
        }
        intersectionsWithPoint(t, e, i, n, r, a, o) {
          this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, t, this.colliders.castClosure(e), i, n, r ? r.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
        }
        castShape(t, e, i, n, r, a, o, c, l, h, d, u) {
          return this.queryPipeline.castShape(this.bodies, this.colliders, t, e, i, n, r, a, o, c, l, h ? h.handle : null, d ? d.handle : null, this.colliders.castClosure(u));
        }
        intersectionsWithShape(t, e, i, n, r, a, o, c, l) {
          this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, t, e, i, this.colliders.castClosure(n), r, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
        }
        collidersWithAabbIntersectingAabb(t, e, i) {
          this.queryPipeline.collidersWithAabbIntersectingAabb(t, e, this.colliders.castClosure(i));
        }
        contactPairsWith(t, e) {
          this.narrowPhase.contactPairsWith(t.handle, this.colliders.castClosure(e));
        }
        intersectionPairsWith(t, e) {
          this.narrowPhase.intersectionPairsWith(t.handle, this.colliders.castClosure(e));
        }
        contactPair(t, e, i) {
          this.narrowPhase.contactPair(t.handle, e.handle, i);
        }
        intersectionPair(t, e) {
          return this.narrowPhase.intersectionPair(t.handle, e.handle);
        }
      }
      var Vo;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", s[s.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
      })(Vo || (Vo = {}));
      class QA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        collider1() {
          return this.raw.collider1();
        }
        collider2() {
          return this.raw.collider2();
        }
        totalForce() {
          return k.fromRaw(this.raw.total_force());
        }
        totalForceMagnitude() {
          return this.raw.total_force_magnitude();
        }
        maxForceDirection() {
          return k.fromRaw(this.raw.max_force_direction());
        }
        maxForceMagnitude() {
          return this.raw.max_force_magnitude();
        }
      }
      class PD {
        constructor(t, e) {
          this.raw = e || new oA(t);
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        drainCollisionEvents(t) {
          this.raw.drainCollisionEvents(t);
        }
        drainContactForceEvents(t) {
          let e = new QA();
          this.raw.drainContactForceEvents((i) => {
            e.raw = i, t(e), e.free();
          });
        }
        clear() {
          this.raw.clear();
        }
      }
      var Wo;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", s[s.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
      })(Wo || (Wo = {}));
      var Eh;
      (function(s) {
        s[s.EMPTY = 0] = "EMPTY", s[s.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
      })(Eh || (Eh = {}));
      var jo;
      (function(s) {
        s[s.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", s[s.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", s[s.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", s[s.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", s[s.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", s[s.FIXED_FIXED = 32] = "FIXED_FIXED", s[s.DEFAULT = 15] = "DEFAULT", s[s.ALL = 60943] = "ALL";
      })(jo || (jo = {}));
      class Sh {
        constructor(t, e, i, n) {
          this.colliderSet = t, this.handle = e, this._parent = i, this._shape = n;
        }
        finalizeDeserialization(t) {
          this.handle != null && (this._parent = t.get(this.colliderSet.raw.coParent(this.handle)));
        }
        ensureShapeIsCached() {
          this._shape || (this._shape = Xe.fromRaw(this.colliderSet.raw, this.handle));
        }
        get shape() {
          return this.ensureShapeIsCached(), this._shape;
        }
        isValid() {
          return this.colliderSet.raw.contains(this.handle);
        }
        translation() {
          return k.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
        }
        rotation() {
          return Gt.fromRaw(this.colliderSet.raw.coRotation(this.handle));
        }
        isSensor() {
          return this.colliderSet.raw.coIsSensor(this.handle);
        }
        setSensor(t) {
          this.colliderSet.raw.coSetSensor(this.handle, t);
        }
        setShape(t) {
          let e = t.intoRaw();
          this.colliderSet.raw.coSetShape(this.handle, e), e.free(), this._shape = t;
        }
        setEnabled(t) {
          this.colliderSet.raw.coSetEnabled(this.handle, t);
        }
        isEnabled() {
          return this.colliderSet.raw.coIsEnabled(this.handle);
        }
        setRestitution(t) {
          this.colliderSet.raw.coSetRestitution(this.handle, t);
        }
        setFriction(t) {
          this.colliderSet.raw.coSetFriction(this.handle, t);
        }
        frictionCombineRule() {
          return this.colliderSet.raw.coFrictionCombineRule(this.handle);
        }
        setFrictionCombineRule(t) {
          this.colliderSet.raw.coSetFrictionCombineRule(this.handle, t);
        }
        restitutionCombineRule() {
          return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
        }
        setRestitutionCombineRule(t) {
          this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, t);
        }
        setCollisionGroups(t) {
          this.colliderSet.raw.coSetCollisionGroups(this.handle, t);
        }
        setSolverGroups(t) {
          this.colliderSet.raw.coSetSolverGroups(this.handle, t);
        }
        contactSkin() {
          return this.colliderSet.raw.coContactSkin(this.handle);
        }
        setContactSkin(t) {
          return this.colliderSet.raw.coSetContactSkin(this.handle, t);
        }
        activeHooks() {
          return this.colliderSet.raw.coActiveHooks(this.handle);
        }
        setActiveHooks(t) {
          this.colliderSet.raw.coSetActiveHooks(this.handle, t);
        }
        activeEvents() {
          return this.colliderSet.raw.coActiveEvents(this.handle);
        }
        setActiveEvents(t) {
          this.colliderSet.raw.coSetActiveEvents(this.handle, t);
        }
        activeCollisionTypes() {
          return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
        }
        setContactForceEventThreshold(t) {
          return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, t);
        }
        contactForceEventThreshold() {
          return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
        }
        setActiveCollisionTypes(t) {
          this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, t);
        }
        setDensity(t) {
          this.colliderSet.raw.coSetDensity(this.handle, t);
        }
        setMass(t) {
          this.colliderSet.raw.coSetMass(this.handle, t);
        }
        setMassProperties(t, e, i, n) {
          let r = k.intoRaw(e), a = k.intoRaw(i), o = Gt.intoRaw(n);
          this.colliderSet.raw.coSetMassProperties(this.handle, t, r, a, o), r.free(), a.free(), o.free();
        }
        setTranslation(t) {
          this.colliderSet.raw.coSetTranslation(this.handle, t.x, t.y, t.z);
        }
        setTranslationWrtParent(t) {
          this.colliderSet.raw.coSetTranslationWrtParent(this.handle, t.x, t.y, t.z);
        }
        setRotation(t) {
          this.colliderSet.raw.coSetRotation(this.handle, t.x, t.y, t.z, t.w);
        }
        setRotationWrtParent(t) {
          this.colliderSet.raw.coSetRotationWrtParent(this.handle, t.x, t.y, t.z, t.w);
        }
        shapeType() {
          return this.colliderSet.raw.coShapeType(this.handle);
        }
        halfExtents() {
          return k.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
        }
        setHalfExtents(t) {
          const e = k.intoRaw(t);
          this.colliderSet.raw.coSetHalfExtents(this.handle, e);
        }
        radius() {
          return this.colliderSet.raw.coRadius(this.handle);
        }
        setRadius(t) {
          this.colliderSet.raw.coSetRadius(this.handle, t);
        }
        roundRadius() {
          return this.colliderSet.raw.coRoundRadius(this.handle);
        }
        setRoundRadius(t) {
          this.colliderSet.raw.coSetRoundRadius(this.handle, t);
        }
        halfHeight() {
          return this.colliderSet.raw.coHalfHeight(this.handle);
        }
        setHalfHeight(t) {
          this.colliderSet.raw.coSetHalfHeight(this.handle, t);
        }
        vertices() {
          return this.colliderSet.raw.coVertices(this.handle);
        }
        indices() {
          return this.colliderSet.raw.coIndices(this.handle);
        }
        heightfieldHeights() {
          return this.colliderSet.raw.coHeightfieldHeights(this.handle);
        }
        heightfieldScale() {
          let t = this.colliderSet.raw.coHeightfieldScale(this.handle);
          return k.fromRaw(t);
        }
        heightfieldNRows() {
          return this.colliderSet.raw.coHeightfieldNRows(this.handle);
        }
        heightfieldNCols() {
          return this.colliderSet.raw.coHeightfieldNCols(this.handle);
        }
        parent() {
          return this._parent;
        }
        friction() {
          return this.colliderSet.raw.coFriction(this.handle);
        }
        restitution() {
          return this.colliderSet.raw.coRestitution(this.handle);
        }
        density() {
          return this.colliderSet.raw.coDensity(this.handle);
        }
        mass() {
          return this.colliderSet.raw.coMass(this.handle);
        }
        volume() {
          return this.colliderSet.raw.coVolume(this.handle);
        }
        collisionGroups() {
          return this.colliderSet.raw.coCollisionGroups(this.handle);
        }
        solverGroups() {
          return this.colliderSet.raw.coSolverGroups(this.handle);
        }
        containsPoint(t) {
          let e = k.intoRaw(t), i = this.colliderSet.raw.coContainsPoint(this.handle, e);
          return e.free(), i;
        }
        projectPoint(t, e) {
          let i = k.intoRaw(t), n = ba.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, i, e));
          return i.free(), n;
        }
        intersectsRay(t, e) {
          let i = k.intoRaw(t.origin), n = k.intoRaw(t.dir), r = this.colliderSet.raw.coIntersectsRay(this.handle, i, n, e);
          return i.free(), n.free(), r;
        }
        castShape(t, e, i, n, r, a, o, c) {
          let l = k.intoRaw(t), h = k.intoRaw(i), d = Gt.intoRaw(n), u = k.intoRaw(r), f = e.intoRaw(), p = ms.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, l, f, h, d, u, a, o, c));
          return l.free(), h.free(), d.free(), u.free(), f.free(), p;
        }
        castCollider(t, e, i, n, r, a) {
          let o = k.intoRaw(t), c = k.intoRaw(i), l = xa.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, o, e.handle, c, n, r, a));
          return o.free(), c.free(), l;
        }
        intersectsShape(t, e, i) {
          let n = k.intoRaw(e), r = Gt.intoRaw(i), a = t.intoRaw(), o = this.colliderSet.raw.coIntersectsShape(this.handle, a, n, r);
          return n.free(), r.free(), a.free(), o;
        }
        contactShape(t, e, i, n) {
          let r = k.intoRaw(e), a = Gt.intoRaw(i), o = t.intoRaw(), c = ds.fromRaw(this.colliderSet.raw.coContactShape(this.handle, o, r, a, n));
          return r.free(), a.free(), o.free(), c;
        }
        contactCollider(t, e) {
          return ds.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, t.handle, e));
        }
        castRay(t, e, i) {
          let n = k.intoRaw(t.origin), r = k.intoRaw(t.dir), a = this.colliderSet.raw.coCastRay(this.handle, n, r, e, i);
          return n.free(), r.free(), a;
        }
        castRayAndGetNormal(t, e, i) {
          let n = k.intoRaw(t.origin), r = k.intoRaw(t.dir), a = ya.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, n, r, e, i));
          return n.free(), r.free(), a;
        }
      }
      var pr;
      (function(s) {
        s[s.Density = 0] = "Density", s[s.Mass = 1] = "Mass", s[s.MassProps = 2] = "MassProps";
      })(pr || (pr = {}));
      class Qe {
        constructor(t) {
          this.enabled = true, this.shape = t, this.massPropsMode = pr.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = Gt.identity(), this.translation = k.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = ca.Average, this.restitutionCombineRule = ca.Average, this.activeCollisionTypes = jo.DEFAULT, this.activeEvents = Vo.NONE, this.activeHooks = Wo.NONE, this.mass = 0, this.centerOfMass = k.zeros(), this.contactForceEventThreshold = 0, this.contactSkin = 0, this.principalAngularInertia = k.zeros(), this.angularInertiaLocalFrame = Gt.identity();
        }
        static ball(t) {
          const e = new Ad(t);
          return new Qe(e);
        }
        static capsule(t, e) {
          const i = new md(t, e);
          return new Qe(i);
        }
        static segment(t, e) {
          const i = new wd(t, e);
          return new Qe(i);
        }
        static triangle(t, e, i) {
          const n = new bd(t, e, i);
          return new Qe(n);
        }
        static roundTriangle(t, e, i, n) {
          const r = new yd(t, e, i, n);
          return new Qe(r);
        }
        static polyline(t, e) {
          const i = new xd(t, e);
          return new Qe(i);
        }
        static trimesh(t, e, i) {
          const n = new vd(t, e, i);
          return new Qe(n);
        }
        static cuboid(t, e, i) {
          const n = new gd(t, e, i);
          return new Qe(n);
        }
        static roundCuboid(t, e, i, n) {
          const r = new _d(t, e, i, n);
          return new Qe(r);
        }
        static heightfield(t, e, i, n, r) {
          const a = new Ed(t, e, i, n, r);
          return new Qe(a);
        }
        static cylinder(t, e) {
          const i = new Sd(t, e);
          return new Qe(i);
        }
        static roundCylinder(t, e, i) {
          const n = new Cd(t, e, i);
          return new Qe(n);
        }
        static cone(t, e) {
          const i = new Id(t, e);
          return new Qe(i);
        }
        static roundCone(t, e, i) {
          const n = new Md(t, e, i);
          return new Qe(n);
        }
        static convexHull(t) {
          const e = new Go(t, null);
          return new Qe(e);
        }
        static convexMesh(t, e) {
          const i = new Go(t, e);
          return new Qe(i);
        }
        static roundConvexHull(t, e) {
          const i = new Ho(t, null, e);
          return new Qe(i);
        }
        static roundConvexMesh(t, e, i) {
          const n = new Ho(t, e, i);
          return new Qe(n);
        }
        setTranslation(t, e, i) {
          if (typeof t != "number" || typeof e != "number" || typeof i != "number") throw TypeError("The translation components must be numbers.");
          return this.translation = {
            x: t,
            y: e,
            z: i
          }, this;
        }
        setRotation(t) {
          return Gt.copy(this.rotation, t), this;
        }
        setSensor(t) {
          return this.isSensor = t, this;
        }
        setEnabled(t) {
          return this.enabled = t, this;
        }
        setContactSkin(t) {
          return this.contactSkin = t, this;
        }
        setDensity(t) {
          return this.massPropsMode = pr.Density, this.density = t, this;
        }
        setMass(t) {
          return this.massPropsMode = pr.Mass, this.mass = t, this;
        }
        setMassProperties(t, e, i, n) {
          return this.massPropsMode = pr.MassProps, this.mass = t, k.copy(this.centerOfMass, e), k.copy(this.principalAngularInertia, i), Gt.copy(this.angularInertiaLocalFrame, n), this;
        }
        setRestitution(t) {
          return this.restitution = t, this;
        }
        setFriction(t) {
          return this.friction = t, this;
        }
        setFrictionCombineRule(t) {
          return this.frictionCombineRule = t, this;
        }
        setRestitutionCombineRule(t) {
          return this.restitutionCombineRule = t, this;
        }
        setCollisionGroups(t) {
          return this.collisionGroups = t, this;
        }
        setSolverGroups(t) {
          return this.solverGroups = t, this;
        }
        setActiveHooks(t) {
          return this.activeHooks = t, this;
        }
        setActiveEvents(t) {
          return this.activeEvents = t, this;
        }
        setActiveCollisionTypes(t) {
          return this.activeCollisionTypes = t, this;
        }
        setContactForceEventThreshold(t) {
          return this.contactForceEventThreshold = t, this;
        }
      }
      class OA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(t) {
          this.raw = t || new Me(), this.map = new hc(), t && t.forEachColliderHandle((e) => {
            this.map.set(e, new Sh(this, e, null));
          });
        }
        castClosure(t) {
          return (e) => {
            if (t) return t(this.get(e));
          };
        }
        finalizeDeserialization(t) {
          this.map.forEach((e) => e.finalizeDeserialization(t));
        }
        createCollider(t, e, i) {
          let n = i != null && i != null;
          if (n && isNaN(i)) throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
          let r = e.shape.intoRaw(), a = k.intoRaw(e.translation), o = Gt.intoRaw(e.rotation), c = k.intoRaw(e.centerOfMass), l = k.intoRaw(e.principalAngularInertia), h = Gt.intoRaw(e.angularInertiaLocalFrame), d = this.raw.createCollider(e.enabled, r, a, o, e.massPropsMode, e.mass, c, l, h, e.density, e.friction, e.restitution, e.frictionCombineRule, e.restitutionCombineRule, e.isSensor, e.collisionGroups, e.solverGroups, e.activeCollisionTypes, e.activeHooks, e.activeEvents, e.contactForceEventThreshold, e.contactSkin, n, n ? i : 0, t.raw);
          r.free(), a.free(), o.free(), c.free(), l.free(), h.free();
          let u = n ? t.get(i) : null, f = new Sh(this, d, u, e.shape);
          return this.map.set(d, f), f;
        }
        remove(t, e, i, n) {
          this.raw.remove(t, e.raw, i.raw, n), this.unmap(t);
        }
        unmap(t) {
          this.map.delete(t);
        }
        get(t) {
          return this.map.get(t);
        }
        len() {
          return this.map.len();
        }
        contains(t) {
          return this.get(t) != null;
        }
        forEach(t) {
          this.map.forEach(t);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      function FD() {
        return Ev();
      }
      const li = Object.freeze(Object.defineProperty({
        __proto__: null,
        get ActiveCollisionTypes() {
          return jo;
        },
        get ActiveEvents() {
          return Vo;
        },
        get ActiveHooks() {
          return Wo;
        },
        Ball: Ad,
        BroadPhase: IA,
        CCDSolver: SA,
        Capsule: md,
        CharacterCollision: LA,
        get CoefficientCombineRule() {
          return ca;
        },
        Collider: Sh,
        ColliderDesc: Qe,
        ColliderSet: OA,
        ColliderShapeCastHit: xa,
        Cone: Id,
        ConvexPolyhedron: Go,
        Cuboid: gd,
        Cylinder: Sd,
        DebugRenderBuffers: PA,
        DebugRenderPipeline: FA,
        DynamicRayCastVehicleController: UA,
        EventQueue: PD,
        get FeatureType() {
          return us;
        },
        FixedImpulseJoint: uA,
        FixedMultibodyJoint: bA,
        GenericImpulseJoint: _A,
        HalfSpace: RA,
        get HeightFieldFlags() {
          return wh;
        },
        Heightfield: Ed,
        ImpulseJoint: tn,
        ImpulseJointSet: wA,
        IntegrationParameters: dA,
        IslandManager: CA,
        get JointAxesMask() {
          return mh;
        },
        JointData: bn,
        get JointType() {
          return ei;
        },
        KinematicCharacterController: kA,
        get MassPropsMode() {
          return pr;
        },
        get MotorModel() {
          return _h;
        },
        MultibodyJoint: qn,
        MultibodyJointSet: EA,
        NarrowPhase: MA,
        PhysicsPipeline: BA,
        get PidAxesMask() {
          return vh;
        },
        PidController: NA,
        PointColliderProjection: la,
        PointProjection: ba,
        Polyline: xd,
        PrismaticImpulseJoint: AA,
        PrismaticMultibodyJoint: yA,
        Quaternion: ph,
        get QueryFilterFlags() {
          return yh;
        },
        QueryPipeline: DA,
        Ray: DD,
        RayColliderHit: dc,
        RayColliderIntersection: ha,
        RayIntersection: ya,
        RevoluteImpulseJoint: gA,
        RevoluteMultibodyJoint: xA,
        RigidBody: gh,
        RigidBodyDesc: rn,
        RigidBodySet: hA,
        get RigidBodyType() {
          return ji;
        },
        RopeImpulseJoint: fA,
        RotationOps: Gt,
        RoundCone: Md,
        RoundConvexPolyhedron: Ho,
        RoundCuboid: _d,
        RoundCylinder: Cd,
        RoundTriangle: yd,
        SdpMatrix3: lA,
        SdpMatrix3Ops: Ah,
        Segment: wd,
        SerializationPipeline: xh,
        Shape: Xe,
        ShapeCastHit: ms,
        ShapeContact: ds,
        get ShapeType() {
          return Ge;
        },
        get SolverFlags() {
          return Eh;
        },
        SphericalImpulseJoint: mA,
        SphericalMultibodyJoint: vA,
        SpringImpulseJoint: pA,
        TempContactForceEvent: QA,
        TempContactManifold: TA,
        TriMesh: vd,
        get TriMeshFlags() {
          return bh;
        },
        Triangle: bd,
        UnitImpulseJoint: fd,
        UnitMultibodyJoint: pd,
        Vector3: cA,
        VectorOps: k,
        World: uc,
        version: FD
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      class da extends Ui {
        constructor(t) {
          super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
            return new QD(e);
          }), this.register(function(e) {
            return new OD(e);
          }), this.register(function(e) {
            return new YD(e);
          }), this.register(function(e) {
            return new KD(e);
          }), this.register(function(e) {
            return new JD(e);
          }), this.register(function(e) {
            return new GD(e);
          }), this.register(function(e) {
            return new HD(e);
          }), this.register(function(e) {
            return new VD(e);
          }), this.register(function(e) {
            return new WD(e);
          }), this.register(function(e) {
            return new UD(e);
          }), this.register(function(e) {
            return new jD(e);
          }), this.register(function(e) {
            return new zD(e);
          }), this.register(function(e) {
            return new XD(e);
          }), this.register(function(e) {
            return new qD(e);
          }), this.register(function(e) {
            return new kD(e);
          }), this.register(function(e) {
            return new ZD(e);
          }), this.register(function(e) {
            return new $D(e);
          });
        }
        load(t, e, i, n) {
          const r = this;
          let a;
          if (this.resourcePath !== "") a = this.resourcePath;
          else if (this.path !== "") {
            const l = ns.extractUrlBase(t);
            a = ns.resolveURL(l, this.path);
          } else a = ns.extractUrlBase(t);
          this.manager.itemStart(t);
          const o = function(l) {
            n ? n(l) : console.error(l), r.manager.itemError(t), r.manager.itemEnd(t);
          }, c = new Ar(this.manager);
          c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(t, function(l) {
            try {
              r.parse(l, a, function(h) {
                e(h), r.manager.itemEnd(t);
              }, o);
            } catch (h) {
              o(h);
            }
          }, i, o);
        }
        setDRACOLoader(t) {
          return this.dracoLoader = t, this;
        }
        setKTX2Loader(t) {
          return this.ktx2Loader = t, this;
        }
        setMeshoptDecoder(t) {
          return this.meshoptDecoder = t, this;
        }
        register(t) {
          return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
        }
        unregister(t) {
          return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
        }
        parse(t, e, i, n) {
          let r;
          const a = {}, o = {}, c = new TextDecoder();
          if (typeof t == "string") r = JSON.parse(t);
          else if (t instanceof ArrayBuffer) if (c.decode(new Uint8Array(t, 0, 4)) === zA) {
            try {
              a[Jt.KHR_BINARY_GLTF] = new tP(t);
            } catch (d) {
              n && n(d);
              return;
            }
            r = JSON.parse(a[Jt.KHR_BINARY_GLTF].content);
          } else r = JSON.parse(c.decode(t));
          else r = t;
          if (r.asset === void 0 || r.asset.version[0] < 2) {
            n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const l = new fP(r, {
            path: e || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          l.fileLoader.setRequestHeader(this.requestHeader);
          for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const d = this.pluginCallbacks[h](l);
            d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[d.name] = d, a[d.name] = true;
          }
          if (r.extensionsUsed) for (let h = 0; h < r.extensionsUsed.length; ++h) {
            const d = r.extensionsUsed[h], u = r.extensionsRequired || [];
            switch (d) {
              case Jt.KHR_MATERIALS_UNLIT:
                a[d] = new ND();
                break;
              case Jt.KHR_DRACO_MESH_COMPRESSION:
                a[d] = new eP(r, this.dracoLoader);
                break;
              case Jt.KHR_TEXTURE_TRANSFORM:
                a[d] = new iP();
                break;
              case Jt.KHR_MESH_QUANTIZATION:
                a[d] = new nP();
                break;
              default:
                u.indexOf(d) >= 0 && o[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
            }
          }
          l.setExtensions(a), l.setPlugins(o), l.parse(i, n);
        }
        parseAsync(t, e) {
          const i = this;
          return new Promise(function(n, r) {
            i.parse(t, e, n, r);
          });
        }
      }
      function LD() {
        let s = {};
        return {
          get: function(t) {
            return s[t];
          },
          add: function(t, e) {
            s[t] = e;
          },
          remove: function(t) {
            delete s[t];
          },
          removeAll: function() {
            s = {};
          }
        };
      }
      const Jt = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
      };
      class kD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
          };
        }
        _markDefs() {
          const t = this.parser, e = this.parser.json.nodes || [];
          for (let i = 0, n = e.length; i < n; i++) {
            const r = e[i];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(t) {
          const e = this.parser, i = "light:" + t;
          let n = e.cache.get(i);
          if (n) return n;
          const r = e.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
          let l;
          const h = new ht(16777215);
          c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], di);
          const d = c.range !== void 0 ? c.range : 0;
          switch (c.type) {
            case "directional":
              l = new ec(h), l.target.position.set(0, 0, -1), l.add(l.target);
              break;
            case "point":
              l = new lh(h), l.distance = d;
              break;
            case "spot":
              l = new Vp(h), l.distance = d, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
          }
          return l.position.set(0, 0, 0), yn(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = e.createUniqueName(c.name || "light_" + t), n = Promise.resolve(l), e.cache.add(i, n), n;
        }
        getDependency(t, e) {
          if (t === "light") return this._loadLight(e);
        }
        createNodeAttachment(t) {
          const e = this, i = this.parser, r = i.json.nodes[t], o = (r.extensions && r.extensions[this.name] || {}).light;
          return o === void 0 ? null : this._loadLight(o).then(function(c) {
            return i._getNodeRef(e.cache, o, c);
          });
        }
      }
      class ND {
        constructor() {
          this.name = Jt.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return on;
        }
        extendParams(t, e, i) {
          const n = [];
          t.color = new ht(1, 1, 1), t.opacity = 1;
          const r = e.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const a = r.baseColorFactor;
              t.color.setRGB(a[0], a[1], a[2], di), t.opacity = a[3];
            }
            r.baseColorTexture !== void 0 && n.push(i.assignTexture(t, "map", r.baseColorTexture, ne));
          }
          return Promise.all(n);
        }
      }
      class UD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(t, e) {
          const n = this.parser.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name].emissiveStrength;
          return r !== void 0 && (e.emissiveIntensity = r), Promise.resolve();
        }
      }
      class QD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          if (a.clearcoatFactor !== void 0 && (e.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(i.assignTexture(e, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(e, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(e, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
            const o = a.clearcoatNormalTexture.scale;
            e.clearcoatNormalScale = new rt(o, o);
          }
          return Promise.all(r);
        }
      }
      class OD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const n = this.parser.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name];
          return e.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
      }
      class zD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.iridescenceFactor !== void 0 && (e.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(i.assignTexture(e, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (e.iridescenceIOR = a.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [
            100,
            400
          ]), a.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(e, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
        }
      }
      class GD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [];
          e.sheenColor = new ht(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
          const a = n.extensions[this.name];
          if (a.sheenColorFactor !== void 0) {
            const o = a.sheenColorFactor;
            e.sheenColor.setRGB(o[0], o[1], o[2], di);
          }
          return a.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(i.assignTexture(e, "sheenColorMap", a.sheenColorTexture, ne)), a.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(e, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
        }
      }
      class HD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.transmissionFactor !== void 0 && (e.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(i.assignTexture(e, "transmissionMap", a.transmissionTexture)), Promise.all(r);
        }
      }
      class VD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          e.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(i.assignTexture(e, "thicknessMap", a.thicknessTexture)), e.attenuationDistance = a.attenuationDistance || 1 / 0;
          const o = a.attenuationColor || [
            1,
            1,
            1
          ];
          return e.attenuationColor = new ht().setRGB(o[0], o[1], o[2], di), Promise.all(r);
        }
      }
      class WD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_IOR;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const n = this.parser.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name];
          return e.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
      }
      class jD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          e.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(i.assignTexture(e, "specularIntensityMap", a.specularTexture));
          const o = a.specularColorFactor || [
            1,
            1,
            1
          ];
          return e.specularColor = new ht().setRGB(o[0], o[1], o[2], di), a.specularColorTexture !== void 0 && r.push(i.assignTexture(e, "specularColorMap", a.specularColorTexture, ne)), Promise.all(r);
        }
      }
      class qD {
        constructor(t) {
          this.parser = t, this.name = Jt.EXT_MATERIALS_BUMP;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return e.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(i.assignTexture(e, "bumpMap", a.bumpTexture)), Promise.all(r);
        }
      }
      class XD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(t) {
          const i = this.parser.json.materials[t];
          return !i.extensions || !i.extensions[this.name] ? null : hn;
        }
        extendMaterialParams(t, e) {
          const i = this.parser, n = i.json.materials[t];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.anisotropyStrength !== void 0 && (e.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (e.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(i.assignTexture(e, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
        }
      }
      class YD {
        constructor(t) {
          this.parser = t, this.name = Jt.KHR_TEXTURE_BASISU;
        }
        loadTexture(t) {
          const e = this.parser, i = e.json, n = i.textures[t];
          if (!n.extensions || !n.extensions[this.name]) return null;
          const r = n.extensions[this.name], a = e.options.ktx2Loader;
          if (!a) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
          }
          return e.loadTextureImage(t, r.source, a);
        }
      }
      class KD {
        constructor(t) {
          this.parser = t, this.name = Jt.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(t) {
          const e = this.name, i = this.parser, n = i.json, r = n.textures[t];
          if (!r.extensions || !r.extensions[e]) return null;
          const a = r.extensions[e], o = n.images[a.source];
          let c = i.textureLoader;
          if (o.uri) {
            const l = i.options.manager.getHandler(o.uri);
            l !== null && (c = l);
          }
          return this.detectSupport().then(function(l) {
            if (l) return i.loadTextureImage(t, a.source, c);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(t);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(t) {
            const e = new Image();
            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
              t(e.height === 1);
            };
          })), this.isSupported;
        }
      }
      class JD {
        constructor(t) {
          this.parser = t, this.name = Jt.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(t) {
          const e = this.name, i = this.parser, n = i.json, r = n.textures[t];
          if (!r.extensions || !r.extensions[e]) return null;
          const a = r.extensions[e], o = n.images[a.source];
          let c = i.textureLoader;
          if (o.uri) {
            const l = i.options.manager.getHandler(o.uri);
            l !== null && (c = l);
          }
          return this.detectSupport().then(function(l) {
            if (l) return i.loadTextureImage(t, a.source, c);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(t);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(t) {
            const e = new Image();
            e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
              t(e.height === 1);
            };
          })), this.isSupported;
        }
      }
      class ZD {
        constructor(t) {
          this.name = Jt.EXT_MESHOPT_COMPRESSION, this.parser = t;
        }
        loadBufferView(t) {
          const e = this.parser.json, i = e.bufferViews[t];
          if (i.extensions && i.extensions[this.name]) {
            const n = i.extensions[this.name], r = this.parser.getDependency("buffer", n.buffer), a = this.parser.options.meshoptDecoder;
            if (!a || !a.supported) {
              if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              return null;
            }
            return r.then(function(o) {
              const c = n.byteOffset || 0, l = n.byteLength || 0, h = n.count, d = n.byteStride, u = new Uint8Array(o, c, l);
              return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, d, u, n.mode, n.filter).then(function(f) {
                return f.buffer;
              }) : a.ready.then(function() {
                const f = new ArrayBuffer(h * d);
                return a.decodeGltfBuffer(new Uint8Array(f), h, d, u, n.mode, n.filter), f;
              });
            });
          } else return null;
        }
      }
      class $D {
        constructor(t) {
          this.name = Jt.EXT_MESH_GPU_INSTANCING, this.parser = t;
        }
        createNodeMesh(t) {
          const e = this.parser.json, i = e.nodes[t];
          if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
          const n = e.meshes[i.mesh];
          for (const l of n.primitives) if (l.mode !== Pi.TRIANGLES && l.mode !== Pi.TRIANGLE_STRIP && l.mode !== Pi.TRIANGLE_FAN && l.mode !== void 0) return null;
          const a = i.extensions[this.name].attributes, o = [], c = {};
          for (const l in a) o.push(this.parser.getDependency("accessor", a[l]).then((h) => (c[l] = h, c[l])));
          return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(t)), Promise.all(o).then((l) => {
            const h = l.pop(), d = h.isGroup ? h.children : [
              h
            ], u = l[0].count, f = [];
            for (const p of d) {
              const m = new ft(), g = new I(), A = new ue(), x = new I(1, 1, 1), b = new om(p.geometry, p.material, u);
              for (let y = 0; y < u; y++) c.TRANSLATION && g.fromBufferAttribute(c.TRANSLATION, y), c.ROTATION && A.fromBufferAttribute(c.ROTATION, y), c.SCALE && x.fromBufferAttribute(c.SCALE, y), b.setMatrixAt(y, m.compose(g, A, x));
              for (const y in c) if (y === "_COLOR_0") {
                const M = c[y];
                b.instanceColor = new fr(M.array, M.itemSize, M.normalized);
              } else y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && p.geometry.setAttribute(y, c[y]);
              ce.prototype.copy.call(b, p), this.parser.assignFinalMaterial(b), f.push(b);
            }
            return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
          }));
        }
      }
      const zA = "glTF", Bs = 12, Gf = {
        JSON: 1313821514,
        BIN: 5130562
      };
      class tP {
        constructor(t) {
          this.name = Jt.KHR_BINARY_GLTF, this.content = null, this.body = null;
          const e = new DataView(t, 0, Bs), i = new TextDecoder();
          if (this.header = {
            magic: i.decode(new Uint8Array(t.slice(0, 4))),
            version: e.getUint32(4, true),
            length: e.getUint32(8, true)
          }, this.header.magic !== zA) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - Bs, r = new DataView(t, Bs);
          let a = 0;
          for (; a < n; ) {
            const o = r.getUint32(a, true);
            a += 4;
            const c = r.getUint32(a, true);
            if (a += 4, c === Gf.JSON) {
              const l = new Uint8Array(t, Bs + a, o);
              this.content = i.decode(l);
            } else if (c === Gf.BIN) {
              const l = Bs + a;
              this.body = t.slice(l, l + o);
            }
            a += o;
          }
          if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class eP {
        constructor(t, e) {
          if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          this.name = Jt.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
        }
        decodePrimitive(t, e) {
          const i = this.json, n = this.dracoLoader, r = t.extensions[this.name].bufferView, a = t.extensions[this.name].attributes, o = {}, c = {}, l = {};
          for (const h in a) {
            const d = Ch[h] || h.toLowerCase();
            o[d] = a[h];
          }
          for (const h in t.attributes) {
            const d = Ch[h] || h.toLowerCase();
            if (a[h] !== void 0) {
              const u = i.accessors[t.attributes[h]], f = rs[u.componentType];
              l[d] = f.name, c[d] = u.normalized === true;
            }
          }
          return e.getDependency("bufferView", r).then(function(h) {
            return new Promise(function(d, u) {
              n.decodeDracoFile(h, function(f) {
                for (const p in f.attributes) {
                  const m = f.attributes[p], g = c[p];
                  g !== void 0 && (m.normalized = g);
                }
                d(f);
              }, o, l, di, u);
            });
          });
        }
      }
      class iP {
        constructor() {
          this.name = Jt.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(t, e) {
          return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = true), t;
        }
      }
      class nP {
        constructor() {
          this.name = Jt.KHR_MESH_QUANTIZATION;
        }
      }
      class GA extends wa {
        constructor(t, e, i, n) {
          super(t, e, i, n);
        }
        copySampleValue_(t) {
          const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n * 3 + n;
          for (let a = 0; a !== n; a++) e[a] = i[r + a];
          return e;
        }
        interpolate_(t, e, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, h = n - e, d = (i - e) / h, u = d * d, f = u * d, p = t * l, m = p - l, g = -2 * f + 3 * u, A = f - u, x = 1 - g, b = A - u + d;
          for (let y = 0; y !== o; y++) {
            const M = a[m + y + o], T = a[m + y + c] * h, R = a[p + y + o], B = a[p + y] * h;
            r[y] = x * M + b * T + g * R + A * B;
          }
          return r;
        }
      }
      const rP = new ue();
      class sP extends GA {
        interpolate_(t, e, i, n) {
          const r = super.interpolate_(t, e, i, n);
          return rP.fromArray(r).normalize().toArray(r), r;
        }
      }
      const Pi = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
      }, rs = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      }, Hf = {
        9728: mi,
        9729: Re,
        9984: sp,
        9985: mo,
        9986: Ps,
        9987: Zi
      }, Vf = {
        33071: _i,
        33648: Co,
        10497: ni
      }, ul = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
      }, Ch = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      }, Qn = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      }, aP = {
        CUBICSPLINE: void 0,
        LINEAR: $s,
        STEP: Zs
      }, fl = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      function oP(s) {
        return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new ci({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: Cn
        })), s.DefaultMaterial;
      }
      function cr(s, t, e) {
        for (const i in e.extensions) s[i] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = e.extensions[i]);
      }
      function yn(s, t) {
        t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(s.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
      }
      function cP(s, t, e) {
        let i = false, n = false, r = false;
        for (let l = 0, h = t.length; l < h; l++) {
          const d = t[l];
          if (d.POSITION !== void 0 && (i = true), d.NORMAL !== void 0 && (n = true), d.COLOR_0 !== void 0 && (r = true), i && n && r) break;
        }
        if (!i && !n && !r) return Promise.resolve(s);
        const a = [], o = [], c = [];
        for (let l = 0, h = t.length; l < h; l++) {
          const d = t[l];
          if (i) {
            const u = d.POSITION !== void 0 ? e.getDependency("accessor", d.POSITION) : s.attributes.position;
            a.push(u);
          }
          if (n) {
            const u = d.NORMAL !== void 0 ? e.getDependency("accessor", d.NORMAL) : s.attributes.normal;
            o.push(u);
          }
          if (r) {
            const u = d.COLOR_0 !== void 0 ? e.getDependency("accessor", d.COLOR_0) : s.attributes.color;
            c.push(u);
          }
        }
        return Promise.all([
          Promise.all(a),
          Promise.all(o),
          Promise.all(c)
        ]).then(function(l) {
          const h = l[0], d = l[1], u = l[2];
          return i && (s.morphAttributes.position = h), n && (s.morphAttributes.normal = d), r && (s.morphAttributes.color = u), s.morphTargetsRelative = true, s;
        });
      }
      function lP(s, t) {
        if (s.updateMorphTargets(), t.weights !== void 0) for (let e = 0, i = t.weights.length; e < i; e++) s.morphTargetInfluences[e] = t.weights[e];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
          const e = t.extras.targetNames;
          if (s.morphTargetInfluences.length === e.length) {
            s.morphTargetDictionary = {};
            for (let i = 0, n = e.length; i < n; i++) s.morphTargetDictionary[e[i]] = i;
          } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
      function hP(s) {
        let t;
        const e = s.extensions && s.extensions[Jt.KHR_DRACO_MESH_COMPRESSION];
        if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + pl(e.attributes) : t = s.indices + ":" + pl(s.attributes) + ":" + s.mode, s.targets !== void 0) for (let i = 0, n = s.targets.length; i < n; i++) t += ":" + pl(s.targets[i]);
        return t;
      }
      function pl(s) {
        let t = "";
        const e = Object.keys(s).sort();
        for (let i = 0, n = e.length; i < n; i++) t += e[i] + ":" + s[e[i]] + ";";
        return t;
      }
      function Ih(s) {
        switch (s) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      function dP(s) {
        return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : s.search(/\.ktx2($|\?)/i) > 0 || s.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
      }
      const uP = new ft();
      class fP {
        constructor(t = {}, e = {}) {
          this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new LD(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
          }, this.cameraCache = {
            refs: {},
            uses: {}
          }, this.lightCache = {
            refs: {},
            uses: {}
          }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
          let i = false, n = -1, r = false, a = -1;
          if (typeof navigator < "u") {
            const o = navigator.userAgent;
            i = /^((?!chrome|android).)*safari/i.test(o) === true;
            const c = o.match(/Version\/(\d+)/);
            n = i && c ? parseInt(c[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
          }
          typeof createImageBitmap > "u" || i && n < 17 || r && a < 98 ? this.textureLoader = new hi(this.options.manager) : this.textureLoader = new lw(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ar(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
        }
        setExtensions(t) {
          this.extensions = t;
        }
        setPlugins(t) {
          this.plugins = t;
        }
        parse(t, e) {
          const i = this, n = this.json, r = this.extensions;
          this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
            return a._markDefs && a._markDefs();
          }), Promise.all(this._invokeAll(function(a) {
            return a.beforeRoot && a.beforeRoot();
          })).then(function() {
            return Promise.all([
              i.getDependencies("scene"),
              i.getDependencies("animation"),
              i.getDependencies("camera")
            ]);
          }).then(function(a) {
            const o = {
              scene: a[0][n.scene || 0],
              scenes: a[0],
              animations: a[1],
              cameras: a[2],
              asset: n.asset,
              parser: i,
              userData: {}
            };
            return cr(r, o, n), yn(o, n), Promise.all(i._invokeAll(function(c) {
              return c.afterRoot && c.afterRoot(o);
            })).then(function() {
              for (const c of o.scenes) c.updateMatrixWorld();
              t(o);
            });
          }).catch(e);
        }
        _markDefs() {
          const t = this.json.nodes || [], e = this.json.skins || [], i = this.json.meshes || [];
          for (let n = 0, r = e.length; n < r; n++) {
            const a = e[n].joints;
            for (let o = 0, c = a.length; o < c; o++) t[a[o]].isBone = true;
          }
          for (let n = 0, r = t.length; n < r; n++) {
            const a = t[n];
            a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = true)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
          }
        }
        _addNodeRef(t, e) {
          e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
        }
        _getNodeRef(t, e, i) {
          if (t.refs[e] <= 1) return i;
          const n = i.clone(), r = (a, o) => {
            const c = this.associations.get(a);
            c != null && this.associations.set(o, c);
            for (const [l, h] of a.children.entries()) r(h, o.children[l]);
          };
          return r(i, n), n.name += "_instance_" + t.uses[e]++, n;
        }
        _invokeOne(t) {
          const e = Object.values(this.plugins);
          e.push(this);
          for (let i = 0; i < e.length; i++) {
            const n = t(e[i]);
            if (n) return n;
          }
          return null;
        }
        _invokeAll(t) {
          const e = Object.values(this.plugins);
          e.unshift(this);
          const i = [];
          for (let n = 0; n < e.length; n++) {
            const r = t(e[n]);
            r && i.push(r);
          }
          return i;
        }
        getDependency(t, e) {
          const i = t + ":" + e;
          let n = this.cache.get(i);
          if (!n) {
            switch (t) {
              case "scene":
                n = this.loadScene(e);
                break;
              case "node":
                n = this._invokeOne(function(r) {
                  return r.loadNode && r.loadNode(e);
                });
                break;
              case "mesh":
                n = this._invokeOne(function(r) {
                  return r.loadMesh && r.loadMesh(e);
                });
                break;
              case "accessor":
                n = this.loadAccessor(e);
                break;
              case "bufferView":
                n = this._invokeOne(function(r) {
                  return r.loadBufferView && r.loadBufferView(e);
                });
                break;
              case "buffer":
                n = this.loadBuffer(e);
                break;
              case "material":
                n = this._invokeOne(function(r) {
                  return r.loadMaterial && r.loadMaterial(e);
                });
                break;
              case "texture":
                n = this._invokeOne(function(r) {
                  return r.loadTexture && r.loadTexture(e);
                });
                break;
              case "skin":
                n = this.loadSkin(e);
                break;
              case "animation":
                n = this._invokeOne(function(r) {
                  return r.loadAnimation && r.loadAnimation(e);
                });
                break;
              case "camera":
                n = this.loadCamera(e);
                break;
              default:
                if (n = this._invokeOne(function(r) {
                  return r != this && r.getDependency && r.getDependency(t, e);
                }), !n) throw new Error("Unknown type: " + t);
                break;
            }
            this.cache.add(i, n);
          }
          return n;
        }
        getDependencies(t) {
          let e = this.cache.get(t);
          if (!e) {
            const i = this, n = this.json[t + (t === "mesh" ? "es" : "s")] || [];
            e = Promise.all(n.map(function(r, a) {
              return i.getDependency(t, a);
            })), this.cache.add(t, e);
          }
          return e;
        }
        loadBuffer(t) {
          const e = this.json.buffers[t], i = this.fileLoader;
          if (e.type && e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
          if (e.uri === void 0 && t === 0) return Promise.resolve(this.extensions[Jt.KHR_BINARY_GLTF].body);
          const n = this.options;
          return new Promise(function(r, a) {
            i.load(ns.resolveURL(e.uri, n.path), r, void 0, function() {
              a(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
            });
          });
        }
        loadBufferView(t) {
          const e = this.json.bufferViews[t];
          return this.getDependency("buffer", e.buffer).then(function(i) {
            const n = e.byteLength || 0, r = e.byteOffset || 0;
            return i.slice(r, r + n);
          });
        }
        loadAccessor(t) {
          const e = this, i = this.json, n = this.json.accessors[t];
          if (n.bufferView === void 0 && n.sparse === void 0) {
            const a = ul[n.type], o = rs[n.componentType], c = n.normalized === true, l = new o(n.count * a);
            return Promise.resolve(new ri(l, a, c));
          }
          const r = [];
          return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(a) {
            const o = a[0], c = ul[n.type], l = rs[n.componentType], h = l.BYTES_PER_ELEMENT, d = h * c, u = n.byteOffset || 0, f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === true;
            let m, g;
            if (f && f !== d) {
              const A = Math.floor(u / f), x = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + A + ":" + n.count;
              let b = e.cache.get(x);
              b || (m = new l(o, A * f, n.count * f / h), b = new vp(m, f / h), e.cache.add(x, b)), g = new ea(b, c, u % f / h, p);
            } else o === null ? m = new l(n.count * c) : m = new l(o, u, n.count * c), g = new ri(m, c, p);
            if (n.sparse !== void 0) {
              const A = ul.SCALAR, x = rs[n.sparse.indices.componentType], b = n.sparse.indices.byteOffset || 0, y = n.sparse.values.byteOffset || 0, M = new x(a[1], b, n.sparse.count * A), T = new l(a[2], y, n.sparse.count * c);
              o !== null && (g = new ri(g.array.slice(), g.itemSize, g.normalized)), g.normalized = false;
              for (let R = 0, B = M.length; R < B; R++) {
                const S = M[R];
                if (g.setX(S, T[R * c]), c >= 2 && g.setY(S, T[R * c + 1]), c >= 3 && g.setZ(S, T[R * c + 2]), c >= 4 && g.setW(S, T[R * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
              g.normalized = p;
            }
            return g;
          });
        }
        loadTexture(t) {
          const e = this.json, i = this.options, r = e.textures[t].source, a = e.images[r];
          let o = this.textureLoader;
          if (a.uri) {
            const c = i.manager.getHandler(a.uri);
            c !== null && (o = c);
          }
          return this.loadTextureImage(t, r, o);
        }
        loadTextureImage(t, e, i) {
          const n = this, r = this.json, a = r.textures[t], o = r.images[e], c = (o.uri || o.bufferView) + ":" + a.sampler;
          if (this.textureCache[c]) return this.textureCache[c];
          const l = this.loadImageSource(e, i).then(function(h) {
            h.flipY = false, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === false && (h.name = o.uri);
            const u = (r.samplers || {})[a.sampler] || {};
            return h.magFilter = Hf[u.magFilter] || Re, h.minFilter = Hf[u.minFilter] || Zi, h.wrapS = Vf[u.wrapS] || ni, h.wrapT = Vf[u.wrapT] || ni, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== mi && h.minFilter !== Re, n.associations.set(h, {
              textures: t
            }), h;
          }).catch(function() {
            return null;
          });
          return this.textureCache[c] = l, l;
        }
        loadImageSource(t, e) {
          const i = this, n = this.json, r = this.options;
          if (this.sourceCache[t] !== void 0) return this.sourceCache[t].then((d) => d.clone());
          const a = n.images[t], o = self.URL || self.webkitURL;
          let c = a.uri || "", l = false;
          if (a.bufferView !== void 0) c = i.getDependency("bufferView", a.bufferView).then(function(d) {
            l = true;
            const u = new Blob([
              d
            ], {
              type: a.mimeType
            });
            return c = o.createObjectURL(u), c;
          });
          else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
          const h = Promise.resolve(c).then(function(d) {
            return new Promise(function(u, f) {
              let p = u;
              e.isImageBitmapLoader === true && (p = function(m) {
                const g = new Pe(m);
                g.needsUpdate = true, u(g);
              }), e.load(ns.resolveURL(d, r.path), p, void 0, f);
            });
          }).then(function(d) {
            return l === true && o.revokeObjectURL(c), yn(d, a), d.userData.mimeType = a.mimeType || dP(a.uri), d;
          }).catch(function(d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", c), d;
          });
          return this.sourceCache[t] = h, h;
        }
        assignTexture(t, e, i, n) {
          const r = this;
          return this.getDependency("texture", i.index).then(function(a) {
            if (!a) return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (a = a.clone(), a.channel = i.texCoord), r.extensions[Jt.KHR_TEXTURE_TRANSFORM]) {
              const o = i.extensions !== void 0 ? i.extensions[Jt.KHR_TEXTURE_TRANSFORM] : void 0;
              if (o) {
                const c = r.associations.get(a);
                a = r.extensions[Jt.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, c);
              }
            }
            return n !== void 0 && (a.colorSpace = n), t[e] = a, a;
          });
        }
        assignFinalMaterial(t) {
          const e = t.geometry;
          let i = t.material;
          const n = e.attributes.tangent === void 0, r = e.attributes.color !== void 0, a = e.attributes.normal === void 0;
          if (t.isPoints) {
            const o = "PointsMaterial:" + i.uuid;
            let c = this.cache.get(o);
            c || (c = new Ip(), Ii.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, c.sizeAttenuation = false, this.cache.add(o, c)), i = c;
          } else if (t.isLine) {
            const o = "LineBasicMaterial:" + i.uuid;
            let c = this.cache.get(o);
            c || (c = new ma(), Ii.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, this.cache.add(o, c)), i = c;
          }
          if (n || r || a) {
            let o = "ClonedMaterial:" + i.uuid + ":";
            n && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
            let c = this.cache.get(o);
            c || (c = i.clone(), r && (c.vertexColors = true), a && (c.flatShading = true), n && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(i))), i = c;
          }
          t.material = i;
        }
        getMaterialType() {
          return ci;
        }
        loadMaterial(t) {
          const e = this, i = this.json, n = this.extensions, r = i.materials[t];
          let a;
          const o = {}, c = r.extensions || {}, l = [];
          if (c[Jt.KHR_MATERIALS_UNLIT]) {
            const d = n[Jt.KHR_MATERIALS_UNLIT];
            a = d.getMaterialType(), l.push(d.extendParams(o, r, e));
          } else {
            const d = r.pbrMetallicRoughness || {};
            if (o.color = new ht(1, 1, 1), o.opacity = 1, Array.isArray(d.baseColorFactor)) {
              const u = d.baseColorFactor;
              o.color.setRGB(u[0], u[1], u[2], di), o.opacity = u[3];
            }
            d.baseColorTexture !== void 0 && l.push(e.assignTexture(o, "map", d.baseColorTexture, ne)), o.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, o.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (l.push(e.assignTexture(o, "metalnessMap", d.metallicRoughnessTexture)), l.push(e.assignTexture(o, "roughnessMap", d.metallicRoughnessTexture))), a = this._invokeOne(function(u) {
              return u.getMaterialType && u.getMaterialType(t);
            }), l.push(Promise.all(this._invokeAll(function(u) {
              return u.extendMaterialParams && u.extendMaterialParams(t, o);
            })));
          }
          r.doubleSided === true && (o.side = Ki);
          const h = r.alphaMode || fl.OPAQUE;
          if (h === fl.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, h === fl.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== on && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new rt(1, 1), r.normalTexture.scale !== void 0)) {
            const d = r.normalTexture.scale;
            o.normalScale.set(d, d);
          }
          if (r.occlusionTexture !== void 0 && a !== on && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== on) {
            const d = r.emissiveFactor;
            o.emissive = new ht().setRGB(d[0], d[1], d[2], di);
          }
          return r.emissiveTexture !== void 0 && a !== on && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, ne)), Promise.all(l).then(function() {
            const d = new a(o);
            return r.name && (d.name = r.name), yn(d, r), e.associations.set(d, {
              materials: t
            }), r.extensions && cr(n, d, r), d;
          });
        }
        createUniqueName(t) {
          const e = ee.sanitizeNodeName(t || "");
          return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
        }
        loadGeometries(t) {
          const e = this, i = this.extensions, n = this.primitiveCache;
          function r(o) {
            return i[Jt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, e).then(function(c) {
              return Wf(c, o, e);
            });
          }
          const a = [];
          for (let o = 0, c = t.length; o < c; o++) {
            const l = t[o], h = hP(l), d = n[h];
            if (d) a.push(d.promise);
            else {
              let u;
              l.extensions && l.extensions[Jt.KHR_DRACO_MESH_COMPRESSION] ? u = r(l) : u = Wf(new Fe(), l, e), n[h] = {
                primitive: l,
                promise: u
              }, a.push(u);
            }
          }
          return Promise.all(a);
        }
        loadMesh(t) {
          const e = this, i = this.json, n = this.extensions, r = i.meshes[t], a = r.primitives, o = [];
          for (let c = 0, l = a.length; c < l; c++) {
            const h = a[c].material === void 0 ? oP(this.cache) : this.getDependency("material", a[c].material);
            o.push(h);
          }
          return o.push(e.loadGeometries(a)), Promise.all(o).then(function(c) {
            const l = c.slice(0, c.length - 1), h = c[c.length - 1], d = [];
            for (let f = 0, p = h.length; f < p; f++) {
              const m = h[f], g = a[f];
              let A;
              const x = l[f];
              if (g.mode === Pi.TRIANGLES || g.mode === Pi.TRIANGLE_STRIP || g.mode === Pi.TRIANGLE_FAN || g.mode === void 0) A = r.isSkinnedMesh === true ? new Wh(m, x) : new me(m, x), A.isSkinnedMesh === true && A.normalizeSkinWeights(), g.mode === Pi.TRIANGLE_STRIP ? A.geometry = Af(A.geometry, pp) : g.mode === Pi.TRIANGLE_FAN && (A.geometry = Af(A.geometry, nh));
              else if (g.mode === Pi.LINES) A = new Cp(m, x);
              else if (g.mode === Pi.LINE_STRIP) A = new ls(m, x);
              else if (g.mode === Pi.LINE_LOOP) A = new hm(m, x);
              else if (g.mode === Pi.POINTS) A = new dm(m, x);
              else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
              Object.keys(A.geometry.morphAttributes).length > 0 && lP(A, r), A.name = e.createUniqueName(r.name || "mesh_" + t), yn(A, r), g.extensions && cr(n, A, g), e.assignFinalMaterial(A), d.push(A);
            }
            for (let f = 0, p = d.length; f < p; f++) e.associations.set(d[f], {
              meshes: t,
              primitives: f
            });
            if (d.length === 1) return r.extensions && cr(n, d[0], r), d[0];
            const u = new ki();
            r.extensions && cr(n, u, r), e.associations.set(u, {
              meshes: t
            });
            for (let f = 0, p = d.length; f < p; f++) u.add(d[f]);
            return u;
          });
        }
        loadCamera(t) {
          let e;
          const i = this.json.cameras[t], n = i[i.type];
          if (!n) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return i.type === "perspective" ? e = new Ve(ke.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (e = new ed(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (e.name = this.createUniqueName(i.name)), yn(e, i), Promise.resolve(e);
        }
        loadSkin(t) {
          const e = this.json.skins[t], i = [];
          for (let n = 0, r = e.joints.length; n < r; n++) i.push(this._loadNodeShallow(e.joints[n]));
          return e.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", e.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
            const r = n.pop(), a = n, o = [], c = [];
            for (let l = 0, h = a.length; l < h; l++) {
              const d = a[l];
              if (d) {
                o.push(d);
                const u = new ft();
                r !== null && u.fromArray(r.array, l * 16), c.push(u);
              } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[l]);
            }
            return new _a(o, c);
          });
        }
        loadAnimation(t) {
          const e = this.json, i = this, n = e.animations[t], r = n.name ? n.name : "animation_" + t, a = [], o = [], c = [], l = [], h = [];
          for (let d = 0, u = n.channels.length; d < u; d++) {
            const f = n.channels[d], p = n.samplers[f.sampler], m = f.target, g = m.node, A = n.parameters !== void 0 ? n.parameters[p.input] : p.input, x = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
            m.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", A)), c.push(this.getDependency("accessor", x)), l.push(p), h.push(m));
          }
          return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(c),
            Promise.all(l),
            Promise.all(h)
          ]).then(function(d) {
            const u = d[0], f = d[1], p = d[2], m = d[3], g = d[4], A = [];
            for (let x = 0, b = u.length; x < b; x++) {
              const y = u[x], M = f[x], T = p[x], R = m[x], B = g[x];
              if (y === void 0) continue;
              y.updateMatrix && y.updateMatrix();
              const S = i._createAnimationTracks(y, M, T, R, B);
              if (S) for (let E = 0; E < S.length; E++) A.push(S[E]);
            }
            return new Qo(r, void 0, A);
          });
        }
        createNodeMesh(t) {
          const e = this.json, i = this, n = e.nodes[t];
          return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
            const a = i._getNodeRef(i.meshCache, n.mesh, r);
            return n.weights !== void 0 && a.traverse(function(o) {
              if (o.isMesh) for (let c = 0, l = n.weights.length; c < l; c++) o.morphTargetInfluences[c] = n.weights[c];
            }), a;
          });
        }
        loadNode(t) {
          const e = this.json, i = this, n = e.nodes[t], r = i._loadNodeShallow(t), a = [], o = n.children || [];
          for (let l = 0, h = o.length; l < h; l++) a.push(i.getDependency("node", o[l]));
          const c = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
          return Promise.all([
            r,
            Promise.all(a),
            c
          ]).then(function(l) {
            const h = l[0], d = l[1], u = l[2];
            u !== null && h.traverse(function(f) {
              f.isSkinnedMesh && f.bind(u, uP);
            });
            for (let f = 0, p = d.length; f < p; f++) h.add(d[f]);
            return h;
          });
        }
        _loadNodeShallow(t) {
          const e = this.json, i = this.extensions, n = this;
          if (this.nodeCache[t] !== void 0) return this.nodeCache[t];
          const r = e.nodes[t], a = r.name ? n.createUniqueName(r.name) : "", o = [], c = n._invokeOne(function(l) {
            return l.createNodeMesh && l.createNodeMesh(t);
          });
          return c && o.push(c), r.camera !== void 0 && o.push(n.getDependency("camera", r.camera).then(function(l) {
            return n._getNodeRef(n.cameraCache, r.camera, l);
          })), n._invokeAll(function(l) {
            return l.createNodeAttachment && l.createNodeAttachment(t);
          }).forEach(function(l) {
            o.push(l);
          }), this.nodeCache[t] = Promise.all(o).then(function(l) {
            let h;
            if (r.isBone === true ? h = new ia() : l.length > 1 ? h = new ki() : l.length === 1 ? h = l[0] : h = new ce(), h !== l[0]) for (let d = 0, u = l.length; d < u; d++) h.add(l[d]);
            if (r.name && (h.userData.name = r.name, h.name = a), yn(h, r), r.extensions && cr(i, h, r), r.matrix !== void 0) {
              const d = new ft();
              d.fromArray(r.matrix), h.applyMatrix4(d);
            } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
            return n.associations.has(h) || n.associations.set(h, {}), n.associations.get(h).nodes = t, h;
          }), this.nodeCache[t];
        }
        loadScene(t) {
          const e = this.extensions, i = this.json.scenes[t], n = this, r = new ki();
          i.name && (r.name = n.createUniqueName(i.name)), yn(r, i), i.extensions && cr(e, r, i);
          const a = i.nodes || [], o = [];
          for (let c = 0, l = a.length; c < l; c++) o.push(n.getDependency("node", a[c]));
          return Promise.all(o).then(function(c) {
            for (let h = 0, d = c.length; h < d; h++) r.add(c[h]);
            const l = (h) => {
              const d = /* @__PURE__ */ new Map();
              for (const [u, f] of n.associations) (u instanceof Ii || u instanceof Pe) && d.set(u, f);
              return h.traverse((u) => {
                const f = n.associations.get(u);
                f != null && d.set(u, f);
              }), d;
            };
            return n.associations = l(r), r;
          });
        }
        _createAnimationTracks(t, e, i, n, r) {
          const a = [], o = t.name ? t.name : t.uuid, c = [];
          Qn[r.path] === Qn.weights ? t.traverse(function(u) {
            u.morphTargetInfluences && c.push(u.name ? u.name : u.uuid);
          }) : c.push(o);
          let l;
          switch (Qn[r.path]) {
            case Qn.weights:
              l = wr;
              break;
            case Qn.rotation:
              l = Wn;
              break;
            case Qn.translation:
            case Qn.scale:
              l = br;
              break;
            default:
              switch (i.itemSize) {
                case 1:
                  l = wr;
                  break;
                case 2:
                case 3:
                default:
                  l = br;
                  break;
              }
              break;
          }
          const h = n.interpolation !== void 0 ? aP[n.interpolation] : $s, d = this._getArrayFromAccessor(i);
          for (let u = 0, f = c.length; u < f; u++) {
            const p = new l(c[u] + "." + Qn[r.path], e.array, d, h);
            n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), a.push(p);
          }
          return a;
        }
        _getArrayFromAccessor(t) {
          let e = t.array;
          if (t.normalized) {
            const i = Ih(e.constructor), n = new Float32Array(e.length);
            for (let r = 0, a = e.length; r < a; r++) n[r] = e[r] * i;
            e = n;
          }
          return e;
        }
        _createCubicSplineTrackInterpolant(t) {
          t.createInterpolant = function(i) {
            const n = this instanceof Wn ? sP : GA;
            return new n(this.times, this.values, this.getValueSize() / 3, i);
          }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
        }
      }
      function pP(s, t, e) {
        const i = t.attributes, n = new cn();
        if (i.POSITION !== void 0) {
          const o = e.json.accessors[i.POSITION], c = o.min, l = o.max;
          if (c !== void 0 && l !== void 0) {
            if (n.set(new I(c[0], c[1], c[2]), new I(l[0], l[1], l[2])), o.normalized) {
              const h = Ih(rs[o.componentType]);
              n.min.multiplyScalar(h), n.max.multiplyScalar(h);
            }
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else return;
        const r = t.targets;
        if (r !== void 0) {
          const o = new I(), c = new I();
          for (let l = 0, h = r.length; l < h; l++) {
            const d = r[l];
            if (d.POSITION !== void 0) {
              const u = e.json.accessors[d.POSITION], f = u.min, p = u.max;
              if (f !== void 0 && p !== void 0) {
                if (c.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), c.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), c.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), u.normalized) {
                  const m = Ih(rs[u.componentType]);
                  c.multiplyScalar(m);
                }
                o.max(c);
              } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
          }
          n.expandByVector(o);
        }
        s.boundingBox = n;
        const a = new ln();
        n.getCenter(a.center), a.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = a;
      }
      function Wf(s, t, e) {
        const i = t.attributes, n = [];
        function r(a, o) {
          return e.getDependency("accessor", a).then(function(c) {
            s.setAttribute(o, c);
          });
        }
        for (const a in i) {
          const o = Ch[a] || a.toLowerCase();
          o in s.attributes || n.push(r(i[a], o));
        }
        if (t.indices !== void 0 && !s.index) {
          const a = e.getDependency("accessor", t.indices).then(function(o) {
            s.setIndex(o);
          });
          n.push(a);
        }
        return zt.workingColorSpace !== di && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${zt.workingColorSpace}" not supported.`), yn(s, t), pP(s, t, e), Promise.all(n).then(function() {
          return t.targets !== void 0 ? cP(s, t.targets, e) : s;
        });
      }
      class AP {
        constructor(t = 16777215, e = 1, i = new I(0, 0, 0)) {
          this.dirLight = new ec(t, e), this.offset = new I(60, 100, 0), this.targetPosition = i, this.dirLight.target = new ce(), this._initDirLight();
        }
        _initDirLight() {
          const { x: t, y: e, z: i } = new I().addVectors(this.targetPosition, this.offset);
          this.dirLight.position.set(t, e, i), this.dirLight.target.position.copy(this.targetPosition), this.dirLight.castShadow = true, this.dirLight.shadow.bias = -1e-3, this.dirLight.shadow.mapSize.set(1024, 1024), this.dirLight.shadow.camera.near = 0.5, this.dirLight.shadow.camera.far = 500, this.dirLight.shadow.camera.left = -100, this.dirLight.shadow.camera.right = 100, this.dirLight.shadow.camera.top = 100, this.dirLight.shadow.camera.bottom = -100;
        }
        updateDirLightPosition(t) {
          const { x: e, y: i, z: n } = new I().addVectors(t, this.offset);
          this.dirLight.position.set(e, i, n), this.dirLight.target.position.copy(t), this.dirLight.target.updateMatrixWorld();
        }
      }
      class ua extends me {
        constructor(t, e = {}) {
          super(t), this.isReflector = true, this.type = "Reflector", this.camera = new Ve();
          const i = this, n = e.color !== void 0 ? new ht(e.color) : new ht(8355711), r = e.textureWidth || 512, a = e.textureHeight || 512, o = e.clipBias || 0, c = e.shader || ua.ReflectorShader, l = e.multisample !== void 0 ? e.multisample : 4, h = new Yi(), d = new I(), u = new I(), f = new I(), p = new ft(), m = new I(0, 0, -1), g = new jt(), A = new I(), x = new I(), b = new jt(), y = new ft(), M = this.camera, T = new In(r, a, {
            samples: l,
            type: Ci
          }), R = new Ni({
            name: c.name !== void 0 ? c.name : "unspecified",
            uniforms: Zo.clone(c.uniforms),
            fragmentShader: c.fragmentShader,
            vertexShader: c.vertexShader
          });
          R.uniforms.tDiffuse.value = T.texture, R.uniforms.color.value = n, R.uniforms.textureMatrix.value = y, this.material = R, this.onBeforeRender = function(B, S, E) {
            if (u.setFromMatrixPosition(i.matrixWorld), f.setFromMatrixPosition(E.matrixWorld), p.extractRotation(i.matrixWorld), d.set(0, 0, 1), d.applyMatrix4(p), A.subVectors(u, f), A.dot(d) > 0) return;
            A.reflect(d).negate(), A.add(u), p.extractRotation(E.matrixWorld), m.set(0, 0, -1), m.applyMatrix4(p), m.add(f), x.subVectors(u, m), x.reflect(d).negate(), x.add(u), M.position.copy(A), M.up.set(0, 1, 0), M.up.applyMatrix4(p), M.up.reflect(d), M.lookAt(x), M.far = E.far, M.updateMatrixWorld(), M.projectionMatrix.copy(E.projectionMatrix), y.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), y.multiply(M.projectionMatrix), y.multiply(M.matrixWorldInverse), y.multiply(i.matrixWorld), h.setFromNormalAndCoplanarPoint(d, u), h.applyMatrix4(M.matrixWorldInverse), g.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
            const P = M.projectionMatrix;
            b.x = (Math.sign(g.x) + P.elements[8]) / P.elements[0], b.y = (Math.sign(g.y) + P.elements[9]) / P.elements[5], b.z = -1, b.w = (1 + P.elements[10]) / P.elements[14], g.multiplyScalar(2 / g.dot(b)), P.elements[2] = g.x, P.elements[6] = g.y, P.elements[10] = g.z + 1 - o, P.elements[14] = g.w, i.visible = false;
            const G = B.getRenderTarget(), H = B.xr.enabled, Y = B.shadowMap.autoUpdate;
            B.xr.enabled = false, B.shadowMap.autoUpdate = false, B.setRenderTarget(T), B.state.buffers.depth.setMask(true), B.autoClear === false && B.clear(), B.render(S, M), B.xr.enabled = H, B.shadowMap.autoUpdate = Y, B.setRenderTarget(G);
            const et = E.viewport;
            et !== void 0 && B.state.viewport(et), i.visible = true;
          }, this.getRenderTarget = function() {
            return T;
          }, this.dispose = function() {
            T.dispose(), i.material.dispose();
          };
        }
      }
      ua.ReflectorShader = {
        name: "ReflectorShader",
        uniforms: {
          color: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          textureMatrix: {
            value: null
          }
        },
        vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
        fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      class fa extends me {
        constructor(t, e = {}) {
          super(t), this.isRefractor = true, this.type = "Refractor", this.camera = new Ve();
          const i = this, n = e.color !== void 0 ? new ht(e.color) : new ht(8355711), r = e.textureWidth || 512, a = e.textureHeight || 512, o = e.clipBias || 0, c = e.shader || fa.RefractorShader, l = e.multisample !== void 0 ? e.multisample : 4, h = this.camera;
          h.matrixAutoUpdate = false, h.userData.refractor = true;
          const d = new Yi(), u = new ft(), f = new In(r, a, {
            samples: l,
            type: Ci
          });
          this.material = new Ni({
            name: c.name !== void 0 ? c.name : "unspecified",
            uniforms: Zo.clone(c.uniforms),
            vertexShader: c.vertexShader,
            fragmentShader: c.fragmentShader,
            transparent: true
          }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = u;
          const p = function() {
            const b = new I(), y = new I(), M = new ft(), T = new I(), R = new I();
            return function(S) {
              return b.setFromMatrixPosition(i.matrixWorld), y.setFromMatrixPosition(S.matrixWorld), T.subVectors(b, y), M.extractRotation(i.matrixWorld), R.set(0, 0, 1), R.applyMatrix4(M), T.dot(R) < 0;
            };
          }(), m = function() {
            const b = new I(), y = new I(), M = new ue(), T = new I();
            return function() {
              i.matrixWorld.decompose(y, M, T), b.set(0, 0, 1).applyQuaternion(M).normalize(), b.negate(), d.setFromNormalAndCoplanarPoint(b, y);
            };
          }(), g = function() {
            const b = new Yi(), y = new jt(), M = new jt();
            return function(R) {
              h.matrixWorld.copy(R.matrixWorld), h.matrixWorldInverse.copy(h.matrixWorld).invert(), h.projectionMatrix.copy(R.projectionMatrix), h.far = R.far, b.copy(d), b.applyMatrix4(h.matrixWorldInverse), y.set(b.normal.x, b.normal.y, b.normal.z, b.constant);
              const B = h.projectionMatrix;
              M.x = (Math.sign(y.x) + B.elements[8]) / B.elements[0], M.y = (Math.sign(y.y) + B.elements[9]) / B.elements[5], M.z = -1, M.w = (1 + B.elements[10]) / B.elements[14], y.multiplyScalar(2 / y.dot(M)), B.elements[2] = y.x, B.elements[6] = y.y, B.elements[10] = y.z + 1 - o, B.elements[14] = y.w;
            };
          }();
          function A(b) {
            u.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), u.multiply(b.projectionMatrix), u.multiply(b.matrixWorldInverse), u.multiply(i.matrixWorld);
          }
          function x(b, y, M) {
            i.visible = false;
            const T = b.getRenderTarget(), R = b.xr.enabled, B = b.shadowMap.autoUpdate;
            b.xr.enabled = false, b.shadowMap.autoUpdate = false, b.setRenderTarget(f), b.autoClear === false && b.clear(), b.render(y, h), b.xr.enabled = R, b.shadowMap.autoUpdate = B, b.setRenderTarget(T);
            const S = M.viewport;
            S !== void 0 && b.state.viewport(S), i.visible = true;
          }
          this.onBeforeRender = function(b, y, M) {
            M.userData.refractor !== true && p(M) && (m(), A(M), g(M), x(b, y, M));
          }, this.getRenderTarget = function() {
            return f;
          }, this.dispose = function() {
            f.dispose(), i.material.dispose();
          };
        }
      }
      fa.RefractorShader = {
        name: "RefractorShader",
        uniforms: {
          color: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          textureMatrix: {
            value: null
          }
        },
        vertexShader: `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      class fc extends me {
        constructor(t, e = {}) {
          super(t), this.isWater = true, this.type = "Water";
          const i = this, n = e.color !== void 0 ? new ht(e.color) : new ht(16777215), r = e.textureWidth !== void 0 ? e.textureWidth : 512, a = e.textureHeight !== void 0 ? e.textureHeight : 512, o = e.clipBias !== void 0 ? e.clipBias : 0, c = e.flowDirection !== void 0 ? e.flowDirection : new rt(1, 0), l = e.flowSpeed !== void 0 ? e.flowSpeed : 0.03, h = e.reflectivity !== void 0 ? e.reflectivity : 0.02, d = e.scale !== void 0 ? e.scale : 1, u = e.shader !== void 0 ? e.shader : fc.WaterShader, f = e.isFoggy !== void 0 ? e.isFoggy : true, p = new hi(), m = e.flowMap || void 0, g = e.normalMap0 || p.load("./water/Water_1_M_Normal.jpg"), A = e.normalMap1 || p.load("./water/Water_2_M_Normal.jpg"), x = 0.15, b = x * 0.5, y = new ft(), M = new jp();
          if (ua === void 0) {
            console.error("THREE.Water: Required component Reflector not found.");
            return;
          }
          if (fa === void 0) {
            console.error("THREE.Water: Required component Refractor not found.");
            return;
          }
          const T = new ua(t, {
            textureWidth: r,
            textureHeight: a,
            clipBias: o
          }), R = new fa(t, {
            textureWidth: r,
            textureHeight: a,
            clipBias: o
          });
          T.matrixAutoUpdate = false, R.matrixAutoUpdate = false;
          const B = this.createFogCompatibleShader(u, f);
          this.material = new Ni({
            name: B.name,
            uniforms: Zo.merge([
              ct.fog,
              B.uniforms
            ]),
            vertexShader: B.vertexShader,
            fragmentShader: B.fragmentShader,
            transparent: true,
            fog: true
          }), this.material.uniforms.fogTime = {
            value: 0
          }, this.material.uniforms.perlinNoise = {
            value: e.perlinNoise || new Pe()
          }, m !== void 0 ? (this.material.defines.USE_FLOWMAP = "", this.material.uniforms.tFlowMap = {
            type: "t",
            value: m
          }) : this.material.uniforms.flowDirection = {
            type: "v2",
            value: c
          }, g.wrapS = g.wrapT = ni, A.wrapS = A.wrapT = ni, this.material.uniforms.tReflectionMap.value = T.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = R.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = g, this.material.uniforms.tNormalMap1.value = A, this.material.uniforms.color.value = n, this.material.uniforms.reflectivity.value = h, this.material.uniforms.textureMatrix.value = y, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = b, this.material.uniforms.config.value.z = b, this.material.uniforms.config.value.w = d;
          function S(P) {
            y.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), y.multiply(P.projectionMatrix), y.multiply(P.matrixWorldInverse), y.multiply(i.matrixWorld);
          }
          function E() {
            const P = M.getDelta(), G = i.material.uniforms.config;
            G.value.x += l * P, G.value.y = G.value.x + b, G.value.x >= x ? (G.value.x = 0, G.value.y = b) : G.value.y >= x && (G.value.y = G.value.y - x);
          }
          this.onBeforeRender = function(P, G, H) {
            S(H), E(), i.visible = false, T.matrixWorld.copy(i.matrixWorld), R.matrixWorld.copy(i.matrixWorld), T.onBeforeRender(P, G, H), R.onBeforeRender(P, G, H), i.visible = true;
          };
        }
        createFogCompatibleShader(t, e) {
          return {
            name: "WaterShaderWithFog",
            uniforms: t.uniforms,
            vertexShader: `
      #include <common>
      #include <fog_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      
      uniform mat4 textureMatrix;
      
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;
      
      void main() {
        vUv = uv;
        vCoord = textureMatrix * vec4( position, 1.0 );
        
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vToEye = cameraPosition - worldPosition.xyz;
        
        vec4 mvPosition = viewMatrix * worldPosition;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
      }
    `,
            fragmentShader: `
      #include <common>
      #include <fog_pars_fragment>
      #include <logdepthbuf_pars_fragment>

      uniform sampler2D tReflectionMap;
      uniform sampler2D tRefractionMap;
      uniform sampler2D tNormalMap0;
      uniform sampler2D tNormalMap1;
      uniform sampler2D heightMap;
      
      #ifdef USE_FLOWMAP
          uniform sampler2D tFlowMap;
      #else
          uniform vec2 flowDirection;
      #endif
      
      uniform vec3 color;
      uniform float reflectivity;
      uniform vec4 config;
      
      varying vec4 vCoord;
      varying vec2 vUv;
      varying vec3 vToEye;

      void main() {
          #include <logdepthbuf_fragment>

          float flowMapOffset0 = config.x;
          float flowMapOffset1 = config.y;
          float halfCycle = config.z;
          float scale = config.w;

          vec3 toEye = normalize( vToEye );

          // Sample height map and discard high areas
          float height = texture2D(heightMap, vUv).r;  
          if (height > 0.5) {
              discard;
          }  

          // Determine flow direction
          vec2 flow;
          #ifdef USE_FLOWMAP
              flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
          #else
              flow = flowDirection;
          #endif
          flow.x *= - 1.0;

          // Sample normal maps (distort UVs with flow data)
          vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
          vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

          // Linear interpolate to get the final normal color
          float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
          vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

          // Calculate normal vector
          vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

          // Calculate the fresnel term to blend reflection and refraction maps
          float theta = max( dot( toEye, normal ), 0.0 );
          float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

          // Calculate final UV coords
          vec3 coord = vCoord.xyz / vCoord.w;
          vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

          vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
          vec4 refractColor = texture2D( tRefractionMap, uv );

          // Multiply water color with the mix of both textures
          gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

          #include <tonemapping_fragment>
          #include <colorspace_fragment>
          #include <fog_fragment>
      }
    `
          };
        }
      }
      fc.WaterShader = {
        name: "WaterShader",
        uniforms: {
          color: {
            type: "c",
            value: null
          },
          reflectivity: {
            type: "f",
            value: 0
          },
          tReflectionMap: {
            type: "t",
            value: null
          },
          tRefractionMap: {
            type: "t",
            value: null
          },
          tNormalMap0: {
            type: "t",
            value: null
          },
          tNormalMap1: {
            type: "t",
            value: null
          },
          textureMatrix: {
            type: "m4",
            value: null
          },
          config: {
            type: "v4",
            value: new jt()
          }
        },
        vertexShader: "",
        fragmentShader: ""
      };
      class gP {
        constructor(t, e) {
          this._scene = t, this._waterMeshWidth = 1220, this._waterMeshHeight = 1220, this._s = 1, this.tLoader = new hi(), this.isFoggy = e, this._initialize();
        }
        _initialize() {
          const t = this.tLoader.load("./map/heights_map.jpg", () => {
            t.needsUpdate = true, this.initializeWater(t);
          });
          t.wrapS = t.wrapT = ni, t.repeat.set(this._s, this._s), this.waterFlowDirMap = this.tLoader.load("./map/water_flow_map.jpeg"), this.waterFlowDirMap.wrapS = this.waterFlowDirMap.wrapT = ni, this.waterFlowDirMap.repeat.set(this._s, this._s);
        }
        initializeWater(t) {
          const i = new hi().load("./noise/perlin_noise.png");
          i.wrapS = i.wrapT = ni, this.waterGeometry = new vr(this._waterMeshWidth, this._waterMeshHeight, 512, 512), this.water = new fc(this.waterGeometry, {
            scale: 1,
            flowSpeed: 0.04,
            reflectivity: 0.35,
            flowMap: this.waterFlowDirMap,
            perlinNoise: i
          }), this.water.material && this.water.material.uniforms ? (this.water.material.uniforms.heightMap = {
            value: t
          }, this.water.material.uniforms.heightMap.needsUpdate = true, this.water.material.uniforms.fogTime = {
            value: 0
          }, this.water.material.uniforms.perlinNoise = {
            value: i
          }) : console.warn("Water material or uniforms are undefined."), this.water.position.y = -9, this.water.rotation.x = -Math.PI / 2, this._scene.add(this.water);
        }
      }
      class _P {
        constructor(t, e) {
          this.terrain = t, this.totalTime = 0, this.shaders = e;
        }
        fogHuck() {
          Qt.fog_fragment = `
#ifdef USE_FOG
  vec3 fogOrigin = cameraPosition;
  vec3 fogDirection = normalize(vWorldPosition - fogOrigin);
  float fogDepth = distance(vWorldPosition, fogOrigin);

  // Sample Perlin noise texture using world position
  // vec2 uv_m = vWorldPosition.xz * 0.0001; // Scale for large terrain
  vec2 uv_m = vWorldPosition.xz * 0.00005 + vec2(fogTime * 0.000000001, 0.0);
  float noiseSample = texture2D(perlinNoise, uv_m).r; // Grayscale sample

  // Modulate fog depth with noise
  fogDepth *= mix(noiseSample, 1.0, saturate((fogDepth - 5000.0) / 5000.0));
  fogDepth *= fogDepth;

  float heightFactor = 0.05;
  float fogFactor = heightFactor * exp(-fogOrigin.y * fogDensity) * (
      1.0 - exp(-fogDepth * fogDirection.y * fogDensity)) / fogDirection.y;
  fogFactor = saturate(fogFactor);

  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`, Qt.fog_pars_fragment = `
#ifdef USE_FOG
  uniform float fogTime;
  uniform vec3 fogColor;
  uniform sampler2D perlinNoise;
  varying vec3 vWorldPosition;
  #ifdef FOG_EXP2
    uniform float fogDensity;
  #else
    uniform float fogNear;
    uniform float fogFar;
  #endif
#endif`, Qt.fog_vertex = `
#ifdef USE_FOG
  #ifdef CUSTOM_FOG_POSITION
    vWorldPosition = worldPosition.xyz;
  #else
    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
  #endif
#endif`, Qt.fog_pars_vertex = `
#ifdef USE_FOG
  varying vec3 vWorldPosition;
#endif`;
        }
        fogStep(t) {
          this.totalTime += t;
          for (let e of this.shaders) e.uniforms.fogTime.value = this.totalTime, e.needsUpdate = true;
        }
      }
      class mP {
        constructor(t) {
          this.worldPhysics = t;
        }
        createVegetationCollider(t = {
          x: 0,
          y: 0,
          z: 0
        }, e = 1, i = {
          w: 1,
          x: 0,
          y: 0,
          z: 0
        }, n) {
          return this._setCollider(t, e, i, n);
        }
        _setCollider(t, e, i, n) {
          let r;
          return n.startsWith("stump") ? r = li.ColliderDesc.ball(e * 0.6) : n.startsWith("stone") ? r = li.ColliderDesc.ball(e * 3) : r = li.ColliderDesc.cylinder(e, e * 0.2), r.setTranslation(t.x, t.y, t.z), this.worldPhysics.createCollider(r);
        }
      }
      class wP {
        constructor(t, e) {
          this.vegetationGroup = t, this.shaders = e, this.perlinTexture = this.createPerlinTexture();
        }
        createPerlinTexture() {
          const e = new hi().load("./noise/perlin_noise.png");
          return e.wrapS = e.wrapT = ni, e;
        }
        modify() {
          this.vegetationGroup.traverse((t) => {
            t.isMesh && (Array.isArray(t.material) ? t.material : [
              t.material
            ]).forEach((i) => {
              i.isMeshStandardMaterial && (i.onBeforeCompile = (n) => {
                n.uniforms.fogTime = {
                  value: 0
                }, n.uniforms.perlinNoise = {
                  value: this.perlinTexture
                }, this.shaders.push(n);
              });
            });
          });
        }
      }
      const bP = Math.PI / 180;
      function pa(s) {
        return s * bP;
      }
      const Sn = {
        x: 2,
        y: 2,
        z: 2
      }, Al = {
        x: 0,
        y: -80,
        z: 0
      }, gl = {
        maxX: 400,
        minX: -400,
        maxZ: 400,
        minZ: -400
      }, po = {
        maxX: 500,
        minX: -500,
        maxZ: 500,
        minZ: -500
      }, Ao = {
        x: -40,
        y: 50,
        z: -40
      }, yP = {
        x: 80,
        y: 50,
        z: -180
      }, xP = {
        minX: 30,
        maxX: 200,
        minZ: 80,
        maxZ: 170
      };
      class vP {
        constructor(t = 4) {
          this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null;
        }
        _initWorker(t) {
          if (!this.workers[t]) {
            const e = this.workerCreator();
            e.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e;
          }
        }
        _getIdleWorker() {
          for (let t = 0; t < this.pool; t++) if (!(this.workerStatus & 1 << t)) return t;
          return -1;
        }
        _onMessage(t, e) {
          const i = this.workersResolve[t];
          if (i && i(e), this.queue.length) {
            const { resolve: n, msg: r, transfer: a } = this.queue.shift();
            this.workersResolve[t] = n, this.workers[t].postMessage(r, a);
          } else this.workerStatus ^= 1 << t;
        }
        setWorkerCreator(t) {
          this.workerCreator = t;
        }
        setWorkerLimit(t) {
          this.pool = t;
        }
        postMessage(t, e) {
          return new Promise((i) => {
            const n = this._getIdleWorker();
            n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = i, this.workers[n].postMessage(t, e)) : this.queue.push({
              resolve: i,
              msg: t,
              transfer: e
            });
          });
        }
        dispose() {
          this.workers.forEach((t) => t.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
        }
      }
      const EP = 0, jf = 2, SP = 1, qf = 2, CP = 0, IP = 1, MP = 10, TP = 0, HA = 9, VA = 15, WA = 16, jA = 22, qA = 37, XA = 43, YA = 76, KA = 83, JA = 97, ZA = 100, $A = 103, tg = 109, eg = 165, ig = 166, Td = 1000066e3;
      class RP {
        constructor() {
          this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [
            {
              vendorId: 0,
              descriptorType: 0,
              descriptorBlockSize: 0,
              versionNumber: 2,
              colorModel: 0,
              colorPrimaries: 1,
              transferFunction: 2,
              flags: 0,
              texelBlockDimension: [
                0,
                0,
                0,
                0
              ],
              bytesPlane: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              ],
              samples: []
            }
          ], this.keyValue = {}, this.globalData = null;
        }
      }
      class Ds {
        constructor(t, e, i, n) {
          this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(t.buffer, t.byteOffset + e, i), this._littleEndian = n, this._offset = 0;
        }
        _nextUint8() {
          const t = this._dataView.getUint8(this._offset);
          return this._offset += 1, t;
        }
        _nextUint16() {
          const t = this._dataView.getUint16(this._offset, this._littleEndian);
          return this._offset += 2, t;
        }
        _nextUint32() {
          const t = this._dataView.getUint32(this._offset, this._littleEndian);
          return this._offset += 4, t;
        }
        _nextUint64() {
          const t = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
          return this._offset += 8, t;
        }
        _nextInt32() {
          const t = this._dataView.getInt32(this._offset, this._littleEndian);
          return this._offset += 4, t;
        }
        _nextUint8Array(t) {
          const e = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, t);
          return this._offset += t, e;
        }
        _skip(t) {
          return this._offset += t, this;
        }
        _scan(t, e) {
          e === void 0 && (e = 0);
          const i = this._offset;
          let n = 0;
          for (; this._dataView.getUint8(this._offset) !== e && n < t; ) n++, this._offset++;
          return n < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n);
        }
      }
      const pi = [
        171,
        75,
        84,
        88,
        32,
        50,
        48,
        187,
        13,
        10,
        26,
        10
      ];
      function Xf(s) {
        return new TextDecoder().decode(s);
      }
      function BP(s) {
        const t = new Uint8Array(s.buffer, s.byteOffset, pi.length);
        if (t[0] !== pi[0] || t[1] !== pi[1] || t[2] !== pi[2] || t[3] !== pi[3] || t[4] !== pi[4] || t[5] !== pi[5] || t[6] !== pi[6] || t[7] !== pi[7] || t[8] !== pi[8] || t[9] !== pi[9] || t[10] !== pi[10] || t[11] !== pi[11]) throw new Error("Missing KTX 2.0 identifier.");
        const e = new RP(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new Ds(s, pi.length, i, true);
        e.vkFormat = n._nextUint32(), e.typeSize = n._nextUint32(), e.pixelWidth = n._nextUint32(), e.pixelHeight = n._nextUint32(), e.pixelDepth = n._nextUint32(), e.layerCount = n._nextUint32(), e.faceCount = n._nextUint32();
        const r = n._nextUint32();
        e.supercompressionScheme = n._nextUint32();
        const a = n._nextUint32(), o = n._nextUint32(), c = n._nextUint32(), l = n._nextUint32(), h = n._nextUint64(), d = n._nextUint64(), u = new Ds(s, pi.length + i, 3 * r * 8, true);
        for (let Z = 0; Z < r; Z++) e.levels.push({
          levelData: new Uint8Array(s.buffer, s.byteOffset + u._nextUint64(), u._nextUint64()),
          uncompressedByteLength: u._nextUint64()
        });
        const f = new Ds(s, a, o, true), p = {
          vendorId: f._skip(4)._nextUint16(),
          descriptorType: f._nextUint16(),
          versionNumber: f._nextUint16(),
          descriptorBlockSize: f._nextUint16(),
          colorModel: f._nextUint8(),
          colorPrimaries: f._nextUint8(),
          transferFunction: f._nextUint8(),
          flags: f._nextUint8(),
          texelBlockDimension: [
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8()
          ],
          bytesPlane: [
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8()
          ],
          samples: []
        }, m = (p.descriptorBlockSize / 4 - 6) / 4;
        for (let Z = 0; Z < m; Z++) {
          const W = {
            bitOffset: f._nextUint16(),
            bitLength: f._nextUint8(),
            channelType: f._nextUint8(),
            samplePosition: [
              f._nextUint8(),
              f._nextUint8(),
              f._nextUint8(),
              f._nextUint8()
            ],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
          };
          64 & W.channelType ? (W.sampleLower = f._nextInt32(), W.sampleUpper = f._nextInt32()) : (W.sampleLower = f._nextUint32(), W.sampleUpper = f._nextUint32()), p.samples[Z] = W;
        }
        e.dataFormatDescriptor.length = 0, e.dataFormatDescriptor.push(p);
        const g = new Ds(s, c, l, true);
        for (; g._offset < l; ) {
          const Z = g._nextUint32(), W = g._scan(Z), st = Xf(W);
          if (e.keyValue[st] = g._nextUint8Array(Z - W.byteLength - 1), st.match(/^ktx/i)) {
            const dt = Xf(e.keyValue[st]);
            e.keyValue[st] = dt.substring(0, dt.lastIndexOf("\0"));
          }
          g._skip(Z % 4 ? 4 - Z % 4 : 0);
        }
        if (d <= 0) return e;
        const A = new Ds(s, h, d, true), x = A._nextUint16(), b = A._nextUint16(), y = A._nextUint32(), M = A._nextUint32(), T = A._nextUint32(), R = A._nextUint32(), B = [];
        for (let Z = 0; Z < r; Z++) B.push({
          imageFlags: A._nextUint32(),
          rgbSliceByteOffset: A._nextUint32(),
          rgbSliceByteLength: A._nextUint32(),
          alphaSliceByteOffset: A._nextUint32(),
          alphaSliceByteLength: A._nextUint32()
        });
        const S = h + A._offset, E = S + y, P = E + M, G = P + T, H = new Uint8Array(s.buffer, s.byteOffset + S, y), Y = new Uint8Array(s.buffer, s.byteOffset + E, M), et = new Uint8Array(s.buffer, s.byteOffset + P, T), q = new Uint8Array(s.buffer, s.byteOffset + G, R);
        return e.globalData = {
          endpointCount: x,
          selectorCount: b,
          imageDescs: B,
          endpointsData: H,
          selectorsData: Y,
          tablesData: et,
          extendedData: q
        }, e;
      }
      let _l, wn, Mh;
      const ml = {
        env: {
          emscripten_notify_memory_growth: function(s) {
            Mh = new Uint8Array(wn.exports.memory.buffer);
          }
        }
      };
      class DP {
        init() {
          return _l || (_l = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Yf).then((t) => t.arrayBuffer()).then((t) => WebAssembly.instantiate(t, ml)).then(this._init) : WebAssembly.instantiate(Buffer.from(Yf, "base64"), ml).then(this._init), _l);
        }
        _init(t) {
          wn = t.instance, ml.env.emscripten_notify_memory_growth(0);
        }
        decode(t, e = 0) {
          if (!wn) throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const i = t.byteLength, n = wn.exports.malloc(i);
          Mh.set(t, n), e = e || Number(wn.exports.ZSTD_findDecompressedSize(n, i));
          const r = wn.exports.malloc(e), a = wn.exports.ZSTD_decompress(r, e, n, i), o = Mh.slice(r, r + a);
          return wn.exports.free(n), wn.exports.free(r), o;
        }
      }
      const Yf = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", PP = "display-p3", FP = "display-p3-linear", wl = /* @__PURE__ */ new WeakMap();
      let bl = 0, yl;
      class Fi extends Ui {
        constructor(t) {
          super(t), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new vP(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
        }
        setTranscoderPath(t) {
          return this.transcoderPath = t, this;
        }
        setWorkerLimit(t) {
          return this.workerPool.setWorkerLimit(t), this;
        }
        async detectSupportAsync(t) {
          return this.workerConfig = {
            astcSupported: await t.hasFeatureAsync("texture-compression-astc"),
            astcHDRSupported: false,
            etc1Supported: await t.hasFeatureAsync("texture-compression-etc1"),
            etc2Supported: await t.hasFeatureAsync("texture-compression-etc2"),
            dxtSupported: await t.hasFeatureAsync("texture-compression-bc"),
            bptcSupported: await t.hasFeatureAsync("texture-compression-bptc"),
            pvrtcSupported: await t.hasFeatureAsync("texture-compression-pvrtc")
          }, this;
        }
        detectSupport(t) {
          return t.isWebGPURenderer === true ? this.workerConfig = {
            astcSupported: t.hasFeature("texture-compression-astc"),
            astcHDRSupported: false,
            etc1Supported: t.hasFeature("texture-compression-etc1"),
            etc2Supported: t.hasFeature("texture-compression-etc2"),
            dxtSupported: t.hasFeature("texture-compression-bc"),
            bptcSupported: t.hasFeature("texture-compression-bptc"),
            pvrtcSupported: t.hasFeature("texture-compression-pvrtc")
          } : this.workerConfig = {
            astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
            astcHDRSupported: t.extensions.has("WEBGL_compressed_texture_astc") && t.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
            etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
          }, this;
        }
        init() {
          if (!this.transcoderPending) {
            const t = new Ar(this.manager);
            t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials);
            const e = t.loadAsync("basis_transcoder.js"), i = new Ar(this.manager);
            i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
            const n = i.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([
              e,
              n
            ]).then(([r, a]) => {
              const o = Fi.BasisWorker.toString(), c = [
                "/* constants */",
                "let _EngineFormat = " + JSON.stringify(Fi.EngineFormat),
                "let _EngineType = " + JSON.stringify(Fi.EngineType),
                "let _TranscoderFormat = " + JSON.stringify(Fi.TranscoderFormat),
                "let _BasisFormat = " + JSON.stringify(Fi.BasisFormat),
                "/* basis_transcoder.js */",
                r,
                "/* worker */",
                o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
              ].join(`
`);
              this.workerSourceURL = URL.createObjectURL(new Blob([
                c
              ])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
                const l = new Worker(this.workerSourceURL), h = this.transcoderBinary.slice(0);
                return l.postMessage({
                  type: "init",
                  config: this.workerConfig,
                  transcoderBinary: h
                }, [
                  h
                ]), l;
              });
            }), bl > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), bl++;
          }
          return this.transcoderPending;
        }
        load(t, e, i, n) {
          if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
          const r = new Ar(this.manager);
          r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(t, (a) => {
            this.parse(a, e, n);
          }, i, n);
        }
        parse(t, e, i) {
          if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
          if (wl.has(t)) return wl.get(t).promise.then(e).catch(i);
          this._createTexture(t).then((n) => e ? e(n) : null).catch(i);
        }
        _createTextureFrom(t, e) {
          const { type: i, error: n, data: { faces: r, width: a, height: o, format: c, type: l, dfdFlags: h } } = t;
          if (i === "error") return Promise.reject(n);
          let d;
          if (e.faceCount === 6) d = new fm(r, c, l);
          else {
            const u = r[0].mipmaps;
            d = e.layerCount > 1 ? new um(u, a, o, e.layerCount, c, l) : new $o(u, a, o, c, l);
          }
          return d.minFilter = r[0].mipmaps.length === 1 ? Re : Zi, d.magFilter = Re, d.generateMipmaps = false, d.needsUpdate = true, d.colorSpace = ng(e), d.premultiplyAlpha = !!(h & SP), d;
        }
        async _createTexture(t, e = {}) {
          const i = BP(new Uint8Array(t)), n = i.vkFormat === Td && i.dataFormatDescriptor[0].colorModel === 167;
          if (!(i.vkFormat === TP || n && !this.workerConfig.astcHDRSupported)) return kP(i);
          const a = e, o = this.init().then(() => this.workerPool.postMessage({
            type: "transcode",
            buffer: t,
            taskConfig: a
          }, [
            t
          ])).then((c) => this._createTextureFrom(c.data, i));
          return wl.set(t, {
            promise: o
          }), o;
        }
        dispose() {
          this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), bl--;
        }
      }
      Fi.BasisFormat = {
        ETC1S: 0,
        UASTC: 1,
        UASTC_HDR: 2
      };
      Fi.TranscoderFormat = {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16,
        BC6H: 22,
        RGB_HALF: 24,
        RGBA_HALF: 25
      };
      Fi.EngineFormat = {
        RGBAFormat: We,
        RGBA_ASTC_4x4_Format: Ks,
        RGB_BPTC_UNSIGNED_Format: Do,
        RGBA_BPTC_Format: Qs,
        RGBA_ETC2_EAC_Format: Bo,
        RGBA_PVRTC_4BPPV1_Format: Mo,
        RGBA_S3TC_DXT5_Format: Us,
        RGB_ETC1_Format: To,
        RGB_ETC2_Format: Ro,
        RGB_PVRTC_4BPPV1_Format: Io,
        RGBA_S3TC_DXT1_Format: Ns
      };
      Fi.EngineType = {
        UnsignedByteType: Je,
        HalfFloatType: Ci,
        FloatType: ii
      };
      Fi.BasisWorker = function() {
        let s, t, e;
        const i = _EngineFormat, n = _EngineType, r = _TranscoderFormat, a = _BasisFormat;
        self.addEventListener("message", function(p) {
          const m = p.data;
          switch (m.type) {
            case "init":
              s = m.config, o(m.transcoderBinary);
              break;
            case "transcode":
              t.then(() => {
                try {
                  const { faces: g, buffers: A, width: x, height: b, hasAlpha: y, format: M, type: T, dfdFlags: R } = c(m.buffer);
                  self.postMessage({
                    type: "transcode",
                    id: m.id,
                    data: {
                      faces: g,
                      width: x,
                      height: b,
                      hasAlpha: y,
                      format: M,
                      type: T,
                      dfdFlags: R
                    }
                  }, A);
                } catch (g) {
                  console.error(g), self.postMessage({
                    type: "error",
                    id: m.id,
                    error: g.message
                  });
                }
              });
              break;
          }
        });
        function o(p) {
          t = new Promise((m) => {
            e = {
              wasmBinary: p,
              onRuntimeInitialized: m
            }, BASIS(e);
          }).then(() => {
            e.initializeBasis(), e.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
        }
        function c(p) {
          const m = new e.KTX2File(new Uint8Array(p));
          function g() {
            m.close(), m.delete();
          }
          if (!m.isValid()) throw g(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
          let A;
          if (m.isUASTC()) A = a.UASTC;
          else if (m.isETC1S()) A = a.ETC1S;
          else if (m.isHDR()) A = a.UASTC_HDR;
          else throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
          const x = m.getWidth(), b = m.getHeight(), y = m.getLayers() || 1, M = m.getLevels(), T = m.getFaces(), R = m.getHasAlpha(), B = m.getDFDFlags(), { transcoderFormat: S, engineFormat: E, engineType: P } = d(A, x, b, R);
          if (!x || !b || !M) throw g(), new Error("THREE.KTX2Loader:	Invalid texture");
          if (!m.startTranscoding()) throw g(), new Error("THREE.KTX2Loader: .startTranscoding failed");
          const G = [], H = [];
          for (let Y = 0; Y < T; Y++) {
            const et = [];
            for (let q = 0; q < M; q++) {
              const Z = [];
              let W, st;
              for (let Et = 0; Et < y; Et++) {
                const Pt = m.getImageLevelInfo(q, Et, Y);
                Y === 0 && q === 0 && Et === 0 && (Pt.origWidth % 4 !== 0 || Pt.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), M > 1 ? (W = Pt.origWidth, st = Pt.origHeight) : (W = Pt.width, st = Pt.height);
                let Vt = new Uint8Array(m.getImageTranscodedSizeInBytes(q, Et, 0, S));
                const K = m.transcodeImage(Vt, q, Et, Y, S, 0, -1, -1);
                if (P === n.HalfFloatType && (Vt = new Uint16Array(Vt.buffer, Vt.byteOffset, Vt.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !K) throw g(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                Z.push(Vt);
              }
              const dt = f(Z);
              et.push({
                data: dt,
                width: W,
                height: st
              }), H.push(dt.buffer);
            }
            G.push({
              mipmaps: et,
              width: x,
              height: b,
              format: E,
              type: P
            });
          }
          return g(), {
            faces: G,
            buffers: H,
            width: x,
            height: b,
            hasAlpha: R,
            dfdFlags: B,
            format: E,
            type: P
          };
        }
        const l = [
          {
            if: "astcSupported",
            basisFormat: [
              a.UASTC
            ],
            transcoderFormat: [
              r.ASTC_4x4,
              r.ASTC_4x4
            ],
            engineFormat: [
              i.RGBA_ASTC_4x4_Format,
              i.RGBA_ASTC_4x4_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 1 / 0,
            priorityUASTC: 1,
            needsPowerOfTwo: false
          },
          {
            if: "bptcSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.BC7_M5,
              r.BC7_M5
            ],
            engineFormat: [
              i.RGBA_BPTC_Format,
              i.RGBA_BPTC_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: false
          },
          {
            if: "dxtSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.BC1,
              r.BC3
            ],
            engineFormat: [
              i.RGBA_S3TC_DXT1_Format,
              i.RGBA_S3TC_DXT5_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: false
          },
          {
            if: "etc2Supported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.ETC1,
              r.ETC2
            ],
            engineFormat: [
              i.RGB_ETC2_Format,
              i.RGBA_ETC2_EAC_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: false
          },
          {
            if: "etc1Supported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.ETC1
            ],
            engineFormat: [
              i.RGB_ETC1_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: false
          },
          {
            if: "pvrtcSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.PVRTC1_4_RGB,
              r.PVRTC1_4_RGBA
            ],
            engineFormat: [
              i.RGB_PVRTC_4BPPV1_Format,
              i.RGBA_PVRTC_4BPPV1_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: true
          },
          {
            if: "bptcSupported",
            basisFormat: [
              a.UASTC_HDR
            ],
            transcoderFormat: [
              r.BC6H
            ],
            engineFormat: [
              i.RGB_BPTC_UNSIGNED_Format
            ],
            engineType: [
              n.HalfFloatType
            ],
            priorityHDR: 1,
            needsPowerOfTwo: false
          },
          {
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.RGBA32,
              r.RGBA32
            ],
            engineFormat: [
              i.RGBAFormat,
              i.RGBAFormat
            ],
            engineType: [
              n.UnsignedByteType,
              n.UnsignedByteType
            ],
            priorityETC1S: 100,
            priorityUASTC: 100,
            needsPowerOfTwo: false
          },
          {
            basisFormat: [
              a.UASTC_HDR
            ],
            transcoderFormat: [
              r.RGBA_HALF
            ],
            engineFormat: [
              i.RGBAFormat
            ],
            engineType: [
              n.HalfFloatType
            ],
            priorityHDR: 100,
            needsPowerOfTwo: false
          }
        ], h = {
          [a.ETC1S]: l.filter((p) => p.basisFormat.includes(a.ETC1S)).sort((p, m) => p.priorityUASTC - m.priorityUASTC),
          [a.UASTC]: l.filter((p) => p.basisFormat.includes(a.UASTC)).sort((p, m) => p.priorityUASTC - m.priorityUASTC),
          [a.UASTC_HDR]: l.filter((p) => p.basisFormat.includes(a.UASTC_HDR)).sort((p, m) => p.priorityHDR - m.priorityHDR)
        };
        function d(p, m, g, A) {
          const x = h[p];
          for (let b = 0; b < x.length; b++) {
            const y = x[b];
            if (y.if && !s[y.if] || !y.basisFormat.includes(p) || A && y.transcoderFormat.length < 2 || y.needsPowerOfTwo && !(u(m) && u(g))) continue;
            const M = y.transcoderFormat[A ? 1 : 0], T = y.engineFormat[A ? 1 : 0], R = y.engineType[0];
            return {
              transcoderFormat: M,
              engineFormat: T,
              engineType: R
            };
          }
          throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
        }
        function u(p) {
          return p <= 2 ? true : (p & p - 1) === 0 && p !== 0;
        }
        function f(p) {
          if (p.length === 1) return p[0];
          let m = 0;
          for (let x = 0; x < p.length; x++) {
            const b = p[x];
            m += b.byteLength;
          }
          const g = new Uint8Array(m);
          let A = 0;
          for (let x = 0; x < p.length; x++) {
            const b = p[x];
            g.set(b, A), A += b.byteLength;
          }
          return g;
        }
      };
      const LP = /* @__PURE__ */ new Set([
        We,
        ur,
        xn
      ]), xl = {
        [tg]: We,
        [JA]: We,
        [qA]: We,
        [XA]: We,
        [$A]: ur,
        [KA]: ur,
        [WA]: ur,
        [jA]: ur,
        [ZA]: xn,
        [YA]: xn,
        [VA]: xn,
        [HA]: xn,
        [Td]: Ks,
        [ig]: Js,
        [eg]: Js
      }, vl = {
        [tg]: ii,
        [JA]: Ci,
        [qA]: Je,
        [XA]: Je,
        [$A]: ii,
        [KA]: Ci,
        [WA]: Je,
        [jA]: Je,
        [ZA]: ii,
        [YA]: Ci,
        [VA]: Je,
        [HA]: Je,
        [Td]: Ci,
        [ig]: Je,
        [eg]: Je
      };
      async function kP(s) {
        const { vkFormat: t } = s;
        if (xl[t] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        let e;
        s.supercompressionScheme === jf && (yl || (yl = new Promise(async (r) => {
          const a = new DP();
          await a.init(), r(a);
        })), e = await yl);
        const i = [];
        for (let r = 0; r < s.levels.length; r++) {
          const a = Math.max(1, s.pixelWidth >> r), o = Math.max(1, s.pixelHeight >> r), c = s.pixelDepth ? Math.max(1, s.pixelDepth >> r) : 0, l = s.levels[r];
          let h;
          if (s.supercompressionScheme === EP) h = l.levelData;
          else if (s.supercompressionScheme === jf) h = e.decode(l.levelData, l.uncompressedByteLength);
          else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
          let d;
          vl[t] === ii ? d = new Float32Array(h.buffer, h.byteOffset, h.byteLength / Float32Array.BYTES_PER_ELEMENT) : vl[t] === Ci ? d = new Uint16Array(h.buffer, h.byteOffset, h.byteLength / Uint16Array.BYTES_PER_ELEMENT) : d = h, i.push({
            data: d,
            width: a,
            height: o,
            depth: c
          });
        }
        let n;
        if (LP.has(xl[t])) n = s.pixelDepth === 0 ? new ga(i[0].data, s.pixelWidth, s.pixelHeight) : new mp(i[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
        else {
          if (s.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
          n = new $o(i, s.pixelWidth, s.pixelHeight), n.minFilter = i.length === 1 ? Re : Zi, n.magFilter = Re;
        }
        return n.mipmaps = i, n.type = vl[t], n.format = xl[t], n.colorSpace = ng(s), n.needsUpdate = true, Promise.resolve(n);
      }
      function ng(s) {
        const t = s.dataFormatDescriptor[0];
        return t.colorPrimaries === IP ? t.transferFunction === qf ? ne : di : t.colorPrimaries === MP ? t.transferFunction === qf ? PP : FP : (t.colorPrimaries === CP || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`), an);
      }
      var NP = function() {
        var s = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", t = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", e = new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          3,
          2,
          0,
          0,
          5,
          3,
          1,
          0,
          1,
          12,
          1,
          0,
          10,
          22,
          2,
          12,
          0,
          65,
          0,
          65,
          0,
          65,
          0,
          252,
          10,
          0,
          0,
          11,
          7,
          0,
          65,
          0,
          253,
          15,
          26,
          11
        ]), i = new Uint8Array([
          32,
          0,
          65,
          2,
          1,
          106,
          34,
          33,
          3,
          128,
          11,
          4,
          13,
          64,
          6,
          253,
          10,
          7,
          15,
          116,
          127,
          5,
          8,
          12,
          40,
          16,
          19,
          54,
          20,
          9,
          27,
          255,
          113,
          17,
          42,
          67,
          24,
          23,
          146,
          148,
          18,
          14,
          22,
          45,
          70,
          69,
          56,
          114,
          101,
          21,
          25,
          63,
          75,
          136,
          108,
          28,
          118,
          29,
          73,
          115
        ]);
        if (typeof WebAssembly != "object") return {
          supported: false
        };
        var n = WebAssembly.validate(e) ? t : s, r, a = WebAssembly.instantiate(o(n), {}).then(function(A) {
          r = A.instance, r.exports.__wasm_call_ctors();
        });
        function o(A) {
          for (var x = new Uint8Array(A.length), b = 0; b < A.length; ++b) {
            var y = A.charCodeAt(b);
            x[b] = y > 96 ? y - 97 : y > 64 ? y - 39 : y + 4;
          }
          for (var M = 0, b = 0; b < A.length; ++b) x[M++] = x[b] < 60 ? i[x[b]] : (x[b] - 60) * 64 + x[++b];
          return x.buffer.slice(0, M);
        }
        function c(A, x, b, y, M, T) {
          var R = r.exports.sbrk, B = b + 3 & -4, S = R(B * y), E = R(M.length), P = new Uint8Array(r.exports.memory.buffer);
          P.set(M, E);
          var G = A(S, b, y, E, M.length);
          if (G == 0 && T && T(S, B, y), x.set(P.subarray(S, S + b * y)), R(S - R(0)), G != 0) throw new Error("Malformed buffer data: " + G);
        }
        var l = {
          NONE: "",
          OCTAHEDRAL: "meshopt_decodeFilterOct",
          QUATERNION: "meshopt_decodeFilterQuat",
          EXPONENTIAL: "meshopt_decodeFilterExp"
        }, h = {
          ATTRIBUTES: "meshopt_decodeVertexBuffer",
          TRIANGLES: "meshopt_decodeIndexBuffer",
          INDICES: "meshopt_decodeIndexSequence"
        }, d = [], u = 0;
        function f(A) {
          var x = {
            object: new Worker(A),
            pending: 0,
            requests: {}
          };
          return x.object.onmessage = function(b) {
            var y = b.data;
            x.pending -= y.count, x.requests[y.id][y.action](y.value), delete x.requests[y.id];
          }, x;
        }
        function p(A) {
          for (var x = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + c.toString() + g.toString(), b = new Blob([
            x
          ], {
            type: "text/javascript"
          }), y = URL.createObjectURL(b), M = 0; M < A; ++M) d[M] = f(y);
          URL.revokeObjectURL(y);
        }
        function m(A, x, b, y, M) {
          for (var T = d[0], R = 1; R < d.length; ++R) d[R].pending < T.pending && (T = d[R]);
          return new Promise(function(B, S) {
            var E = new Uint8Array(b), P = u++;
            T.pending += A, T.requests[P] = {
              resolve: B,
              reject: S
            }, T.object.postMessage({
              id: P,
              count: A,
              size: x,
              source: E,
              mode: y,
              filter: M
            }, [
              E.buffer
            ]);
          });
        }
        function g(A) {
          a.then(function() {
            var x = A.data;
            try {
              var b = new Uint8Array(x.count * x.size);
              c(r.exports[x.mode], b, x.count, x.size, x.source, r.exports[x.filter]), self.postMessage({
                id: x.id,
                count: x.count,
                action: "resolve",
                value: b
              }, [
                b.buffer
              ]);
            } catch (y) {
              self.postMessage({
                id: x.id,
                count: x.count,
                action: "reject",
                value: y
              });
            }
          });
        }
        return {
          ready: a,
          supported: true,
          useWorkers: function(A) {
            p(A);
          },
          decodeVertexBuffer: function(A, x, b, y, M) {
            c(r.exports.meshopt_decodeVertexBuffer, A, x, b, y, r.exports[l[M]]);
          },
          decodeIndexBuffer: function(A, x, b, y) {
            c(r.exports.meshopt_decodeIndexBuffer, A, x, b, y);
          },
          decodeIndexSequence: function(A, x, b, y) {
            c(r.exports.meshopt_decodeIndexSequence, A, x, b, y);
          },
          decodeGltfBuffer: function(A, x, b, y, M, T) {
            c(r.exports[h[M]], A, x, b, y, r.exports[l[T]]);
          },
          decodeGltfBufferAsync: function(A, x, b, y, M) {
            return d.length > 0 ? m(A, x, b, h[y], l[M]) : a.then(function() {
              var T = new Uint8Array(A * x);
              return c(r.exports[h[y]], T, A, x, b, r.exports[l[M]]), T;
            });
          }
        };
      }();
      const UP = async (s, t, e) => new Promise((i, n) => {
        s.load("./map/map.glb", (r) => {
          const a = r.scene;
          a.scale.set(Sn.x, Sn.y, Sn.z), a.translateY(0), a._forShadersModifiable = true, a.traverse((o) => {
            o.isMesh && (o.receiveShadow = true, o.castShadow = true);
          }), e && t.add(a), i(a);
        }, void 0, (r) => {
          console.error("Error loading terrain:", r), n(r);
        });
      }), ks = /* @__PURE__ */ (() => {
        let s = null, t = null;
        return async (e, i, n, r, a, o = {
          x: 0,
          y: 0,
          z: 0
        }, c = {
          x: Sn.x,
          y: Sn.y,
          z: Sn.z
        }, l = {
          x: 0,
          y: 0,
          z: 0
        }, h = "") => new Promise((d, u) => {
          s || (s = new da(e), t = new Fi(), t.setTranscoderPath("./libs/basis/"), t.detectSupport(i), s.setKTX2Loader(t), s.setMeshoptDecoder(NP)), s.load(r, (f) => {
            const p = f.scene;
            p.position.set(o.x, o.y, o.z), p.scale.set(c.x, c.y, c.z), p.rotateX(l.x), p.rotateY(l.y), p.rotateZ(l.z), p._forShadersModifiable = true, h && (p.name = h), p.traverse((m) => {
              m.isMesh && (m.receiveShadow = true, m.castShadow = true);
            }), n && a.add(p), d(p);
          }, void 0, (f) => {
            console.error("Error loading terrain:", f), u(f);
          });
        });
      })();
      class QP {
        constructor(t, e, i, n, r, a) {
          this.shaders = a, this.worldPhysics = r, this.mapScaleFactor = {
            x: 1,
            y: 1,
            z: 1
          }, this.renderer = e, this.loadingManager = i, this.scene = t, this.toRadian = pa, this.terrain = n, this.objectsTypesSrc = [
            {
              type: "tree1",
              src: "./models/trees/scene_c1.glb"
            },
            {
              type: "tree2",
              src: "./models/trees/scene_c2.glb"
            },
            {
              type: "tree3",
              src: "./models/trees/scene_c3.glb"
            },
            {
              type: "tree4",
              src: "./models/trees/scene_c4.glb"
            },
            {
              type: "tree5",
              src: "./models/trees/scene_c5.glb"
            },
            {
              type: "tree6",
              src: "./models/trees/scene_c6.glb"
            },
            {
              type: "tree7",
              src: "./models/trees/scene_c7.glb"
            },
            {
              type: "tree8",
              src: "./models/trees/scene_c8.glb"
            },
            {
              type: "tree9",
              src: "./models/trees/scene_c9.glb"
            },
            {
              type: "tree10",
              src: "./models/trees/scene_c10.glb"
            },
            {
              type: "rottenTree1",
              src: "./models/trees/scene_c11.glb"
            },
            {
              type: "stump1",
              src: "./models/trees/scene_c12.glb"
            },
            {
              type: "stone1",
              src: "./models/trees/scene_c13.glb"
            }
          ], this.vegetationGroup = new ki(), this.vegetationGroup.name = "vegetation", this.loadedModels = {}, this.heightData = null, this.sizeX = 0, this.sizeZ = 0, this.minX = 0, this.minZ = 0, this.maxX = 0, this.maxZ = 0, this.maskData = null, this.scene.add(this.vegetationGroup), this.colliderBuilder = new mP(this.worldPhysics), this.vegetationShaderModifiers = new wP(this.vegetationGroup, this.shaders);
        }
        async preloadModels(t) {
          const e = this.objectsTypesSrc.map(({ type: i, src: n }) => ks(this.loadingManager, this.renderer, false, n, this.scene).then((r) => {
            this.loadedModels[i] = r;
          }).catch((r) => (console.error(`Error loading model ${i}:`, r), null)));
          await Promise.allSettled(e), t();
        }
        addObject(t = {
          x: 0,
          y: 0,
          z: 0
        }, e = 1, i = {
          x: 0,
          y: 0,
          z: 0
        }, n) {
          const r = this.loadedModels[n];
          if (!r) {
            console.warn(`Model ${n} not loaded yet!`);
            return;
          }
          const a = r.clone();
          a.position.set(t.x, t.y, t.z), a.scale.set(e, e, e), a.rotation.set(i.x, i.y, i.z), a.layers.enable(Object.keys(this.loadedModels).indexOf(n) % 32), a.traverse((o) => {
            o.isMesh && (o.receiveShadow = true, o.castShadow = true);
          }), this.vegetationGroup.add(a);
        }
        async setVegetation() {
          let t = 200;
          const e = 640, i = 30, n = 1, r = 0, a = 0.5;
          await this.setVegetationAreas(), await this.createHeightsTexture();
          for (let o = 0; o < t; o++) {
            const c = this.objectsTypesSrc[Math.floor(Math.random() * this.objectsTypesSrc.length)].type, l = ke.randFloatSpread(e * 2), h = ke.randFloatSpread(e * 2) / n + r;
            if (this._sampleVegetationMask(l, h) < a) {
              o--;
              continue;
            }
            const u = this.getHeightAt(l, h), f = this.toRadian(Math.random() * 360);
            let p = (Math.random() + 0.5) * i;
            c === "stone1" && (p /= 5), this.colliderBuilder.createVegetationCollider({
              x: l,
              y: u,
              z: h
            }, p * 0.5, {
              w: 1,
              x: 0,
              y: f,
              z: 0
            }, c), this.addObject({
              x: l,
              y: u,
              z: h
            }, p, {
              x: 0,
              y: f,
              z: 0
            }, c);
          }
          this.vegetationShaderModifiers.modify();
        }
        getTerrainMesh() {
          if (!this.terrain) throw new Error("No mesh found");
          if (this.terrainMesh = this.terrain.getObjectByName("Plane"), !this.terrainMesh) throw new Error("\u274C Terrain 'Plane' not found!");
          let t = [];
          if (this.terrainMesh.type === "Mesh" ? t.push(this.terrainMesh) : t = this.terrainMesh.children.filter((r) => r.isMesh), t.length === 0) throw new Error("\u274C No meshes found inside 'Plane'!");
          const e = t.map((r) => {
            const a = r.geometry.clone().applyMatrix4(r.matrixWorld);
            return a.scale(this.mapScaleFactor.x, this.mapScaleFactor.y, this.mapScaleFactor.z), a;
          }), i = nc(e, false);
          if (!i) throw new Error("\u274C Terrain mesh not found!");
          return new me(i, new ci({
            color: 65280
          }));
        }
        async _extractHeightData() {
          let t;
          try {
            t = this.getTerrainMesh();
          } catch (p) {
            return console.error(p.message), null;
          }
          const i = t.geometry.attributes.position.array, n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
          for (let p = 0; p < i.length; p += 3) n.add(i[p]), r.add(i[p + 2]);
          const a = 100, o = 100, c = Math.min(...n), l = Math.max(...n), h = Math.min(...r), d = Math.max(...r), u = new Float32Array(a * o), f = new Float32Array(a * o).fill(0);
          for (let p = 0; p < i.length; p += 3) {
            const m = i[p], g = i[p + 2], A = i[p + 1], x = (m - c) / (l - c) || 1, b = (g - h) / (d - h) || 1, y = Math.floor(x * (a - 1)), T = Math.floor(b * (o - 1)) * a + y;
            u[T] += A, f[T] += 1;
          }
          for (let p = 0; p < u.length; p++) f[p] > 0 && (u[p] /= f[p]);
          return {
            heightData: u,
            sizeX: a,
            sizeZ: o,
            minX: c,
            minZ: h,
            maxX: l,
            maxZ: d
          };
        }
        async createHeightsTexture() {
          const t = await this._extractHeightData();
          if (!t) return console.error("Failed to extract height data!"), null;
          const { heightData: e, sizeX: i, sizeZ: n, minX: r, minZ: a, maxX: o, maxZ: c } = t;
          return this.heightData = e, this.sizeX = i, this.sizeZ = n, this.minX = r, this.minZ = a, this.maxX = o, this.maxZ = c, t;
        }
        getHeightAt(t, e) {
          const i = Math.floor((t - this.minX) / (this.maxX - this.minX) * (this.sizeX - 1)), n = Math.floor((e - this.minZ) / (this.maxZ - this.minZ) * (this.sizeZ - 1)), r = Math.max(0, Math.min(this.sizeX - 1, i)), o = Math.max(0, Math.min(this.sizeZ - 1, n)) * this.sizeX + r;
          return this.heightData[o] || 0;
        }
        _precomputeVegetationMask() {
          if (!this.vegMask) {
            console.warn("Vegetation mask not loaded!");
            return;
          }
          const t = document.createElement("canvas"), e = t.getContext("2d");
          t.width = this.vegMask.image.width, t.height = this.vegMask.image.height, e.drawImage(this.vegMask.image, 0, 0), this.maskData = new Uint8Array(t.width * t.height);
          const i = e.getImageData(0, 0, t.width, t.height).data;
          for (let n = 0; n < i.length; n += 4) {
            const r = n / 4;
            this.maskData[r] = i[n];
          }
        }
        _sampleVegetationMask(t, e) {
          if (this.maskData === null && this._precomputeVegetationMask(), !this.maskData) return console.warn("Vegetation mask not loaded!"), 1;
          let i = (t - this.minX) / (this.maxX - this.minX), n = (e - this.minZ) / (this.maxZ - this.minZ);
          i = Math.min(Math.max(i, 0), 1), n = Math.min(Math.max(n, 0), 1);
          const r = Math.floor(i * this.vegMask.image.width), o = Math.floor(n * this.vegMask.image.height) * this.vegMask.image.width + r;
          return this.maskData[o] / 255;
        }
        async setVegetationAreas() {
          return new Promise((t, e) => {
            this.vegMask = new hi().load("./map/vegetation_map.jpeg", (i) => {
              console.log("Vegetation mask loaded successfully!"), this.vegMask = i, this.vegMask.wrapS = this.vegMask.wrapT = _i, this.vegMask.minFilter = Re, this.vegMask.magFilter = Re, t(this.vegMask);
            }, void 0, (i) => {
              console.error("Failed to load vegetation mask:", i);
            });
          });
        }
      }
      function OP(s) {
        return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
      }
      var Eo = {
        exports: {}
      }, zP = Eo.exports, Kf;
      function GP() {
        return Kf || (Kf = 1, function(s, t) {
          (function(e, i) {
            s.exports = i();
          })(zP, function() {
            var e = function() {
              function i(f) {
                return a.appendChild(f.dom), f;
              }
              function n(f) {
                for (var p = 0; p < a.children.length; p++) a.children[p].style.display = p === f ? "block" : "none";
                r = f;
              }
              var r = 0, a = document.createElement("div");
              a.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", a.addEventListener("click", function(f) {
                f.preventDefault(), n(++r % a.children.length);
              }, false);
              var o = (performance || Date).now(), c = o, l = 0, h = i(new e.Panel("FPS", "#0ff", "#002")), d = i(new e.Panel("MS", "#0f0", "#020"));
              if (self.performance && self.performance.memory) var u = i(new e.Panel("MB", "#f08", "#201"));
              return n(0), {
                REVISION: 16,
                dom: a,
                addPanel: i,
                showPanel: n,
                begin: function() {
                  o = (performance || Date).now();
                },
                end: function() {
                  l++;
                  var f = (performance || Date).now();
                  if (d.update(f - o, 200), f > c + 1e3 && (h.update(1e3 * l / (f - c), 100), c = f, l = 0, u)) {
                    var p = performance.memory;
                    u.update(p.usedJSHeapSize / 1048576, p.jsHeapSizeLimit / 1048576);
                  }
                  return f;
                },
                update: function() {
                  o = this.end();
                },
                domElement: a,
                setMode: n
              };
            };
            return e.Panel = function(i, n, r) {
              var a = 1 / 0, o = 0, c = Math.round, l = c(window.devicePixelRatio || 1), h = 80 * l, d = 48 * l, u = 3 * l, f = 2 * l, p = 3 * l, m = 15 * l, g = 74 * l, A = 30 * l, x = document.createElement("canvas");
              x.width = h, x.height = d, x.style.cssText = "width:80px;height:48px";
              var b = x.getContext("2d");
              return b.font = "bold " + 9 * l + "px Helvetica,Arial,sans-serif", b.textBaseline = "top", b.fillStyle = r, b.fillRect(0, 0, h, d), b.fillStyle = n, b.fillText(i, u, f), b.fillRect(p, m, g, A), b.fillStyle = r, b.globalAlpha = 0.9, b.fillRect(p, m, g, A), {
                dom: x,
                update: function(y, M) {
                  a = Math.min(a, y), o = Math.max(o, y), b.fillStyle = r, b.globalAlpha = 1, b.fillRect(0, 0, h, m), b.fillStyle = n, b.fillText(c(y) + " " + i + " (" + c(a) + "-" + c(o) + ")", u, f), b.drawImage(x, p + l, m, g - l, A, p, m, g - l, A), b.fillRect(p + g - l, m, l, A), b.fillStyle = r, b.globalAlpha = 0.9, b.fillRect(p + g - l, m, l, c((1 - y / M) * A));
                }
              };
            }, e;
          });
        }(Eo)), Eo.exports;
      }
      var HP = GP();
      const VP = OP(HP);
      class WP {
        constructor() {
          this.stats = new VP(), this.stats.showPanel(0), document.body.appendChild(this.stats.dom);
        }
      }
      function jP({ x: s = 0, y: t = 0, z: e = 0 } = {}) {
        const i = (h) => h * Math.PI / 180, n = Math.cos(i(s) / 2), r = Math.sin(i(s) / 2), a = Math.cos(i(t) / 2), o = Math.sin(i(t) / 2), c = Math.cos(i(e) / 2), l = Math.sin(i(e) / 2);
        return {
          w: n * a * c + r * o * l,
          x: r * a * c - n * o * l,
          y: n * o * c + r * a * l,
          z: n * a * l - r * o * c
        };
      }
      class qP {
        constructor(t) {
          this.worldPhysics = t;
        }
        toRadian(t) {
          return THREE.MathUtils.degToRad(t);
        }
        createColliders(t = []) {
          if (!Array.isArray(t)) throw Error("Colliders data must be an array.");
          return this._setColliders(t);
        }
        _setColliders(t) {
          return t.forEach(({ name: e, positions: i, dimensions: n, rotations: r, figure: a, group: o }) => {
            const c = jP(r);
            this._initCollider(i, c, n, a, e, o);
          }), true;
        }
        _initCollider(t = {
          x: 0,
          y: 0,
          z: 0
        }, e = {
          w: 1,
          x: 0,
          y: 0,
          z: 0
        }, i = {
          x: 0,
          y: 0,
          z: 0
        }, n = "cylinder", r = "unknown", a = "") {
          let o;
          switch (n) {
            case "ball":
              o = li.ColliderDesc.ball(i.x * 0.6);
              break;
            case "cylinder":
              o = li.ColliderDesc.cylinder(i.y, i.x);
              break;
            case "cuboid":
              o = li.ColliderDesc.cuboid(i.x, i.y, i.z);
              break;
            default:
              throw new Error(`Unsupported collider type: ${n}`);
          }
          o.setTranslation(t.x, t.y, t.z), o.setRotation(e);
          const c = this.worldPhysics.createCollider(o);
          return c.userData = {
            name: r,
            group: a
          }, c;
        }
      }
      const rg = [
        {
          name: "profile",
          positions: {
            x: -185,
            y: 20,
            z: 94
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "credits",
          positions: {
            x: -54,
            y: 20,
            z: 335
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "hobbies",
          positions: {
            x: 284,
            y: 6,
            z: 176
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "history",
          positions: {
            x: 148,
            y: 28,
            z: 37
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "skills",
          positions: {
            x: 198,
            y: 13,
            z: -64
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "contacts",
          positions: {
            x: -165,
            y: 26,
            z: -260
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "portfolio",
          positions: {
            x: -45,
            y: 18,
            z: -83
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "magic bridge",
          positions: {
            x: -59,
            y: 15,
            z: 20
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "wind mill",
          positions: {
            x: 40,
            y: 10,
            z: 249
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "book stand",
          positions: {
            x: 128,
            y: 16,
            z: 64
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "dead end",
          positions: {
            x: 168,
            y: 30,
            z: -251
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "tavern",
          positions: {
            x: -31,
            y: 16,
            z: -195
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "book stand",
          positions: {
            x: 156,
            y: 30,
            z: 45
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "book stand"
        },
        {
          name: "house box",
          positions: {
            x: 298,
            y: 36,
            z: -20
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 44,
            y: 30,
            z: 26
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "tent",
          positions: {
            x: 284,
            y: 22,
            z: -155
          },
          rotations: {
            x: 0,
            y: 25,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 10,
            z: 17
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "tent",
          positions: {
            x: 250,
            y: 13,
            z: -175
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 2,
            z: 3
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "anvils",
          positions: {
            x: 253,
            y: 10,
            z: -160
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "anvils",
          positions: {
            x: 278,
            y: 10,
            z: -65
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 298,
            y: 10,
            z: -65
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 2,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 321,
            y: 12,
            z: -60
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 320,
            y: 12,
            z: 0
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 251,
            y: 10,
            z: -20
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "house box",
          positions: {
            x: 346,
            y: 14,
            z: 248
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 14,
            z: 26
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 346,
            y: 3,
            z: 215
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 8
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 325,
            y: 10,
            z: 207
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 17,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 358,
            y: 10,
            z: 207
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 365,
            y: 10,
            z: 214
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 316,
            y: 3,
            z: 241
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 1,
            z: 35
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 290,
            y: -3,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 296,
            y: -1,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 301,
            y: 1,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 305,
            y: 2.5,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 309,
            y: 10,
            z: 222
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 15
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 309,
            y: 10,
            z: 263
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 11
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 317,
            y: 10,
            z: 274
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 298,
            y: 6,
            z: 235
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 11,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 298,
            y: 6,
            z: 251
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 11,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 275,
            y: 0,
            z: 234
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 9,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 235,
            y: 0,
            z: 234
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 9,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 255,
            y: 0,
            z: 264
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 30,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 285,
            y: 0,
            z: 257
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 265,
            y: 0,
            z: 220
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 13
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 244,
            y: 0,
            z: 220
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 13
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "pier",
          positions: {
            x: 258,
            y: -6,
            z: 248
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 35,
            y: 1,
            z: 17
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "pier",
          positions: {
            x: 255,
            y: -6,
            z: 217
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 12,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "boat",
          positions: {
            x: 255,
            y: -10,
            z: 192
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 21,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "water tower",
          positions: {
            x: 305,
            y: 35,
            z: 140
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "well",
          positions: {
            x: 400,
            y: 15,
            z: 219
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "palms",
          positions: {
            x: 346,
            y: 15,
            z: 174
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 8,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "palms",
          positions: {
            x: 339,
            y: 15,
            z: 315
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 8,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 237.5,
            y: -1,
            z: 258
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 271,
            y: -3,
            z: 258
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 277,
            y: -2,
            z: 259.5
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "rug",
          positions: {
            x: 315,
            y: 10,
            z: 309
          },
          rotations: {
            x: 0,
            y: 170,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 8
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "tavern",
          positions: {
            x: -231,
            y: 40,
            z: -355
          },
          rotations: {
            x: 0,
            y: 80,
            z: 0
          },
          dimensions: {
            x: 36,
            y: 30,
            z: 24
          },
          figure: "cuboid",
          group: "tavern"
        },
        {
          name: "tavern",
          positions: {
            x: -264,
            y: 20,
            z: -350
          },
          rotations: {
            x: 0,
            y: 80,
            z: 0
          },
          dimensions: {
            x: 18,
            y: 8,
            z: 6
          },
          figure: "cuboid",
          group: "tavern"
        },
        {
          name: "wind mill",
          positions: {
            x: -160,
            y: 32,
            z: 420
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "wind mill"
        },
        {
          name: "house",
          positions: {
            x: -258,
            y: 30,
            z: 5
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 15,
            z: 20
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "porch",
          positions: {
            x: -258,
            y: 30,
            z: 55
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 15,
            z: 5
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "stumps",
          positions: {
            x: -284,
            y: 22,
            z: 52
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 6
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house cylinder",
          positions: {
            x: -227,
            y: 30,
            z: 5
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 12,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house small cylinder",
          positions: {
            x: -196,
            y: 25,
            z: -22
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 7,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house small cylinder",
          positions: {
            x: -186,
            y: 22,
            z: 7
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -190,
            y: 20,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -216,
            y: 20,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -230,
            y: 25,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 10,
            z: 10
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -210,
            y: 21,
            z: 68
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 2,
            z: 7
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -195,
            y: 19,
            z: 67
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 1,
            z: 5
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -215,
            y: 20,
            z: 77
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "board",
          positions: {
            x: -75,
            y: 28,
            z: -66
          },
          rotations: {
            x: 0,
            y: 85,
            z: 0
          },
          dimensions: {
            x: 15,
            y: 15,
            z: 1
          },
          figure: "cuboid",
          group: "board"
        },
        {
          name: "layer",
          positions: {
            x: 41,
            y: 0,
            z: 60
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 22,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: -19,
            y: 0,
            z: 40
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 24,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: -15,
            y: 2,
            z: 41
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 41,
            y: 2,
            z: 60
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 17,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 4,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 44,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 6,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 41,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 8,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 38,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 10,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 34,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 12,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 29,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 14,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 25,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 16,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 16,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 15,
            y: 24,
            z: 42
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 42,
            y: 16,
            z: 51
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: -12,
            y: 16,
            z: 33
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 12,
            y: 24,
            z: 61
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 39,
            y: 16,
            z: 71
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: -15,
            y: 16,
            z: 52
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: 3,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 15,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: 1,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 25,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: -1,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 35,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: -4,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 50,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 11,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 7,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 9,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 15,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 7,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 5,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 28,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 76,
            y: 3,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 33,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 78,
            y: 1,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 36,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 80,
            y: -3,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 40,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "wall",
          positions: {
            x: 75,
            y: 0,
            z: -270
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 20,
            z: 1
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "wall",
          positions: {
            x: 83,
            y: 0,
            z: -227
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 20,
            z: 1
          },
          figure: "cuboid",
          group: "top bridge"
        }
      ];
      class XP {
        constructor(t) {
          if (this.markerModalContainer = document.getElementById("modal-marker-cont"), !this.markerModalContainer) {
            console.error("Modal container #modal-marker-cont not found!");
            return;
          }
          this._initModalMarker(), this.markersDistanceHandler = t, this.markersDistanceHandler.modalMarker = this, this.activeMarker = null;
        }
        _initModalMarker() {
          this.modal = document.createElement("div"), this.modal.className = "modal-marker", this.markerModalContainer.append(this.modal);
        }
        updateMarkerModalStatus() {
          this.markersDistanceHandler.activeMarker && this.markersDistanceHandler.activeMarker !== this.activeMarker && (this.activeMarker = this.markersDistanceHandler.activeMarker, this.modal.innerHTML = `
                press <kbd>R</kbd> to read <strong> ${this.activeMarker.name}</strong>
            `, this.modal.classList.add("show-marker-modal")), !this.markersDistanceHandler.activeMarker && this.activeMarker && (this.activeMarker = null, this.modal.classList.remove("show-marker-modal"));
        }
      }
      class YP {
        constructor(t) {
          this.markers = (rg || []).filter((e) => e.group === "markers").map((e) => {
            var _a3, _b2, _c2;
            return {
              vec: new I(((_a3 = e.positions) == null ? void 0 : _a3.x) ?? 0, ((_b2 = e.positions) == null ? void 0 : _b2.y) ?? 0, ((_c2 = e.positions) == null ? void 0 : _c2.z) ?? 0),
              ...e
            };
          }), this.activeMarker = null, this.character = t, this.interactDistance = 30;
        }
        updateCharPositionDistance() {
          const t = this.character.mesh.position;
          this.activeMarker = this.markers.find((e) => t.distanceTo(e.vec) < this.interactDistance) || null;
        }
      }
      class KP {
        constructor(t, e, i) {
          if (this.audioPlayer = i, this.chapterModalContainer = document.getElementById("modal-chapter-cont"), !this.chapterModalContainer) {
            console.error("Modal container #modal-chapter-cont not found!");
            return;
          }
          this.chapterViewer = e, this.markersDistanceHandler = t, this.activeModalChapter = null, this._initModalChapter(), document.addEventListener("keydown", (n) => this.handleKeyPress(n));
        }
        _initModalChapter() {
          this.modal = this.chapterViewer.modal.firstElementChild, this.chapterViewer.closeButton.addEventListener("click", () => this.hideChapterModal());
        }
        updateChapterModalStatus() {
          const t = this.markersDistanceHandler.character.basicController._input._keys;
          this.markersDistanceHandler.activeMarker && !this.activeModalChapter && t.read && (this.showChapterModal(), t.read = false), this.activeModalChapter && (t.esc || t.read) && (this.hideChapterModal(), t.esc = false, t.read = false);
        }
        handleKeyPress(t) {
          this.markersDistanceHandler.activeMarker && !this.activeModalChapter && t.keyCode === 82 ? this.showChapterModal() : this.activeModalChapter && (t.code === "Escape" || t.keyCode === 82) && this.hideChapterModal();
        }
        showChapterModal() {
          const t = this.markersDistanceHandler.character.basicController._input;
          this.modal.classList.add("show-chapter-modal"), this.activeModalChapter = this.markersDistanceHandler.activeMarker, this.markersDistanceHandler.modalMarker.modal.classList.remove("show-marker-modal"), t.actionsAllowed = false, this.playOpenInventorySound(), this.chapterViewer.open();
        }
        hideChapterModal() {
          const t = this.markersDistanceHandler.character.basicController._input;
          this.modal.classList.remove("show-chapter-modal"), this.markersDistanceHandler.modalMarker.modal.classList.add("show-marker-modal"), this.activeModalChapter = null, t.actionsAllowed = true, this.playOpenInventorySound(), this.chapterViewer.close();
        }
        playOpenInventorySound() {
          this.audioPlayer && this.audioPlayer.playSound("./sounds/leather_inventory.wav");
        }
      }
      const Jf = {
        type: "change"
      }, Rd = {
        type: "start"
      }, sg = {
        type: "end"
      }, go = new fs(), Zf = new Yi(), JP = Math.cos(70 * ke.DEG2RAD), He = new I(), bi = 2 * Math.PI, _e = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }, El = 1e-6;
      class ag extends Tw {
        constructor(t, e = null) {
          super(t, e), this.state = _e.NONE, this.target = new I(), this.cursor = new I(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
          }, this.mouseButtons = {
            LEFT: ts.ROTATE,
            MIDDLE: ts.DOLLY,
            RIGHT: ts.PAN
          }, this.touches = {
            ONE: Yr.ROTATE,
            TWO: Yr.DOLLY_PAN
          }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new I(), this._lastQuaternion = new ue(), this._lastTargetPosition = new I(), this._quat = new ue().setFromUnitVectors(t.up, new I(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Uu(), this._sphericalDelta = new Uu(), this._scale = 1, this._panOffset = new I(), this._rotateStart = new rt(), this._rotateEnd = new rt(), this._rotateDelta = new rt(), this._panStart = new rt(), this._panEnd = new rt(), this._panDelta = new rt(), this._dollyStart = new rt(), this._dollyEnd = new rt(), this._dollyDelta = new rt(), this._dollyDirection = new I(), this._mouse = new rt(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = $P.bind(this), this._onPointerDown = ZP.bind(this), this._onPointerUp = tF.bind(this), this._onContextMenu = oF.bind(this), this._onMouseWheel = nF.bind(this), this._onKeyDown = rF.bind(this), this._onTouchStart = sF.bind(this), this._onTouchMove = aF.bind(this), this._onMouseDown = eF.bind(this), this._onMouseMove = iF.bind(this), this._interceptControlDown = cF.bind(this), this._interceptControlUp = lF.bind(this), this.domElement !== null && this.connect(this.domElement), this.update();
        }
        connect(t) {
          super.connect(t), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: false
          }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: true,
            capture: true
          }), this.domElement.style.touchAction = "none";
        }
        disconnect() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: true
          }), this.domElement.style.touchAction = "auto";
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(t) {
          t.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = t;
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
        }
        saveState() {
          this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
        }
        reset() {
          this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Jf), this.update(), this.state = _e.NONE;
        }
        update(t = null) {
          const e = this.object.position;
          He.copy(e).sub(this.target), He.applyQuaternion(this._quat), this._spherical.setFromVector3(He), this.autoRotate && this.state === _e.NONE && this._rotateLeft(this._getAutoRotationAngle(t)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
          let i = this.minAzimuthAngle, n = this.maxAzimuthAngle;
          isFinite(i) && isFinite(n) && (i < -Math.PI ? i += bi : i > Math.PI && (i -= bi), n < -Math.PI ? n += bi : n > Math.PI && (n -= bi), i <= n ? this._spherical.theta = Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
          let r = false;
          if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
          else {
            const a = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = a != this._spherical.radius;
          }
          if (He.setFromSpherical(this._spherical), He.applyQuaternion(this._quatInverse), e.copy(this.target).add(He), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let a = null;
            if (this.object.isPerspectiveCamera) {
              const o = He.length();
              a = this._clampDistance(o * this._scale);
              const c = o - a;
              this.object.position.addScaledVector(this._dollyDirection, c), this.object.updateMatrixWorld(), r = !!c;
            } else if (this.object.isOrthographicCamera) {
              const o = new I(this._mouse.x, this._mouse.y, 0);
              o.unproject(this.object);
              const c = this.object.zoom;
              this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = c !== this.object.zoom;
              const l = new I(this._mouse.x, this._mouse.y, 0);
              l.unproject(this.object), this.object.position.sub(l).add(o), this.object.updateMatrixWorld(), a = He.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
            a !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(a).add(this.object.position) : (go.origin.copy(this.object.position), go.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(go.direction)) < JP ? this.object.lookAt(this.target) : (Zf.setFromNormalAndCoplanarPoint(this.object.up, this.target), go.intersectPlane(Zf, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const a = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), a !== this.object.zoom && (this.object.updateProjectionMatrix(), r = true);
          }
          return this._scale = 1, this._performCursorZoom = false, r || this._lastPosition.distanceToSquared(this.object.position) > El || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > El || this._lastTargetPosition.distanceToSquared(this.target) > El ? (this.dispatchEvent(Jf), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
        }
        _getAutoRotationAngle(t) {
          return t !== null ? bi / 60 * this.autoRotateSpeed * t : bi / 60 / 60 * this.autoRotateSpeed;
        }
        _getZoomScale(t) {
          const e = Math.abs(t * 0.01);
          return Math.pow(0.95, this.zoomSpeed * e);
        }
        _rotateLeft(t) {
          this._sphericalDelta.theta -= t;
        }
        _rotateUp(t) {
          this._sphericalDelta.phi -= t;
        }
        _panLeft(t, e) {
          He.setFromMatrixColumn(e, 0), He.multiplyScalar(-t), this._panOffset.add(He);
        }
        _panUp(t, e) {
          this.screenSpacePanning === true ? He.setFromMatrixColumn(e, 1) : (He.setFromMatrixColumn(e, 0), He.crossVectors(this.object.up, He)), He.multiplyScalar(t), this._panOffset.add(He);
        }
        _pan(t, e) {
          const i = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const n = this.object.position;
            He.copy(n).sub(this.target);
            let r = He.length();
            r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * t * r / i.clientHeight, this.object.matrix), this._panUp(2 * e * r / i.clientHeight, this.object.matrix);
          } else this.object.isOrthographicCamera ? (this._panLeft(t * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(e * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
        }
        _dollyOut(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _dollyIn(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _updateZoomParameters(t, e) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = true;
          const i = this.domElement.getBoundingClientRect(), n = t - i.left, r = e - i.top, a = i.width, o = i.height;
          this._mouse.x = n / a * 2 - 1, this._mouse.y = -(r / o) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
        }
        _clampDistance(t) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, t));
        }
        _handleMouseDownRotate(t) {
          this._rotateStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownDolly(t) {
          this._updateZoomParameters(t.clientX, t.clientX), this._dollyStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownPan(t) {
          this._panStart.set(t.clientX, t.clientY);
        }
        _handleMouseMoveRotate(t) {
          this._rotateEnd.set(t.clientX, t.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft(bi * this._rotateDelta.x / e.clientHeight), this._rotateUp(bi * this._rotateDelta.y / e.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
        }
        _handleMouseMoveDolly(t) {
          this._dollyEnd.set(t.clientX, t.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
        }
        _handleMouseMovePan(t) {
          this._panEnd.set(t.clientX, t.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
        }
        _handleMouseWheel(t) {
          this._updateZoomParameters(t.clientX, t.clientY), t.deltaY < 0 ? this._dollyIn(this._getZoomScale(t.deltaY)) : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)), this.update();
        }
        _handleKeyDown(t) {
          let e = false;
          switch (t.code) {
            case this.keys.UP:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(bi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), e = true;
              break;
            case this.keys.BOTTOM:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(-bi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), e = true;
              break;
            case this.keys.LEFT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(bi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), e = true;
              break;
            case this.keys.RIGHT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(-bi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), e = true;
              break;
          }
          e && (t.preventDefault(), this.update());
        }
        _handleTouchStartRotate(t) {
          if (this._pointers.length === 1) this._rotateStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), n = 0.5 * (t.pageY + e.y);
            this._rotateStart.set(i, n);
          }
        }
        _handleTouchStartPan(t) {
          if (this._pointers.length === 1) this._panStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), n = 0.5 * (t.pageY + e.y);
            this._panStart.set(i, n);
          }
        }
        _handleTouchStartDolly(t) {
          const e = this._getSecondPointerPosition(t), i = t.pageX - e.x, n = t.pageY - e.y, r = Math.sqrt(i * i + n * n);
          this._dollyStart.set(0, r);
        }
        _handleTouchStartDollyPan(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enablePan && this._handleTouchStartPan(t);
        }
        _handleTouchStartDollyRotate(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enableRotate && this._handleTouchStartRotate(t);
        }
        _handleTouchMoveRotate(t) {
          if (this._pointers.length == 1) this._rotateEnd.set(t.pageX, t.pageY);
          else {
            const i = this._getSecondPointerPosition(t), n = 0.5 * (t.pageX + i.x), r = 0.5 * (t.pageY + i.y);
            this._rotateEnd.set(n, r);
          }
          this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft(bi * this._rotateDelta.x / e.clientHeight), this._rotateUp(bi * this._rotateDelta.y / e.clientHeight), this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(t) {
          if (this._pointers.length === 1) this._panEnd.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), n = 0.5 * (t.pageY + e.y);
            this._panEnd.set(i, n);
          }
          this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(t) {
          const e = this._getSecondPointerPosition(t), i = t.pageX - e.x, n = t.pageY - e.y, r = Math.sqrt(i * i + n * n);
          this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
          const a = (t.pageX + e.x) * 0.5, o = (t.pageY + e.y) * 0.5;
          this._updateZoomParameters(a, o);
        }
        _handleTouchMoveDollyPan(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enablePan && this._handleTouchMovePan(t);
        }
        _handleTouchMoveDollyRotate(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enableRotate && this._handleTouchMoveRotate(t);
        }
        _addPointer(t) {
          this._pointers.push(t.pointerId);
        }
        _removePointer(t) {
          delete this._pointerPositions[t.pointerId];
          for (let e = 0; e < this._pointers.length; e++) if (this._pointers[e] == t.pointerId) {
            this._pointers.splice(e, 1);
            return;
          }
        }
        _isTrackingPointer(t) {
          for (let e = 0; e < this._pointers.length; e++) if (this._pointers[e] == t.pointerId) return true;
          return false;
        }
        _trackPointer(t) {
          let e = this._pointerPositions[t.pointerId];
          e === void 0 && (e = new rt(), this._pointerPositions[t.pointerId] = e), e.set(t.pageX, t.pageY);
        }
        _getSecondPointerPosition(t) {
          const e = t.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
          return this._pointerPositions[e];
        }
        _customWheelEvent(t) {
          const e = t.deltaMode, i = {
            clientX: t.clientX,
            clientY: t.clientY,
            deltaY: t.deltaY
          };
          switch (e) {
            case 1:
              i.deltaY *= 16;
              break;
            case 2:
              i.deltaY *= 100;
              break;
          }
          return t.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
        }
      }
      function ZP(s) {
        this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(s) && (this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)));
      }
      function $P(s) {
        this.enabled !== false && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
      }
      function tF(s) {
        switch (this._removePointer(s), this._pointers.length) {
          case 0:
            this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(sg), this.state = _e.NONE;
            break;
          case 1:
            const t = this._pointers[0], e = this._pointerPositions[t];
            this._onTouchStart({
              pointerId: t,
              pageX: e.x,
              pageY: e.y
            });
            break;
        }
      }
      function eF(s) {
        let t;
        switch (s.button) {
          case 0:
            t = this.mouseButtons.LEFT;
            break;
          case 1:
            t = this.mouseButtons.MIDDLE;
            break;
          case 2:
            t = this.mouseButtons.RIGHT;
            break;
          default:
            t = -1;
        }
        switch (t) {
          case ts.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(s), this.state = _e.DOLLY;
            break;
          case ts.ROTATE:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = _e.PAN;
            } else {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = _e.ROTATE;
            }
            break;
          case ts.PAN:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = _e.ROTATE;
            } else {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = _e.PAN;
            }
            break;
          default:
            this.state = _e.NONE;
        }
        this.state !== _e.NONE && this.dispatchEvent(Rd);
      }
      function iF(s) {
        switch (this.state) {
          case _e.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(s);
            break;
          case _e.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(s);
            break;
          case _e.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(s);
            break;
        }
      }
      function nF(s) {
        this.enabled === false || this.enableZoom === false || this.state !== _e.NONE || (s.preventDefault(), this.dispatchEvent(Rd), this._handleMouseWheel(this._customWheelEvent(s)), this.dispatchEvent(sg));
      }
      function rF(s) {
        this.enabled !== false && this._handleKeyDown(s);
      }
      function sF(s) {
        switch (this._trackPointer(s), this._pointers.length) {
          case 1:
            switch (this.touches.ONE) {
              case Yr.ROTATE:
                if (this.enableRotate === false) return;
                this._handleTouchStartRotate(s), this.state = _e.TOUCH_ROTATE;
                break;
              case Yr.PAN:
                if (this.enablePan === false) return;
                this._handleTouchStartPan(s), this.state = _e.TOUCH_PAN;
                break;
              default:
                this.state = _e.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case Yr.DOLLY_PAN:
                if (this.enableZoom === false && this.enablePan === false) return;
                this._handleTouchStartDollyPan(s), this.state = _e.TOUCH_DOLLY_PAN;
                break;
              case Yr.DOLLY_ROTATE:
                if (this.enableZoom === false && this.enableRotate === false) return;
                this._handleTouchStartDollyRotate(s), this.state = _e.TOUCH_DOLLY_ROTATE;
                break;
              default:
                this.state = _e.NONE;
            }
            break;
          default:
            this.state = _e.NONE;
        }
        this.state !== _e.NONE && this.dispatchEvent(Rd);
      }
      function aF(s) {
        switch (this._trackPointer(s), this.state) {
          case _e.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(s), this.update();
            break;
          case _e.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(s), this.update();
            break;
          case _e.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(s), this.update();
            break;
          case _e.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(s), this.update();
            break;
          default:
            this.state = _e.NONE;
        }
      }
      function oF(s) {
        this.enabled !== false && s.preventDefault();
      }
      function cF(s) {
        s.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      function lF(s) {
        s.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      class hF {
        constructor(t, e, i, n) {
          this.pages = t, this.marker = e, this.currentSpread = 0, this.onPageChange = n, this.audioPlayer = i, this.frontBtn = document.getElementById("btn-front"), this.backBtn = document.getElementById("btn-back"), this.pageContainer = document.getElementById("page-buttons"), this.asideLinkContainer = document.querySelector(".chapter-aside"), this.setFirstButtonHandler = this.setFirstButtonHandler.bind(this), this.setLastButtonHandler = this.setLastButtonHandler.bind(this), this.frontBtn.addEventListener("click", this.setFirstButtonHandler), this.backBtn.addEventListener("click", this.setLastButtonHandler), this.generateSideButtons(), this.generatePageButtons(), this.updateUI();
        }
        generateSideButtons() {
          const t = this.asideLinkContainer.children;
          t.length > 1 && Array.from(t).forEach((i, n, r) => n !== r.length - 1 && i.remove());
          const e = (i) => {
            for (let n = 0; n < i; n++) {
              const r = document.createElement("a");
              this.asideLinkContainer.prepend(r);
            }
          };
          switch (this.marker) {
            case "portfolio":
              e(1);
              break;
            case "credits":
              e(2);
              break;
            case "contacts":
              e(3);
              break;
            default:
              e(0);
          }
        }
        generatePageButtons() {
          this.pageContainer.innerHTML = "";
          for (let t = 1; t < this.pages.length; t++) {
            const e = document.createElement("button");
            e.classList.add("page-btn"), e.textContent = `Pages ${t * 2 - 1}-${t * 2}`, e.addEventListener("click", () => this.setPage(t)), this.pageContainer.appendChild(e);
          }
        }
        setFirstButtonHandler() {
          this.setPage(0);
        }
        setLastButtonHandler() {
          this.setPage(this.pages.length);
        }
        destroy() {
          this.frontBtn.removeEventListener("click", this.setFirstButtonHandler), this.backBtn.removeEventListener("click", this.setLastButtonHandler), this.pageContainer.innerHTML = "";
        }
        updateUI() {
          this.frontBtn.disabled = this.currentSpread === 0, this.backBtn.disabled = this.currentSpread >= this.pages.length, [
            ...this.pageContainer.children
          ].forEach((t, e) => {
            t.classList.toggle("active", e === this.currentSpread - 1);
          });
        }
        setPage(t) {
          this.currentSpread = t, this.onPageChange(t), this.updateUI(), this.playFlipSound();
        }
        playFlipSound() {
          this.audioPlayer && this.audioPlayer.playSound("./sounds/page-flip.mp3");
        }
      }
      const Wr = {
        portfolio: [
          {
            front: "portfolio-cover",
            back: "portfolio_devices_first",
            links: []
          },
          {
            front: "portfolio_devices_second",
            back: "portfolio_burger_first",
            links: [
              {
                text: "Visit 01",
                link: "https://zaxel.github.io/react_simple_shop"
              }
            ]
          },
          {
            front: "portfolio_burger_second",
            back: "portfolio_resume_first",
            links: [
              {
                text: "Visit 02",
                link: "https://zaxel.github.io/react_burger_shop"
              }
            ]
          },
          {
            front: "portfolio_resume_second",
            back: "portfolio_mixed_first",
            links: [
              {
                text: "Visit 03",
                link: "https://zaxel.github.io/resume_3d"
              }
            ]
          },
          {
            front: "portfolio_mixed_second",
            back: "portfolio_sorter_first",
            links: [
              {
                text: "Visit 04",
                link: "https://zaxel.github.io/mixed_features_react_app"
              }
            ]
          },
          {
            front: "portfolio_sorter_second",
            back: "portfolio_maze_first",
            links: [
              {
                text: "Visit 05",
                link: "https://zaxel.github.io/mail_sorter"
              }
            ]
          },
          {
            front: "portfolio_maze_second",
            back: "portfolio_tetris_first",
            links: [
              {
                text: "Visit 06",
                link: "https://zaxel.github.io/maze-builder/"
              }
            ]
          },
          {
            front: "portfolio_tetris_second",
            back: "portfolio_converter_first",
            links: [
              {
                text: "Visit 07",
                link: "https://zaxel.github.io/tetris/"
              }
            ]
          },
          {
            front: "portfolio_converter_second",
            back: "portfolio_weather_first",
            links: [
              {
                text: "Visit 08",
                link: "https://zaxel.github.io/currency-converter"
              }
            ]
          },
          {
            front: "portfolio_weather_second",
            back: "portfolio_italian-food_first",
            links: [
              {
                text: "Visit 09",
                link: "https://zaxel.github.io/weatherApp"
              }
            ]
          },
          {
            front: "portfolio_italian-food_second",
            back: "portfolio_bigmack_first",
            links: [
              {
                text: "Visit 10",
                link: "https://zaxel.github.io/italian_food"
              }
            ]
          },
          {
            front: "portfolio_bigmack_second",
            back: "portfolio_italian-cuisine_first",
            links: [
              {
                text: "Visit 11",
                link: "https://zaxel.github.io/bigmack/"
              }
            ]
          },
          {
            front: "portfolio_italian-cuisine_second",
            back: "portfolio_mobiler_first",
            links: [
              {
                text: "Visit 12",
                link: "https://zaxel.github.io/foody"
              }
            ]
          },
          {
            front: "portfolio_mobiler_second",
            back: "portfolio_carcharger_first",
            links: [
              {
                text: "Visit 13",
                link: "https://zaxel.github.io/mobiler.com"
              }
            ]
          },
          {
            front: "portfolio_carcharger_second",
            back: "portfolio_bikeshop_first",
            links: [
              {
                text: "Visit 14",
                link: "https://zaxel.github.io/car_charger/dist"
              }
            ]
          },
          {
            front: "portfolio_bikeshop_second",
            back: "cover",
            links: [
              {
                text: "Visit 15",
                link: "https://zaxel.github.io/bike-shop"
              }
            ]
          }
        ],
        profile: [
          {
            front: "profile-cover",
            back: "profile_first"
          },
          {
            front: "profile_second",
            back: "cover"
          }
        ],
        skills: [
          {
            front: "skills-cover",
            back: "skills_first"
          },
          {
            front: "skills_second",
            back: "cover"
          }
        ],
        history: [
          {
            front: "history-cover",
            back: "history_first"
          },
          {
            front: "history_second",
            back: "cover"
          }
        ],
        contacts: [
          {
            front: "contacts-cover",
            back: "contacts_first"
          },
          {
            front: "contacts_second",
            back: "cover",
            links: [
              {
                text: "Call",
                link: "tel:380676780478"
              },
              {
                text: "Mail",
                link: "mailto:sae11.z.alex@gmail.com"
              },
              {
                text: "GitHub",
                link: "https://github.com/zaxel"
              }
            ]
          }
        ],
        hobbies: [
          {
            front: "hobbies-cover",
            back: "hobbies_cycling_first"
          },
          {
            front: "hobbies_cycling_second",
            back: "hobbies_prehistoric_first"
          },
          {
            front: "hobbies_prehistoric_second",
            back: "hobbies_cosmos_first"
          },
          {
            front: "hobbies_cosmos_second",
            back: "cover"
          }
        ],
        credits: [
          {
            front: "credits-cover",
            back: "credits_1_first"
          },
          {
            front: "credits_1_second",
            back: "credits_2_first",
            links: [
              {
                text: "Visit 01",
                link: "https://sketchfab.com/3d-models/af05-basic-modeling-dao-pt-6eab61b7a8e3405a9259eebd65cc7ffd"
              },
              {
                text: "Visit 02",
                link: "https://sketchfab.com/3d-models/medieval-blacksmith-2e4f2725963644c685419dea1e4430df"
              }
            ]
          },
          {
            front: "credits_2_second",
            back: "credits_3_first",
            links: [
              {
                text: "Visit 03",
                link: "https://sketchfab.com/3d-models/the-wandering-smith-b64167041c9543f1bfb58a871da5ce1c"
              },
              {
                text: "Visit 04",
                link: "https://sketchfab.com/3d-models/tavern-medieval-house-eda03fe47db1450a93a4e2102e4caf65"
              }
            ]
          },
          {
            front: "credits_3_second",
            back: "credits_4_first",
            links: [
              {
                text: "Visit 05",
                link: "https://sketchfab.com/3d-models/mill-wind-d53ed9dc8f624db9be4c7f3ec22a8e8b"
              },
              {
                text: "Visit 06",
                link: "https://sketchfab.com/3d-models/fishermans-house-7df29905b3704e61874d5906db9f0a75"
              }
            ]
          },
          {
            front: "credits_4_second",
            back: "credits_5_first",
            links: [
              {
                text: "Visit 07",
                link: "https://sketchfab.com/3d-models/dreamy-bridge-50c3313a16c740a4b02d0ff2e2441889"
              },
              {
                text: "Visit 08",
                link: "https://sketchfab.com/3d-models/old-bridge-6441316f4195400f80d5bdcbfe835d30"
              }
            ]
          },
          {
            front: "credits_5_second",
            back: "credits_6_first",
            links: [
              {
                text: "Visit 09",
                link: "https://sketchfab.com/3d-models/bridge-9328bbfc04a84202a6a97bd59408473a"
              },
              {
                text: "Visit 10",
                link: "https://sketchfab.com/3d-models/medieval-notice-board-6b81d6df32724396bd56e79f6774b25f"
              }
            ]
          },
          {
            front: "credits_6_second",
            back: "cover",
            links: [
              {
                text: "Visit 11",
                link: "https://sketchfab.com/3d-models/the-medieval-book-stand-3e736d23b3f44f0d859b40a4fc13af0d"
              },
              {
                text: "Visit 12",
                link: "https://sketchfab.com/3d-models/stylized-wood-signs-d529ec8478304d45a5048e15cf9cc9db"
              }
            ]
          }
        ]
      };
      class dF {
        constructor(t, e, i) {
          this.markersDistanceHandler = t, this.marker = null, this.lastMarker = null, this.modal = document.getElementById("modal-chapter-cont"), this.closeButton = this.modal.querySelector(".chapter-close"), this.audio = e, this.loadManager = i, this.books = {}, this.currentBook = null, this.raycasterPointerMoveHandler = null, this.initScene(), this.preloadTextures().then(() => this.forceTextureUpload()).then(() => this.preloadBooks()).then(() => this.preprocessGeometries()).then(() => this.precompileShaders()).then(() => this.animate());
        }
        async initScene() {
          this._previousFrame = null, this.canvas = document.querySelector(".chapter-canvas"), this.scene = new xo(), this.scene.rotateX(pa(-25)), this.camera = new Ve(45, window.innerWidth / window.innerHeight, 0.1, 100), this.camera.position.set(0, 0, 3), this.renderer = new eA({
            canvas: this.canvas,
            alpha: true,
            antialias: true
          }), this.renderer.setSize(window.innerWidth, window.innerHeight), this.controls = new ag(this.camera, this.renderer.domElement), this.controls.enableDamping = true, this.addLighting(), this.paginationNumber = 0, this.firstLoad = true, this.close();
        }
        async preloadBooks() {
          const t = Object.keys(Wr);
          for (const e of t) {
            const i = Wr[e], n = await this.createBook(i);
            n.visible = true, this.scene.add(n), this.books[e] = n;
          }
        }
        async preloadTextures() {
          const t = new hi(this.loadManager);
          this.textureCache = /* @__PURE__ */ new Map();
          const e = [];
          Object.values(Wr).forEach((i) => {
            i.forEach((n) => {
              if (n.front) {
                const r = new Promise((a) => {
                  t.load(`./book/${n.front}.jpg`, (o) => {
                    this.textureCache.set(n.front, o), a();
                  });
                });
                e.push(r);
              }
              if (n.back) {
                const r = new Promise((a) => {
                  t.load(`./book/${n.back}.jpg`, (o) => {
                    this.textureCache.set(n.back, o), a();
                  });
                });
                e.push(r);
              }
            });
          }), await Promise.all(e);
        }
        precompileShaders() {
          const t = new xo(), e = new ko(), i = new on(), n = [];
          Object.values(this.books).forEach((r) => {
            r.traverse((a) => {
              a.isMesh && n.push(a.geometry);
            });
          }), n.forEach((r) => {
            const a = new me(r, i);
            t.add(a);
          }), this.renderer.render(t, e);
        }
        forceTextureUpload() {
          const t = new xo(), e = new ko(), i = new on({
            map: this.textureCache.values().next().value
          }), n = new vr(), r = new me(n, i);
          t.add(r), this.renderer.render(t, e);
        }
        preprocessGeometries() {
          Object.values(this.books).forEach((t) => {
            t.traverse((e) => {
              e.isMesh && e.geometry && (e.geometry.computeVertexNormals(), e.geometry.computeBoundingBox(), e.geometry.computeBoundingSphere());
            });
          });
        }
        async createBook(t) {
          const e = new ki(), i = 1.28, n = 1.71, r = 3e-3, a = 30, o = i / a, c = new ps(i, n, r, a, 2);
          this.pageParams = {
            pageWidth: i,
            pageHeight: n,
            pageDepth: r,
            pageSegments: a,
            segmentWidth: o
          }, new hi();
          const l = () => {
            const u = c.attributes.position, f = new I(), p = [], m = [];
            for (let g = 0; g < u.count; g++) {
              f.fromBufferAttribute(u, g);
              const A = f.x + i / 2, x = Math.max(0, Math.floor(A / o)), b = A % o / o;
              p.push(x, x + 1, 0, 0), m.push(1 - b, b, 0, 0);
            }
            c.setAttribute("skinIndex", new Jo(p, 4)), c.setAttribute("skinWeight", new le(m, 4)), c.translate(i / 2, 0, 0);
          }, h = ({ front: u, back: f }, p) => {
            const m = [];
            for (let B = 0; B <= a; B++) {
              let S = new ia();
              m.push(S), B === 0 ? S.position.x = 0 : S.position.x = o, B > 0 && m[B - 1].add(S);
            }
            new ht("white");
            const g = new ht("orange");
            new ht("black");
            const A = new ht(14869218), x = new ht(14277081), b = [
              new ci({
                color: x
              }),
              new ci({
                color: A
              }),
              new ci({
                color: x
              }),
              new ci({
                color: x
              }),
              new ci({
                color: A,
                emissive: g,
                emissiveIntensity: 0
              }),
              new ci({
                color: A,
                emissive: g,
                emissiveIntensity: 0
              })
            ];
            if (u) {
              const B = this.textureCache.get(u);
              B ? (b[4].map = B, b[4].needsUpdate = true, B.colorSpace = ne) : console.error(`Texture not found in cache: ${u}`);
            }
            if (f) {
              const B = this.textureCache.get(f);
              B ? (b[5].map = B, b[5].needsUpdate = true, B.colorSpace = ne) : console.error(`Texture not found in cache: ${f}`);
            }
            const y = new _a(m), M = new Wh(c, b);
            M.castShadow = true, M.receiveShadow = true, M.frustumCulled = false;
            const T = -p * r;
            M.position.set(0, 0, T), M.add(y.bones[0]), M.bind(y), M.index = p;
            const R = new Iw(M);
            return R.visible = false, this.scene.add(R), M;
          }, d = (u = []) => {
            (u || []).forEach((f, p, m) => {
              const g = h(f, p);
              g.isOpen = false, g.isLastOpen = false, g.turnedAt = Date.now(), g.isHighlighted = false, g.onClick = (A) => {
                g.isOpen ? this.pagination.setPage(this.paginationNumber - 1) : this.pagination.setPage(this.paginationNumber + 1);
              }, g.onPointerenter = (A) => {
                g.isHighlighted = true;
              }, g.onPointerleave = (A) => {
                g.isHighlighted = false;
              }, e.add(g);
            }), e.position.z = 0.28;
          };
          return l(), d(t), e;
        }
        addSceneContent() {
          this.currentBook && (this.currentBook.visible = false);
          const t = this.books[this.marker];
          if (t) {
            this.firstLoad && (Object.values(this.books).forEach((i) => {
              i.visible = false;
            }), this.firstLoad = false), t.visible = true, this.currentBook = t, this.resetPageStates(t), this.resetPageTransforms(t);
            const e = Wr[this.marker];
            this.addPagination(e, this.marker);
          }
          this.setRaycaster();
        }
        resetPageStates(t) {
          t.children.forEach((e) => {
            e.isOpen = false, e.isLastOpen = false, e.turnedAt = Date.now(), e.isHighlighted = false;
          });
        }
        resetPageTransforms(t) {
          const { pageWidth: e, pageHeight: i, pageDepth: n, pageSegments: r, segmentWidth: a } = this.pageParams;
          t.children.forEach((o) => {
            o.rotation.set(0, 0, 0), o.position.set(0, 0, -o.index * n), o.skeleton && o.skeleton.bones.forEach((c, l) => {
              c.rotation.set(0, 0, 0), l === 0 || l % (r + 1) === 0 ? c.position.set(0, 0, 0) : c.position.set(a, 0, 0);
            });
          });
        }
        addLighting() {
          const t = new id(16777215, 0.5), e = new ec(16777215, 1);
          e.position.set(1, 1, 1), this.scene.add(t, e);
        }
        setRaycaster() {
          this.raycasterClickHandler && this.renderer.domElement.removeEventListener("click", this.raycasterClickHandler), this.raycasterPointerMoveHandler && this.renderer.domElement.removeEventListener("pointermove", this.raycasterPointerMoveHandler);
          const t = new Xp(), e = new rt();
          let i = null;
          this.raycasterClickHandler = (n) => {
            e.x = n.clientX / window.innerWidth * 2 - 1, e.y = -(n.clientY / window.innerHeight) * 2 + 1, t.setFromCamera(e, this.camera);
            const r = t.intersectObjects(this.currentBook.children, true);
            if (r.length > 0) {
              const a = r[0].object;
              a.onClick && a.onClick(n);
            }
          }, this.raycasterPointerMoveHandler = (n) => {
            e.x = n.clientX / window.innerWidth * 2 - 1, e.y = -(n.clientY / window.innerHeight) * 2 + 1, t.setFromCamera(e, this.camera);
            const r = t.intersectObjects(this.currentBook.children, true);
            if (r.length > 0) {
              const a = r[0].object;
              a !== i && (i && i.onPointerleave && i.onPointerleave(n), a.onPointerenter && a.onPointerenter(n), i = a, this.renderer.domElement.style.cursor = "pointer");
            } else i && i.onPointerleave && i.onPointerleave(n), i = null, this.renderer.domElement.style.cursor = "default";
          }, this.renderer.domElement.addEventListener("click", this.raycasterClickHandler), this.renderer.domElement.addEventListener("pointermove", this.raycasterPointerMoveHandler);
        }
        updatePageRotation(t) {
          const e = this.currentBook;
          if (!e) {
            console.error("Book group not found in the scene.");
            return;
          }
          const i = this.paginationNumber !== 0 && this.paginationNumber !== e.children.length;
          e.children.forEach((n) => {
            if (n.index === void 0) {
              console.error("Page index is undefined:", n);
              return;
            }
            const r = n.isHighlighted ? 0.2 : 0;
            n.material[4].emissiveIntensity = n.material[5].emissiveIntensity = this.lerp(n.material[4].emissiveIntensity, r, t, 3), n.isOpen = n.index < this.paginationNumber, n.isLastOpen !== n.isOpen && (n.turnedAt = /* @__PURE__ */ new Date(), n.isLastOpen = n.isOpen);
            let a = Math.min(400, /* @__PURE__ */ new Date() - n.turnedAt) / 400;
            a = Math.sin(a * Math.PI);
            let o = n.isOpen ? -Math.PI / 2 : Math.PI / 2;
            i && (o += (n.index - this.paginationNumber) * 0.015);
            const c = n.skeleton;
            if (!c || !c.bones || c.bones.length === 0) {
              console.error("Page skeleton is missing bones:", n);
              return;
            }
            const l = c.bones;
            l.forEach((h, d) => {
              const u = d === 0 ? e : h, f = d < 9 ? Math.sin(d * 0.2 + 0.23) : 0, p = 0.17, m = d >= 9 ? Math.cos(d * 0.3 + 0.1) : 0, g = 0.028, A = Math.sin(d * Math.PI * (1 / l.length)) * a;
              let b = f * p * o - m * g * o + A * 0.08 * o;
              const y = d >= 9 ? Math.sin(d * Math.PI * (1 / l.length) - 0.5) * a : 0;
              let M = pa(Math.sin(o) * 2);
              i || (b = d == 0 ? o * 0.9999 : 0, M = 0);
              const T = 3;
              let R = 1.5;
              if (u === e) {
                const B = e.children.length;
                B < 2 ? R = 0.7 : B < 4 ? R = 0.5 : B < 6 ? R = 0.3 : B < 10 ? R = 0.2 : R = 0.1, b -= Math.PI / 2;
              }
              u.rotation.y = this.lerp(u.rotation.y, b, t, R), u.rotation.x = this.lerp(u.rotation.x, M * y, t, T);
            });
          });
        }
        lerp(t, e, i, n) {
          const r = 1 - Math.exp(-i * n);
          return t * (1 - r) + e * r;
        }
        updatePaginationLinks(t) {
          if (this.marker !== "contacts" && this.marker !== "portfolio" && this.marker !== "credits") return;
          const e = this.pagination.asideLinkContainer.children, i = this.pagination.currentSpread;
          if (this.pagination.currentSpread === 0 || this.pagination.currentSpread === this.pagination.pages.length) {
            for (let n = 0; n < e.length - 1; n++) e[n].classList.remove("chapter-link-show");
            return;
          }
          for (let n = 0; n < e.length - 1; n++) e[n].textContent = t[i].links[n].text, e[n].href = t[i].links[n].link, e[n].target = "blank", e[n].classList.add("chapter-link-show");
        }
        addPagination(t, e) {
          t && (this.pagination && this.pagination.destroy(), this.paginationNumber = 0, this.pagination = new hF(t, e, this.audio, (i) => {
            let n = null;
            const r = () => {
              if (this.paginationNumber === i) {
                clearTimeout(n);
                return;
              }
              n = setTimeout(r, Math.abs(i - this.paginationNumber) > 2 ? 50 : 150), i < this.paginationNumber ? this.paginationNumber-- : i > this.paginationNumber && this.paginationNumber++, this.updatePaginationLinks(t);
            };
            r();
          }));
        }
        getChapterContent(t) {
          return Wr[t] ?? Wr.portfolio;
        }
        updateMarkerStatus() {
          var _a3, _b2;
          const t = (_b2 = (_a3 = this.markersDistanceHandler) == null ? void 0 : _a3.activeMarker) == null ? void 0 : _b2.name;
          t === this.lastMarker || t === null || t === void 0 || (this.lastMarker = this.marker, this.marker = t);
        }
        updateChapterContent() {
          this.marker === this.lastMarker || this.marker === null || this.marker === void 0 || this.addSceneContent();
        }
        animate(t = 0) {
          requestAnimationFrame(this.animate.bind(this)), this._previousFrame === null && (this._previousFrame = t);
          const e = (t - this._previousFrame) * 1e-3;
          this._previousFrame = t, this.controls.update(), this.renderer.render(this.scene, this.camera), this.currentBook && this.currentBook.visible && this.updatePageRotation(e), this.updateMarkerStatus(), this.updateChapterContent();
        }
        open() {
          this.renderer.setAnimationLoop(() => this.renderer.render(this.scene, this.camera));
        }
        close() {
          this.renderer.setAnimationLoop(null);
        }
      }
      class uF {
        constructor(t, e, i, n, r, a, o, c, l, h, d) {
          this.scene = o, this.camera = i, this.audioLoader = new hw(), this.btnsController = h, this.chicks = d, this.updatesCount = 0, this.audioFiles = a, this.riverCurve = e.riverCatmullCurve, this.musicStatus = c, this.soundsStatus = l, this.listener = new fw(), this.camera.add(this.listener), this.keys = n, this.charStateMachine = r, this.prevState = null, this.prevExternLoadedSoundLink = null, this.externLoadedSound = null, this.walkFwdSound = new Di(this.listener), this.runFwdSound = new Di(this.listener), this.walkBwdSound = new Di(this.listener), this.runBwdSound = new Di(this.listener), this.jumpStandSound = new Di(this.listener), this.jumpBwdSound = new Di(this.listener), this.movementSounds = [
            this.walkFwdSound,
            this.runFwdSound,
            this.walkBwdSound,
            this.runBwdSound,
            this.jumpStandSound,
            this.jumpBwdSound
          ], this.idleTheme = new Di(this.listener), this.walkTheme = new Di(this.listener), this.runTheme = new Di(this.listener), this.themeSounds = [
            this.idleTheme,
            this.walkTheme,
            this.runTheme
          ], this.parkSounds = new Di(this.listener), this.riverSounds = new Xc(this.listener), this.scene.add(this.riverSounds), this.ambienceSounds = [
            this.parkSounds,
            this.riverSounds
          ], t.blades && (this.windmillSounds = new Xc(this.listener), this.ambienceSounds.push(this.windmillSounds), this.scene.children.find((p) => p.name === "blade").children[0].children[0].add(this.windmillSounds)), t.chicks && (this.chicksSounds = new Xc(this.listener), this.ambienceSounds.push(this.chicksSounds), this.scene.add(this.chicksSounds)), this.initAudioFiles(), this.soundsManager(), this.updateRiverSound(), this.updateChicksSound(), this.initHelpBtnsHandler();
        }
        updateRiverSound() {
          const t = this.getClosestPointToRiver(this.camera.position);
          this.riverSounds.position.copy(t);
        }
        updateChicksSound() {
          const t = this.getCenterPointToChicks();
          this.chicksSounds.position.copy(t);
        }
        getClosestPointToRiver(t) {
          let e = null, i = 1 / 0;
          const n = 100;
          for (let r = 0; r <= 1; r += 1 / n) {
            const a = this.riverCurve.getPoint(r), o = t.distanceTo(a);
            o < i && (i = o, e = a);
          }
          return e;
        }
        getCenterPointToChicks(t) {
          const e = this.chicks.map((n) => n.chickPhysics.mesh.position), i = e.reduce((n, r) => (n.x += r.x, n.y += r.y, n.z += r.z, n), {
            x: 0,
            y: 0,
            z: 0
          });
          return i.x /= e.length, i.y /= e.length, i.z /= e.length, i;
        }
        playSound(t, e = 0.5) {
          if (this.soundsStatus) {
            if (this.prevExternLoadedSoundLink === t && this.externLoadedSound) {
              this.externLoadedSound.setVolume(e), this.externLoadedSound.play();
              return;
            }
            this.externLoadedSound && (this.externLoadedSound.stop(), this.externLoadedSound.disconnect()), this.prevExternLoadedSoundLink = t, this.externLoadedSound = new Di(this.listener), this.audioLoader.load(t, (i) => {
              this.externLoadedSound.setBuffer(i), this.externLoadedSound.setVolume(e), this.externLoadedSound.play();
            }, void 0, (i) => console.error("Failed to load sound:", i));
          }
        }
        initAudioFiles() {
          this.audioLoader.load(this.audioFiles.park, (t) => {
            this.parkSounds.setBuffer(t), this.parkSounds.setLoop(true), this.parkSounds.setVolume(0.3), this.soundsStatus && this.parkSounds.play();
          }), this.audioLoader.load(this.audioFiles.walkFwdSound, (t) => {
            this.walkFwdSound.setBuffer(t), this.walkFwdSound.setLoop(true), this.walkFwdSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.runFwdSound, (t) => {
            this.runFwdSound.setBuffer(t), this.runFwdSound.setLoop(true), this.runFwdSound.setVolume(0.6), this.runFwdSound.setPlaybackRate(1.6);
          }), this.audioLoader.load(this.audioFiles.walkBwdSound, (t) => {
            this.walkBwdSound.setBuffer(t), this.walkBwdSound.setLoop(true), this.walkBwdSound.setVolume(0.6), this.walkBwdSound.setPlaybackRate(0.8);
          }), this.audioLoader.load(this.audioFiles.runBwdSound, (t) => {
            this.runBwdSound.setBuffer(t), this.runBwdSound.setLoop(true), this.runBwdSound.setVolume(0.6), this.runBwdSound.setPlaybackRate(1.6);
          }), this.audioLoader.load(this.audioFiles.jumpStandSound, (t) => {
            this.jumpStandSound.setBuffer(t), this.jumpStandSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.jumpBwdSound, (t) => {
            this.jumpBwdSound.setBuffer(t), this.jumpBwdSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.idleTheme, (t) => {
            this.idleTheme.setBuffer(t), this.idleTheme.setLoop(true), this.idleTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.walkTheme, (t) => {
            this.walkTheme.setBuffer(t), this.walkTheme.setLoop(true), this.walkTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.runTheme, (t) => {
            this.runTheme.setBuffer(t), this.runTheme.setLoop(true), this.runTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.river, (t) => {
            this.riverSounds.setBuffer(t), this.riverSounds.setLoop(true), this.riverSounds.setVolume(1), this.riverSounds.setRefDistance(10), this.riverSounds.setRolloffFactor(2), this.soundsStatus && this.riverSounds.play();
          }), this.windmillSounds && this.audioLoader.load(this.audioFiles.windmill, (t) => {
            this.windmillSounds.setBuffer(t), this.windmillSounds.setLoop(true), this.windmillSounds.setVolume(1), this.windmillSounds.setRefDistance(8), this.windmillSounds.setRolloffFactor(2), this.soundsStatus && this.windmillSounds.play();
          }), this.chicksSounds && this.audioLoader.load(this.audioFiles.chicks, (t) => {
            this.chicksSounds.setBuffer(t), this.chicksSounds.setLoop(true), this.chicksSounds.setVolume(3), this.chicksSounds.setRefDistance(6), this.chicksSounds.setRolloffFactor(3), this.soundsStatus && this.chicksSounds.play();
          });
        }
        initHelpBtnsHandler() {
          this.btnsController.onSoundOn = this.btnsController.onSoundOn.bind(null, this.soundOn.bind(this)), this.btnsController.onSoundOff = this.btnsController.onSoundOff.bind(null, this.soundOff.bind(this)), this.btnsController.onMusicOn = this.btnsController.onMusicOn.bind(null, this.musicOn.bind(this)), this.btnsController.onMusicOff = this.btnsController.onMusicOff.bind(null, this.musicOff.bind(this));
        }
        clearMovementSounds() {
          this.movementSounds.forEach((t) => {
            t.isPlaying && t.stop();
          });
        }
        clearThemeSounds() {
          this.themeSounds.forEach((t) => {
            t.isPlaying && t.pause();
          });
        }
        clearAmbienceSounds() {
          this.ambienceSounds.forEach((t) => {
            t.isPlaying && t.pause();
          });
        }
        fadeIn(t, e = 1, i = 1e3, n = 0) {
          t.setVolume(0), t.play(n / 1e3);
          const r = 30, a = i / r;
          let o = 0;
          function c() {
            const l = o / r * e;
            t.setVolume(l), o++, o <= r && setTimeout(c, a);
          }
          c();
        }
        fadeOut(t, e = 1e3, i = "stop") {
          const n = t.getVolume(), r = 30, a = e / r;
          let o = 0;
          function c() {
            const l = n * (1 - o / r);
            t.setVolume(Math.max(l, 0)), o++, o <= r ? setTimeout(c, a) : (t.setVolume(0), i === "stop" ? t.stop() : t.pause());
          }
          c();
        }
        soundsManager() {
          window.addEventListener("keydown", (t) => {
            switch (t.keyCode) {
              case 77:
                this.musicStatus ? this.musicOff() : this.musicOn();
                break;
              case 78:
                this.soundsStatus ? this.soundOff() : this.soundOn();
                break;
            }
          });
        }
        musicOn() {
          this.musicStatus = true, this.idleTheme.play(), this.btnsController.musicOn(false);
        }
        musicOff() {
          this.musicStatus = false, this.clearThemeSounds(), this.btnsController.musicOff(false);
        }
        soundOn() {
          this.soundsStatus = true, this.ambienceSounds.forEach((t) => {
            t.play();
          }), this.btnsController.soundOn(false);
        }
        soundOff() {
          this.soundsStatus = false, this.clearMovementSounds(), this.clearAmbienceSounds(), this.btnsController.soundOff(false);
        }
        updateSoundsState() {
          if (this.updatesCount++, this.updatesCount % 10 && this.updateChicksSound(), !this.charStateMachine._currentState) return;
          const t = this.charStateMachine._currentState.Name;
          if (this.camera.position.distanceTo(this.riverSounds.position) > 2 && this.updateRiverSound(), t === this.prevState) return;
          if (!this.soundsStatus && !this.musicStatus) {
            this.clearMovementSounds(), this.clearThemeSounds();
            return;
          }
          this.clearMovementSounds();
          const e = 800;
          switch (t) {
            case "walk_fwd":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.walkTheme, 0.3, e), this.soundsStatus && this.walkFwdSound.play();
              break;
            case "run_fwd":
              this.clearThemeSounds(), this.soundsStatus && this.runFwdSound.play(), this.musicStatus && this.fadeIn(this.runTheme, 0.3, e);
              break;
            case "walk_bwd":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.walkTheme, 0.3, e), this.soundsStatus && this.walkBwdSound.play();
              break;
            case "run_bwd":
              this.clearThemeSounds(), this.soundsStatus && this.runBwdSound.play(), this.musicStatus && this.fadeIn(this.runTheme, 0.3, e);
              break;
            case "jumpStand":
            case "jumpFwd":
              this.soundsStatus && this.jumpStandSound.play(0.3);
              break;
            case "jumpBwd":
              this.soundsStatus && this.jumpBwdSound.play();
              break;
            case "idle":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.idleTheme, 0.3, e);
              break;
          }
          this.prevState = t;
        }
      }
      const fF = {
        walkFwdSound: "sounds/step.wav",
        walkBwdSound: "sounds/step.wav",
        runFwdSound: "sounds/step.wav",
        runBwdSound: "sounds/step.wav",
        jumpStandSound: "sounds/long_jump.flac",
        jumpBwdSound: "sounds/jump.flac",
        idleTheme: "sounds/Bamboo_Forest.mp3",
        walkTheme: "sounds/walk_3.mp3",
        runTheme: "sounds/run_3.mp3",
        park: "sounds/park_2.wav",
        river: "sounds/amb_river.flac",
        windmill: "sounds/windmill.mp3",
        chicks: "sounds/chicks.mp3"
      };
      class pF {
        constructor(t, e = false) {
          this.scene = t, this.visible = e, this.riverCurve = new Qi(), this.initRiverCurve();
        }
        initRiverCurve() {
          const t = [
            new I(140, -13, -690),
            new I(140, -13, -500),
            new I(70, -13, -400),
            new I(70, -13, 0),
            new I(0, -13, 90),
            new I(50, -13, 140),
            new I(230, -13, 190),
            new I(230, -13, 290),
            new I(130, -13, 390),
            new I(-175, -13, 690)
          ], e = new Tp(t), i = new $h(e, 100, 0.5, 8, false), n = new on({
            color: 255,
            transparent: true,
            opacity: 0.5
          });
          this.riverCurveMesh = new me(i, n), this.riverCurveMesh.visible = this.visible, this.scene.add(this.riverCurveMesh), this.riverCatmullCurve = e;
        }
      }
      const AF = [
        "./skybox/blizzard_ft.jpg",
        "./skybox/blizzard_bk.jpg",
        "./skybox/blizzard_up.jpg",
        "./skybox/blizzard_dn.jpg",
        "./skybox/blizzard_rt.jpg",
        "./skybox/blizzard_lf.jpg"
      ], gF = [
        "./skybox/yonder_ft.jpg",
        "./skybox/yonder_bk.jpg",
        "./skybox/yonder_up.jpg",
        "./skybox/yonder_dn.jpg",
        "./skybox/yonder_rt.jpg",
        "./skybox/yonder_lf.jpg"
      ], $f = {
        blizzard: AF,
        yonder: gF
      };
      class _F {
        constructor(t, e) {
          this.isFoggy = t, this.scene = e, this.cubeTextureLoader = new rw();
        }
        addSkyBox() {
          let t = null;
          this.isFoggy ? t = this.cubeTextureLoader.load($f.blizzard) : t = this.cubeTextureLoader.load($f.yonder), t && (t.encoding = void 0, this.scene.background = t);
        }
      }
      class mF {
        constructor(t) {
          this.loadPage = document.getElementById("loading"), this.progressBar = document.getElementById("ld-progress"), this.manager = new Gp(), this.helpMenu = t, this._setupEventHandlers();
        }
        getManager() {
          return this.manager;
        }
        _setupEventHandlers() {
          this.manager.onStart = this._onStart.bind(this), this.manager.onProgress = this._onProgress.bind(this), this.manager.onLoad = this._onLoad.bind(this), this.manager.onError = this._onError.bind(this);
        }
        _onStart(t, e, i) {
          this.loadPage && this.loadPage.classList.add("loading-show"), this.helpMenu.hide();
        }
        _onProgress(t, e, i) {
          this.progressBar && (this.progressBar.value = e / i * 100);
        }
        _onLoad() {
          this.loadPage && this.loadPage.classList.remove("loading-show"), this.helpMenu.show();
        }
        _onError(t) {
          console.error(`Error loading: ${t}`);
        }
      }
      class wF {
        constructor(t, e) {
          this.helpModule = document.getElementById("help-menu"), this.btns = this.helpModule.querySelector(".help-menu__wrapper"), this.body = document.body, this.lastSuitableBodyCont = document.getElementById("modal-chapter-cont"), this.soundsBtn = null, this.musicBtn = null, this.soundsStatus = t, this.musicStatus = e, this.initBtns(), this.helpModal = this.makeAndAddModal();
        }
        makeAndAddModal() {
          const t = document.createElement("div");
          t.classList.add("help__modal");
          const e = document.createElement("div");
          return e.classList.add("help__container"), e.innerHTML = `<fieldset class="c-main__right">
            <legend class="c-main__title">Controls</legend>
            <div class="c-main__controls-kbd">
              <dl class="c-main__kbd wasd">
                <dt class="wasd__buttons">
                  <div class="wasd__btns">
                    <div class="wasd__top-line">
                      <kbd>w</kbd>
                    </div>
                    <div class="wast__bottom-line">
                      <kbd>a</kbd>
                      <kbd>s</kbd>
                      <kbd>d</kbd>
                    </div>
                  </div>
                  <span> or </span>
                  <div class="wasd__arrs">
                    <div class="wasd__top-line">
                      <kbd>\u2191</kbd>
                    </div>
                    <div class="wasd__bottom-line">
                      <kbd>\u2190</kbd>
                      <kbd>\u2193</kbd>
                      <kbd>\u2192</kbd>
                    </div>
                  </div>
                </dt>
                <dd>- movement</dd>
              </dl>
              <dl class="c-main__kbd rand-action-kbd">
                <dt>
                  <kbd>f</kbd>
                </dt>
                <dd>- random action</dd>
              </dl>
              <dl class="c-main__kbd jump-kbd">
                <dt>
                  <kbd>ctrl</kbd>
                </dt>
                <dd>- jump</dd>
              </dl>
              <dl class="c-main__kbd run-kbd">
                <dt>hold <kbd>shift</kbd></dt>
                <dd>- run</dd>
              </dl>
              <dl class="c-main__kbd help-kbd">
                <dt>
                  <kbd>h</kbd>
                </dt>
                <dd>- help</dd>
              </dl>
              <dl class="c-main__kbd sounds-kbd">
                <dt>
                  <kbd>n</kbd>
                </dt>
                <dd>- sounds</dd>
              </dl>
              <dl class="c-main__kbd music-kbd">
                <dt>
                  <kbd>m</kbd>
                </dt>
                <dd>- music</dd>
              </dl>
              <dl class="c-main__kbd chapter-kbd">
                <dt>
                  <kbd>r</kbd>
                </dt>
                <dd>- open/close chapter</dd>
              </dl>
            </div>
          </fieldset>`, t.append(e), this.close = document.createElement("button"), this.close.textContent = "close", this.close.classList.add("help__close"), this.close.addEventListener("click", (i) => {
            this.hideModal(), this.show();
          }), t.append(this.close), this.body.append(t), this.setBtnListener(), t;
        }
        setBtnListener() {
          window.addEventListener("keydown", (t) => {
            t.keyCode === 72 && (this.helpModal.classList.contains("helpModal-show") ? (this.hideModal(), this.show()) : (this.showModal(), this.hide()));
          });
        }
        initBtns() {
          Array.from(this.btns.children).forEach((t) => {
            const e = t.firstElementChild, i = e.baseURI, n = e.dataset.group;
            n === "sound" ? (this.soundsBtn = t, e.src = i + `icons/${n}-${this.soundsStatus ? "on" : "off"}.svg`, this.soundsStatus || this.soundsBtn.classList.add("active")) : n === "music" && (this.musicBtn = t, e.src = i + `icons/${n}-${this.musicStatus ? "on" : "off"}.svg`, this.musicStatus || this.musicBtn.classList.add("active")), t.addEventListener("click", (r) => {
              t.classList.contains("help-menu__help") ? (this.showModal(), this.hide()) : r.currentTarget.classList.contains("active") ? this[`${n}On`](true) : this[`${n}Off`](true);
            });
          });
        }
        showModal() {
          this.helpModal.classList.add("helpModal-show");
        }
        hideModal() {
          this.helpModal.classList.remove("helpModal-show");
        }
        show() {
          this.helpModule.classList.add("help-menu-show");
        }
        hide() {
          this.helpModule.classList.remove("help-menu-show");
        }
        toggleAudio(t, e, i) {
          const n = t === "sound" ? this.soundsBtn : this.musicBtn, r = n.firstElementChild, a = r.baseURI;
          r.src = `${a}icons/${t}-${e ? "on" : "off"}.svg`, n.classList.toggle("active", !e), this[`${t}Status`] = e, i && this[`on${t.charAt(0).toUpperCase() + t.slice(1)}${e ? "On" : "Off"}`]();
        }
        soundOn(t) {
          this.toggleAudio("sound", true, t);
        }
        soundOff(t) {
          this.toggleAudio("sound", false, t);
        }
        musicOn(t) {
          this.toggleAudio("music", true, t);
        }
        musicOff(t) {
          this.toggleAudio("music", false, t);
        }
        onSoundOn(t) {
          t && t();
        }
        onSoundOff(t) {
          t && t();
        }
        onMusicOn(t) {
          t && t();
        }
        onMusicOff(t) {
          t && t();
        }
      }
      class bF {
        constructor(t, e) {
          this.limits = t, this.character = e, this.limitAnimationPlaying = false, this.keys = this.character.basicController._input.keys, this.btnPressedController = this.character.basicController._input, this.updated = 0;
        }
        setLimitAreaReachedAct() {
          this.keys.limitAreaReachedAct || (this.btnPressedController.limitAreaReachedAct = true);
        }
        update(t) {
          if (this.updated++, this.updated % 30 || this.limitAnimationPlaying) return;
          const e = this.character.rigidBody.translation();
          e.x < this.limits.maxX && e.x > this.limits.minX && e.z < this.limits.maxZ && e.z > this.limits.minZ || this.setLimitAreaReachedAct();
        }
      }
      const yF = (s, t) => {
        const e = s.geometry.attributes.position.array, i = s.geometry.index.array, n = li.ColliderDesc.trimesh(e, i).setActiveEvents(li.ActiveEvents.COLLISION_EVENTS).setRestitution(0.1).setFriction(0.8).setCollisionGroups(65537);
        t.createCollider(n), console.log("\u2705 Physics Collider Set for Terrain");
      }, xF = (s) => {
        if (!s) throw new Error("No mesh found");
        const t = s.getObjectByName("Plane");
        if (!t) return new Error("Terrain 'Plane' not found!");
        let e = [];
        if (t.type === "Mesh" ? e.push(t) : e = t.children.filter((a) => a.isMesh), e.length === 0) return new Error("No meshes found inside 'Plane'!");
        const i = e.map((a) => {
          const o = a.geometry.clone().applyMatrix4(a.matrixWorld);
          return o.scale(Sn.x, Sn.y, Sn.z), o;
        }), n = nc(i, false), r = new me(n, new ci({
          color: 65280
        }));
        return r || new Error("Terrain mesh not found");
      }, vF = (s, t) => {
        try {
          const e = xF(t);
          console.log("\u2705 Terrain Mesh Loaded."), yF(e, s);
        } catch (e) {
          console.error(e);
        }
      };
      class EF {
        constructor(t, e) {
          this._freeCamera, this._initCamera(t, e);
        }
        _initCamera(t, e) {
          this._freeCamera = new ag(t, e), this._freeCamera.target.set(0, 20, 0), this._freeCamera.update();
        }
      }
      class SF {
        constructor(t) {
          this._params = t, this._camera = t.camera, this._position = new I(), this._lookAt = new I(), this._keys = t.target._input._keys, this._thirdPersonOffset = new I(-20, 20, -30), this._selfieOffset = new I(-15, 15, -20), this._lookAtHeight = 10;
        }
        _calcTransformedPosition(t) {
          const e = t.clone();
          return e.applyQuaternion(this._params.target.rotation), e.add(this._params.target.position), e;
        }
        _calcTransformedSelfiePosition(t) {
          const e = new ue().setFromAxisAngle(new I(0, 1, 0), Math.PI), i = t.clone().applyQuaternion(e).applyQuaternion(this._params.target.rotation);
          return this._params.target.position.clone().add(i);
        }
        _calcIdealOffset() {
          return this._keys.selfieMode ? this._calcTransformedSelfiePosition(this._selfieOffset) : this._calcTransformedPosition(this._thirdPersonOffset);
        }
        _calcIdealLookAt() {
          const t = this._params.target.position;
          return this._keys.selfieMode ? new I(t.x, t.y + this._lookAtHeight, t.z) : this._calcTransformedPosition(new I(0, this._lookAtHeight, 40));
        }
        _update(t) {
          const e = this._calcIdealOffset(), i = this._calcIdealLookAt(), n = 1 - Math.pow(1e-3, t);
          this._position.lerp(e, n), this._lookAt.lerp(i, n), this._camera.position.copy(this._position), this._camera.lookAt(this._lookAt);
        }
      }
      const Th = [
        "dance",
        "dance2",
        "dance3",
        "capoeira",
        "hip_hop_dancing"
      ], Rh = [
        "arguing",
        "looking_behind",
        "pray",
        "no",
        "pointing",
        "shaking_it_off"
      ];
      let Bn = class {
        constructor(t) {
          this._parent = t;
        }
        enter() {
        }
        exit() {
        }
        update(t, e) {
        }
      }, pc = (_a2 = class extends Bn {
        constructor(t, e) {
          super(t), this._jumpType = e, this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._jumpType;
        }
        enter(t) {
          const e = this._parent._proxy._animations[this._jumpType].action;
          if (e.getMixer().addEventListener("finished", this._finishedCallback), t) {
            const n = this._parent._proxy._animations[t.Name].action;
            e.reset(), e.setLoop(Yo, 1), e.clampWhenFinished = true, e.crossFadeFrom(n, 0.1, true), e.play();
          } else e.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("idle");
        }
        _cleanup() {
          this._parent._proxy._animations[this._jumpType].action.getMixer().removeEventListener("finished", this._finishedCallback);
        }
        exit() {
          this._cleanup();
        }
        update() {
        }
      }, __publicField(_a2, "_jumpStates", [
        "jumpStand",
        "jumpBwd",
        "jumpFwd"
      ]), _a2);
      class CF extends pc {
        constructor(t) {
          super(t, "jumpStand");
        }
      }
      class IF extends pc {
        constructor(t) {
          super(t, "jumpFwd");
        }
      }
      class MF extends pc {
        constructor(t) {
          super(t, "jumpBwd");
        }
      }
      class TF extends Bn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "run_fwd";
        }
        enter(t) {
          const e = this._parent._proxy._animations.run_fwd.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            if (e.enabled = true, t.Name == "walk_fwd") {
              const n = e.getClip().duration / i.getClip().duration;
              e.time = i.time * n;
            } else e.time = 0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1);
            e.crossFadeFrom(i, 0.2, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          if (e._keys.limitAreaReachedAct) {
            this._parent.setState("end_area");
            return;
          }
          if (e._keys.ctrl) {
            this._parent.setState("jumpFwd");
            return;
          }
          if (!(e._keys.forward && e._keys.shift)) {
            if (e._keys.forward && !e._keys.shift) {
              this._parent.setState("walk_fwd");
              return;
            }
            if (e._keys.backward) {
              this._parent.setState("walk_bwd");
              return;
            }
            this._parent.setState("idle");
          }
        }
      }
      class RF extends Bn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "run_bwd";
        }
        enter(t) {
          const e = this._parent._proxy._animations.run_bwd.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            if (e.enabled = true, t.Name == "walk_bwd") {
              const n = e.getClip().duration / i.getClip().duration;
              e.time = i.time * n;
            } else e.time = 0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1);
            e.crossFadeFrom(i, 0.2, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          if (e._keys.limitAreaReachedAct) {
            this._parent.setState("end_area");
            return;
          }
          if (e._keys.ctrl) {
            this._parent.setState("jumpBwd");
            return;
          }
          if (!(e._keys.backward && e._keys.shift)) {
            if (e._keys.backward && !e._keys.shift) {
              this._parent.setState("walk_bwd");
              return;
            }
            if (e._keys.forward) {
              this._parent.setState("walk_fwd");
              return;
            }
            this._parent.setState("idle");
          }
        }
      }
      class BF extends Bn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "walk_fwd";
        }
        enter(t) {
          const e = this._parent._proxy._animations.walk_fwd.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            if (e.enabled = true, t.Name == "run_fwd") {
              const n = e.getClip().duration / i.getClip().duration;
              e.time = i.time * n;
            } else e.time = 0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1);
            e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          if (e._keys.forward) {
            if (e._keys.limitAreaReachedAct) {
              this._parent.setState("end_area");
              return;
            }
            e._keys.shift && this._parent.setState("run_fwd"), e._keys.ctrl && this._parent.setState("jumpFwd");
            return;
          }
          if (e._keys.backward) {
            this._parent.setState("walk_bwd");
            return;
          }
          this._parent.setState("idle");
        }
      }
      class DF extends Bn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "walk_bwd";
        }
        enter(t) {
          const e = this._parent._proxy._animations.walk_bwd.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            if (e.enabled = true, t.Name == "run_bwd") {
              const n = e.getClip().duration / i.getClip().duration;
              e.time = i.time * n;
            } else e.time = 0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1);
            e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          if (e._keys.backward) {
            if (e._keys.limitAreaReachedAct) {
              this._parent.setState("end_area");
              return;
            }
            e._keys.shift && this._parent.setState("run_bwd"), e._keys.ctrl && this._parent.setState("jumpBwd");
            return;
          }
          if (e._keys.forward) {
            this._parent.setState("walk_fwd");
            return;
          }
          this._parent.setState("idle");
        }
      }
      class og {
        constructor() {
          this._index;
        }
        getRandomIndex(t) {
          if (t.length) return this._index = Math.floor(Math.random() * t.length), this._index;
        }
      }
      class PF extends Bn {
        constructor(t) {
          super(t), this._actionIndexRandomizer = new og().getRandomIndex, this._updateActionIndex(), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._curActionName;
        }
        _updateActionIndex() {
          this._actionIndex = this._actionIndexRandomizer(Th), this._curActionName = Th[this._actionIndex];
        }
        enter(t) {
          this._parent.keys.actionsAllowed = false, this._updateActionIndex();
          const e = this._parent._proxy._animations[this._curActionName].action;
          if (e.getMixer().addEventListener("finished", this._finishedCallback), t) {
            const n = this._parent._proxy._animations[t.Name].action;
            e.reset(), e.setLoop(Yo, 1), e.clampWhenFinished = true, e.crossFadeFrom(n, 0.2, true), e.play();
          } else e.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("idle");
        }
        _cleanup() {
          this._parent._proxy._animations[this._curActionName].action.getMixer().removeEventListener("finished", this._finishedCallback), this._parent.keys.actionsAllowed = true;
        }
        exit() {
          this._cleanup();
        }
        update() {
        }
      }
      class FF extends Bn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "idle";
        }
        enter(t) {
          const e = this._parent._proxy._animations.idle.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          e._keys.forward ? this._parent.setState("walk_fwd") : e._keys.backward ? this._parent.setState("walk_bwd") : e._keys.ctrl ? this._parent.setState("jumpStand") : e._keys.action && this._parent.setState("action");
        }
      }
      class LF extends Bn {
        constructor(t) {
          super(t), this._actionIndexRandomizer = new og().getRandomIndex, this._updateActionIndex(), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._curActionName;
        }
        _updateActionIndex() {
          this._actionIndex = this._actionIndexRandomizer(Rh), this._curActionName = Rh[this._actionIndex];
        }
        enter(t) {
          this._parent.keys.actionsAllowed = false, this._parent.keys.selfieMode = true, this._updateActionIndex();
          const e = this._parent._proxy._animations[this._curActionName].action;
          if (e.getMixer().addEventListener("finished", this._finishedCallback), t) {
            const n = this._parent._proxy._animations[t.Name].action;
            e.reset(), e.setLoop(Yo, 1), e.clampWhenFinished = true, e.crossFadeFrom(n, 0.2, true), e.play();
          } else e.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("lim_area_walk_fwd"), setTimeout(() => {
            this._parent.keys.selfieMode = false;
          }, 2e3);
        }
        _cleanup() {
          this._parent._proxy._animations.end_area.action.getMixer().removeEventListener("finished", this._finishedCallback);
        }
        exit() {
        }
        update(t, e) {
        }
      }
      class kF extends Bn {
        constructor(t) {
          super(t), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return "lim_area_walk_fwd";
        }
        enter(t) {
          this._parent.keys.limitAreaWalk = true, this._parent.keys.limitAreaTurn = true;
          const e = this._parent._proxy._animations.lim_area_walk_fwd.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.enabled = true, e.time = 0, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          e._keys.limitAreaWalk || this._parent.setState("idle");
        }
      }
      let NF = class {
        constructor() {
          this._states = {}, this._currentState = null;
        }
        _addState(t, e) {
          this._states[t] = e;
        }
        _resetKeys() {
          for (const t in this.keys) t === "actionsAllowed" || t === "limitAreaWalk" || t === "limitAreaTurn" || t === "selfieMode" || (this.keys[t] = false);
        }
        setState(t) {
          const e = this._currentState;
          if (e) {
            if (e.Name == t) return;
            e.exit();
          }
          const i = new this._states[t](this);
          this._currentState = i, i.enter(e);
        }
        update(t, e) {
          this.keys.actionsAllowed || this._resetKeys(), this._currentState && this._currentState.update(t, e);
        }
      };
      class UF extends NF {
        constructor(t, e) {
          super(), this._proxy = t, this.keys = e, this._initStates();
        }
        _initStates() {
          this._addState("idle", FF), this._addState("walk_fwd", BF), this._addState("walk_bwd", DF), this._addState("run_fwd", TF), this._addState("run_bwd", RF), this._addState("action", PF), this._addState("jumpStand", CF), this._addState("jumpBwd", MF), this._addState("jumpFwd", IF), this._addState("end_area", LF), this._addState("lim_area_walk_fwd", kF);
        }
      }
      var Li = Uint8Array, $r = Uint16Array, QF = Int32Array, cg = new Li([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        0,
        0,
        0
      ]), lg = new Li([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        0,
        0
      ]), OF = new Li([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      ]), hg = function(s, t) {
        for (var e = new $r(31), i = 0; i < 31; ++i) e[i] = t += 1 << s[i - 1];
        for (var n = new QF(e[30]), i = 1; i < 30; ++i) for (var r = e[i]; r < e[i + 1]; ++r) n[r] = r - e[i] << 5 | i;
        return {
          b: e,
          r: n
        };
      }, dg = hg(cg, 2), ug = dg.b, zF = dg.r;
      ug[28] = 258, zF[258] = 28;
      var GF = hg(lg, 0), HF = GF.b, Bh = new $r(32768);
      for (var Ee = 0; Ee < 32768; ++Ee) {
        var On = (Ee & 43690) >> 1 | (Ee & 21845) << 1;
        On = (On & 52428) >> 2 | (On & 13107) << 2, On = (On & 61680) >> 4 | (On & 3855) << 4, Bh[Ee] = ((On & 65280) >> 8 | (On & 255) << 8) >> 1;
      }
      var Ws = function(s, t, e) {
        for (var i = s.length, n = 0, r = new $r(t); n < i; ++n) s[n] && ++r[s[n] - 1];
        var a = new $r(t);
        for (n = 1; n < t; ++n) a[n] = a[n - 1] + r[n - 1] << 1;
        var o;
        if (e) {
          o = new $r(1 << t);
          var c = 15 - t;
          for (n = 0; n < i; ++n) if (s[n]) for (var l = n << 4 | s[n], h = t - s[n], d = a[s[n] - 1]++ << h, u = d | (1 << h) - 1; d <= u; ++d) o[Bh[d] >> c] = l;
        } else for (o = new $r(i), n = 0; n < i; ++n) s[n] && (o[n] = Bh[a[s[n] - 1]++] >> 15 - s[n]);
        return o;
      }, va = new Li(288);
      for (var Ee = 0; Ee < 144; ++Ee) va[Ee] = 8;
      for (var Ee = 144; Ee < 256; ++Ee) va[Ee] = 9;
      for (var Ee = 256; Ee < 280; ++Ee) va[Ee] = 7;
      for (var Ee = 280; Ee < 288; ++Ee) va[Ee] = 8;
      var fg = new Li(32);
      for (var Ee = 0; Ee < 32; ++Ee) fg[Ee] = 5;
      var VF = Ws(va, 9, 1), WF = Ws(fg, 5, 1), Sl = function(s) {
        for (var t = s[0], e = 1; e < s.length; ++e) s[e] > t && (t = s[e]);
        return t;
      }, Wi = function(s, t, e) {
        var i = t / 8 | 0;
        return (s[i] | s[i + 1] << 8) >> (t & 7) & e;
      }, Cl = function(s, t) {
        var e = t / 8 | 0;
        return (s[e] | s[e + 1] << 8 | s[e + 2] << 16) >> (t & 7);
      }, jF = function(s) {
        return (s + 7) / 8 | 0;
      }, qF = function(s, t, e) {
        return (e == null || e > s.length) && (e = s.length), new Li(s.subarray(t, e));
      }, XF = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
      ], qi = function(s, t, e) {
        var i = new Error(t || XF[s]);
        if (i.code = s, Error.captureStackTrace && Error.captureStackTrace(i, qi), !e) throw i;
        return i;
      }, YF = function(s, t, e, i) {
        var n = s.length, r = 0;
        if (!n || t.f && !t.l) return e || new Li(0);
        var a = !e, o = a || t.i != 2, c = t.i;
        a && (e = new Li(n * 3));
        var l = function(Se) {
          var be = e.length;
          if (Se > be) {
            var Kt = new Li(Math.max(be * 2, Se));
            Kt.set(e), e = Kt;
          }
        }, h = t.f || 0, d = t.p || 0, u = t.b || 0, f = t.l, p = t.d, m = t.m, g = t.n, A = n * 8;
        do {
          if (!f) {
            h = Wi(s, d, 1);
            var x = Wi(s, d + 1, 3);
            if (d += 3, x) if (x == 1) f = VF, p = WF, m = 9, g = 5;
            else if (x == 2) {
              var T = Wi(s, d, 31) + 257, R = Wi(s, d + 10, 15) + 4, B = T + Wi(s, d + 5, 31) + 1;
              d += 14;
              for (var S = new Li(B), E = new Li(19), P = 0; P < R; ++P) E[OF[P]] = Wi(s, d + P * 3, 7);
              d += R * 3;
              for (var G = Sl(E), H = (1 << G) - 1, Y = Ws(E, G, 1), P = 0; P < B; ) {
                var et = Y[Wi(s, d, H)];
                d += et & 15;
                var b = et >> 4;
                if (b < 16) S[P++] = b;
                else {
                  var q = 0, Z = 0;
                  for (b == 16 ? (Z = 3 + Wi(s, d, 3), d += 2, q = S[P - 1]) : b == 17 ? (Z = 3 + Wi(s, d, 7), d += 3) : b == 18 && (Z = 11 + Wi(s, d, 127), d += 7); Z--; ) S[P++] = q;
                }
              }
              var W = S.subarray(0, T), st = S.subarray(T);
              m = Sl(W), g = Sl(st), f = Ws(W, m, 1), p = Ws(st, g, 1);
            } else qi(1);
            else {
              var b = jF(d) + 4, y = s[b - 4] | s[b - 3] << 8, M = b + y;
              if (M > n) {
                c && qi(0);
                break;
              }
              o && l(u + y), e.set(s.subarray(b, M), u), t.b = u += y, t.p = d = M * 8, t.f = h;
              continue;
            }
            if (d > A) {
              c && qi(0);
              break;
            }
          }
          o && l(u + 131072);
          for (var dt = (1 << m) - 1, Et = (1 << g) - 1, Pt = d; ; Pt = d) {
            var q = f[Cl(s, d) & dt], Vt = q >> 4;
            if (d += q & 15, d > A) {
              c && qi(0);
              break;
            }
            if (q || qi(2), Vt < 256) e[u++] = Vt;
            else if (Vt == 256) {
              Pt = d, f = null;
              break;
            } else {
              var K = Vt - 254;
              if (Vt > 264) {
                var P = Vt - 257, ot = cg[P];
                K = Wi(s, d, (1 << ot) - 1) + ug[P], d += ot;
              }
              var bt = p[Cl(s, d) & Et], lt = bt >> 4;
              bt || qi(3), d += bt & 15;
              var st = HF[lt];
              if (lt > 3) {
                var ot = lg[lt];
                st += Cl(s, d) & (1 << ot) - 1, d += ot;
              }
              if (d > A) {
                c && qi(0);
                break;
              }
              o && l(u + 131072);
              var Tt = u + K;
              if (u < st) {
                var Zt = r - st, Ft = Math.min(st, Tt);
                for (Zt + u < 0 && qi(3); u < Ft; ++u) e[u] = i[Zt + u];
              }
              for (; u < Tt; ++u) e[u] = e[u - st];
            }
          }
          t.l = f, t.p = Pt, t.b = u, t.f = h, f && (h = 1, t.m = m, t.d = p, t.n = g);
        } while (!h);
        return u != e.length && a ? qF(e, 0, u) : e.subarray(0, u);
      }, KF = new Li(0), JF = function(s, t) {
        return ((s[0] & 15) != 8 || s[0] >> 4 > 7 || (s[0] << 8 | s[1]) % 31) && qi(6, "invalid zlib data"), (s[1] >> 5 & 1) == 1 && qi(6, "invalid zlib data: " + (s[1] & 32 ? "need" : "unexpected") + " dictionary"), (s[1] >> 3 & 4) + 2;
      };
      function ZF(s, t) {
        return YF(s.subarray(JF(s), -4), {
          i: 2
        }, t, t);
      }
      var $F = typeof TextDecoder < "u" && new TextDecoder(), tL = 0;
      try {
        $F.decode(KF, {
          stream: true
        }), tL = 1;
      } catch {
      }
      function pg(s, t, e) {
        const i = e.length - s - 1;
        if (t >= e[i]) return i - 1;
        if (t <= e[s]) return s;
        let n = s, r = i, a = Math.floor((n + r) / 2);
        for (; t < e[a] || t >= e[a + 1]; ) t < e[a] ? r = a : n = a, a = Math.floor((n + r) / 2);
        return a;
      }
      function eL(s, t, e, i) {
        const n = [], r = [], a = [];
        n[0] = 1;
        for (let o = 1; o <= e; ++o) {
          r[o] = t - i[s + 1 - o], a[o] = i[s + o] - t;
          let c = 0;
          for (let l = 0; l < o; ++l) {
            const h = a[l + 1], d = r[o - l], u = n[l] / (h + d);
            n[l] = c + h * u, c = d * u;
          }
          n[o] = c;
        }
        return n;
      }
      function iL(s, t, e, i) {
        const n = pg(s, i, t), r = eL(n, i, s, t), a = new jt(0, 0, 0, 0);
        for (let o = 0; o <= s; ++o) {
          const c = e[n - s + o], l = r[o], h = c.w * l;
          a.x += c.x * h, a.y += c.y * h, a.z += c.z * h, a.w += c.w * l;
        }
        return a;
      }
      function nL(s, t, e, i, n) {
        const r = [];
        for (let d = 0; d <= e; ++d) r[d] = 0;
        const a = [];
        for (let d = 0; d <= i; ++d) a[d] = r.slice(0);
        const o = [];
        for (let d = 0; d <= e; ++d) o[d] = r.slice(0);
        o[0][0] = 1;
        const c = r.slice(0), l = r.slice(0);
        for (let d = 1; d <= e; ++d) {
          c[d] = t - n[s + 1 - d], l[d] = n[s + d] - t;
          let u = 0;
          for (let f = 0; f < d; ++f) {
            const p = l[f + 1], m = c[d - f];
            o[d][f] = p + m;
            const g = o[f][d - 1] / o[d][f];
            o[f][d] = u + p * g, u = m * g;
          }
          o[d][d] = u;
        }
        for (let d = 0; d <= e; ++d) a[0][d] = o[d][e];
        for (let d = 0; d <= e; ++d) {
          let u = 0, f = 1;
          const p = [];
          for (let m = 0; m <= e; ++m) p[m] = r.slice(0);
          p[0][0] = 1;
          for (let m = 1; m <= i; ++m) {
            let g = 0;
            const A = d - m, x = e - m;
            d >= m && (p[f][0] = p[u][0] / o[x + 1][A], g = p[f][0] * o[A][x]);
            const b = A >= -1 ? 1 : -A, y = d - 1 <= x ? m - 1 : e - d;
            for (let T = b; T <= y; ++T) p[f][T] = (p[u][T] - p[u][T - 1]) / o[x + 1][A + T], g += p[f][T] * o[A + T][x];
            d <= x && (p[f][m] = -p[u][m - 1] / o[x + 1][d], g += p[f][m] * o[d][x]), a[m][d] = g;
            const M = u;
            u = f, f = M;
          }
        }
        let h = e;
        for (let d = 1; d <= i; ++d) {
          for (let u = 0; u <= e; ++u) a[d][u] *= h;
          h *= e - d;
        }
        return a;
      }
      function rL(s, t, e, i, n) {
        const r = n < s ? n : s, a = [], o = pg(s, i, t), c = nL(o, i, s, r, t), l = [];
        for (let h = 0; h < e.length; ++h) {
          const d = e[h].clone(), u = d.w;
          d.x *= u, d.y *= u, d.z *= u, l[h] = d;
        }
        for (let h = 0; h <= r; ++h) {
          const d = l[o - s].clone().multiplyScalar(c[h][0]);
          for (let u = 1; u <= s; ++u) d.add(l[o - s + u].clone().multiplyScalar(c[h][u]));
          a[h] = d;
        }
        for (let h = r + 1; h <= n + 1; ++h) a[h] = new jt(0, 0, 0);
        return a;
      }
      function sL(s, t) {
        let e = 1;
        for (let n = 2; n <= s; ++n) e *= n;
        let i = 1;
        for (let n = 2; n <= t; ++n) i *= n;
        for (let n = 2; n <= s - t; ++n) i *= n;
        return e / i;
      }
      function aL(s) {
        const t = s.length, e = [], i = [];
        for (let r = 0; r < t; ++r) {
          const a = s[r];
          e[r] = new I(a.x, a.y, a.z), i[r] = a.w;
        }
        const n = [];
        for (let r = 0; r < t; ++r) {
          const a = e[r].clone();
          for (let o = 1; o <= r; ++o) a.sub(n[r - o].clone().multiplyScalar(sL(r, o) * i[o]));
          n[r] = a.divideScalar(i[0]);
        }
        return n;
      }
      function oL(s, t, e, i, n) {
        const r = rL(s, t, e, i, n);
        return aL(r);
      }
      class cL extends Qi {
        constructor(t, e, i, n, r) {
          super();
          const a = e ? e.length - 1 : 0, o = i ? i.length : 0;
          this.degree = t, this.knots = e, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = r || a;
          for (let c = 0; c < o; ++c) {
            const l = i[c];
            this.controlPoints[c] = new jt(l.x, l.y, l.z, l.w);
          }
        }
        getPoint(t, e = new I()) {
          const i = e, n = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]), r = iL(this.degree, this.knots, this.controlPoints, n);
          return r.w !== 1 && r.divideScalar(r.w), i.set(r.x, r.y, r.z);
        }
        getTangent(t, e = new I()) {
          const i = e, n = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]), r = oL(this.degree, this.knots, this.controlPoints, n, 1);
          return i.copy(r[1]).normalize(), i;
        }
        toJSON() {
          const t = super.toJSON();
          return t.degree = this.degree, t.knots = [
            ...this.knots
          ], t.controlPoints = this.controlPoints.map((e) => e.toArray()), t.startKnot = this.startKnot, t.endKnot = this.endKnot, t;
        }
        fromJSON(t) {
          return super.fromJSON(t), this.degree = t.degree, this.knots = [
            ...t.knots
          ], this.controlPoints = t.controlPoints.map((e) => new jt(e[0], e[1], e[2], e[3])), this.startKnot = t.startKnot, this.endKnot = t.endKnot, this;
        }
      }
      let Xt, Le, gi;
      class lL extends Ui {
        constructor(t) {
          super(t);
        }
        load(t, e, i, n) {
          const r = this, a = r.path === "" ? ns.extractUrlBase(t) : r.path, o = new Ar(this.manager);
          o.setPath(r.path), o.setResponseType("arraybuffer"), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function(c) {
            try {
              e(r.parse(c, a));
            } catch (l) {
              n ? n(l) : console.error(l), r.manager.itemError(t);
            }
          }, i, n);
        }
        parse(t, e) {
          if (AL(t)) Xt = new pL().parse(t);
          else {
            const n = _g(t);
            if (!gL(n)) throw new Error("THREE.FBXLoader: Unknown format.");
            if (ep(n) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + ep(n));
            Xt = new fL().parse(n);
          }
          const i = new hi(this.manager).setPath(this.resourcePath || e).setCrossOrigin(this.crossOrigin);
          return new hL(i, this.manager).parse(Xt);
        }
      }
      class hL {
        constructor(t, e) {
          this.textureLoader = t, this.manager = e;
        }
        parse() {
          Le = this.parseConnections();
          const t = this.parseImages(), e = this.parseTextures(t), i = this.parseMaterials(e), n = this.parseDeformers(), r = new dL().parse(n);
          return this.parseScene(n, r, i), gi;
        }
        parseConnections() {
          const t = /* @__PURE__ */ new Map();
          return "Connections" in Xt && Xt.Connections.connections.forEach(function(i) {
            const n = i[0], r = i[1], a = i[2];
            t.has(n) || t.set(n, {
              parents: [],
              children: []
            });
            const o = {
              ID: r,
              relationship: a
            };
            t.get(n).parents.push(o), t.has(r) || t.set(r, {
              parents: [],
              children: []
            });
            const c = {
              ID: n,
              relationship: a
            };
            t.get(r).children.push(c);
          }), t;
        }
        parseImages() {
          const t = {}, e = {};
          if ("Video" in Xt.Objects) {
            const i = Xt.Objects.Video;
            for (const n in i) {
              const r = i[n], a = parseInt(n);
              if (t[a] = r.RelativeFilename || r.Filename, "Content" in r) {
                const o = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0, c = typeof r.Content == "string" && r.Content !== "";
                if (o || c) {
                  const l = this.parseImage(i[n]);
                  e[r.RelativeFilename || r.Filename] = l;
                }
              }
            }
          }
          for (const i in t) {
            const n = t[i];
            e[n] !== void 0 ? t[i] = e[n] : t[i] = t[i].split("\\").pop();
          }
          return t;
        }
        parseImage(t) {
          const e = t.Content, i = t.RelativeFilename || t.Filename, n = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
          let r;
          switch (n) {
            case "bmp":
              r = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              r = "image/jpeg";
              break;
            case "png":
              r = "image/png";
              break;
            case "tif":
              r = "image/tiff";
              break;
            case "tga":
              this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", i), r = "image/tga";
              break;
            default:
              console.warn('FBXLoader: Image type "' + n + '" is not supported.');
              return;
          }
          if (typeof e == "string") return "data:" + r + ";base64," + e;
          {
            const a = new Uint8Array(e);
            return window.URL.createObjectURL(new Blob([
              a
            ], {
              type: r
            }));
          }
        }
        parseTextures(t) {
          const e = /* @__PURE__ */ new Map();
          if ("Texture" in Xt.Objects) {
            const i = Xt.Objects.Texture;
            for (const n in i) {
              const r = this.parseTexture(i[n], t);
              e.set(parseInt(n), r);
            }
          }
          return e;
        }
        parseTexture(t, e) {
          const i = this.loadTexture(t, e);
          i.ID = t.id, i.name = t.attrName;
          const n = t.WrapModeU, r = t.WrapModeV, a = n !== void 0 ? n.value : 0, o = r !== void 0 ? r.value : 0;
          if (i.wrapS = a === 0 ? ni : _i, i.wrapT = o === 0 ? ni : _i, "Scaling" in t) {
            const c = t.Scaling.value;
            i.repeat.x = c[0], i.repeat.y = c[1];
          }
          if ("Translation" in t) {
            const c = t.Translation.value;
            i.offset.x = c[0], i.offset.y = c[1];
          }
          return i;
        }
        loadTexture(t, e) {
          const i = /* @__PURE__ */ new Set([
            "tga",
            "tif",
            "tiff",
            "exr",
            "dds",
            "hdr",
            "ktx2"
          ]), n = t.FileName.split(".").pop().toLowerCase(), r = i.has(n) ? this.manager.getHandler(`.${n}`) : this.textureLoader;
          if (!r) return console.warn(`FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`, t.RelativeFilename), new Pe();
          const a = r.path;
          a || r.setPath(this.textureLoader.path);
          const o = Le.get(t.id).children;
          let c;
          o !== void 0 && o.length > 0 && e[o[0].ID] !== void 0 && (c = e[o[0].ID], (c.indexOf("blob:") === 0 || c.indexOf("data:") === 0) && r.setPath(void 0));
          const l = r.load(c);
          return r.setPath(a), l;
        }
        parseMaterials(t) {
          const e = /* @__PURE__ */ new Map();
          if ("Material" in Xt.Objects) {
            const i = Xt.Objects.Material;
            for (const n in i) {
              const r = this.parseMaterial(i[n], t);
              r !== null && e.set(parseInt(n), r);
            }
          }
          return e;
        }
        parseMaterial(t, e) {
          const i = t.id, n = t.attrName;
          let r = t.ShadingModel;
          if (typeof r == "object" && (r = r.value), !Le.has(i)) return null;
          const a = this.parseParameters(t, e, i);
          let o;
          switch (r.toLowerCase()) {
            case "phong":
              o = new eo();
              break;
            case "lambert":
              o = new jm();
              break;
            default:
              console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), o = new eo();
              break;
          }
          return o.setValues(a), o.name = n, o;
        }
        parseParameters(t, e, i) {
          const n = {};
          t.BumpFactor && (n.bumpScale = t.BumpFactor.value), t.Diffuse ? n.color = zt.toWorkingColorSpace(new ht().fromArray(t.Diffuse.value), ne) : t.DiffuseColor && (t.DiffuseColor.type === "Color" || t.DiffuseColor.type === "ColorRGB") && (n.color = zt.toWorkingColorSpace(new ht().fromArray(t.DiffuseColor.value), ne)), t.DisplacementFactor && (n.displacementScale = t.DisplacementFactor.value), t.Emissive ? n.emissive = zt.toWorkingColorSpace(new ht().fromArray(t.Emissive.value), ne) : t.EmissiveColor && (t.EmissiveColor.type === "Color" || t.EmissiveColor.type === "ColorRGB") && (n.emissive = zt.toWorkingColorSpace(new ht().fromArray(t.EmissiveColor.value), ne)), t.EmissiveFactor && (n.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), n.opacity = 1 - (t.TransparencyFactor ? parseFloat(t.TransparencyFactor.value) : 0), (n.opacity === 1 || n.opacity === 0) && (n.opacity = t.Opacity ? parseFloat(t.Opacity.value) : null, n.opacity === null && (n.opacity = 1 - (t.TransparentColor ? parseFloat(t.TransparentColor.value[0]) : 0))), n.opacity < 1 && (n.transparent = true), t.ReflectionFactor && (n.reflectivity = t.ReflectionFactor.value), t.Shininess && (n.shininess = t.Shininess.value), t.Specular ? n.specular = zt.toWorkingColorSpace(new ht().fromArray(t.Specular.value), ne) : t.SpecularColor && t.SpecularColor.type === "Color" && (n.specular = zt.toWorkingColorSpace(new ht().fromArray(t.SpecularColor.value), ne));
          const r = this;
          return Le.get(i).children.forEach(function(a) {
            const o = a.relationship;
            switch (o) {
              case "Bump":
                n.bumpMap = r.getTexture(e, a.ID);
                break;
              case "Maya|TEX_ao_map":
                n.aoMap = r.getTexture(e, a.ID);
                break;
              case "DiffuseColor":
              case "Maya|TEX_color_map":
                n.map = r.getTexture(e, a.ID), n.map !== void 0 && (n.map.colorSpace = ne);
                break;
              case "DisplacementColor":
                n.displacementMap = r.getTexture(e, a.ID);
                break;
              case "EmissiveColor":
                n.emissiveMap = r.getTexture(e, a.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = ne);
                break;
              case "NormalMap":
              case "Maya|TEX_normal_map":
                n.normalMap = r.getTexture(e, a.ID);
                break;
              case "ReflectionColor":
                n.envMap = r.getTexture(e, a.ID), n.envMap !== void 0 && (n.envMap.mapping = So, n.envMap.colorSpace = ne);
                break;
              case "SpecularColor":
                n.specularMap = r.getTexture(e, a.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = ne);
                break;
              case "TransparentColor":
              case "TransparencyFactor":
                n.alphaMap = r.getTexture(e, a.ID), n.transparent = true;
                break;
              case "AmbientColor":
              case "ShininessExponent":
              case "SpecularFactor":
              case "VectorDisplacementColor":
              default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", o);
                break;
            }
          }), n;
        }
        getTexture(t, e) {
          return "LayeredTexture" in Xt.Objects && e in Xt.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = Le.get(e).children[0].ID), t.get(e);
        }
        parseDeformers() {
          const t = {}, e = {};
          if ("Deformer" in Xt.Objects) {
            const i = Xt.Objects.Deformer;
            for (const n in i) {
              const r = i[n], a = Le.get(parseInt(n));
              if (r.attrType === "Skin") {
                const o = this.parseSkeleton(a, i);
                o.ID = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, t[n] = o;
              } else if (r.attrType === "BlendShape") {
                const o = {
                  id: n
                };
                o.rawTargets = this.parseMorphTargets(a, i), o.id = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[n] = o;
              }
            }
          }
          return {
            skeletons: t,
            morphTargets: e
          };
        }
        parseSkeleton(t, e) {
          const i = [];
          return t.children.forEach(function(n) {
            const r = e[n.ID];
            if (r.attrType !== "Cluster") return;
            const a = {
              ID: n.ID,
              indices: [],
              weights: [],
              transformLink: new ft().fromArray(r.TransformLink.a)
            };
            "Indexes" in r && (a.indices = r.Indexes.a, a.weights = r.Weights.a), i.push(a);
          }), {
            rawBones: i,
            bones: []
          };
        }
        parseMorphTargets(t, e) {
          const i = [];
          for (let n = 0; n < t.children.length; n++) {
            const r = t.children[n], a = e[r.ID], o = {
              name: a.attrName,
              initialWeight: a.DeformPercent,
              id: a.id,
              fullWeights: a.FullWeights.a
            };
            if (a.attrType !== "BlendShapeChannel") return;
            o.geoID = Le.get(parseInt(r.ID)).children.filter(function(c) {
              return c.relationship === void 0;
            })[0].ID, i.push(o);
          }
          return i;
        }
        parseScene(t, e, i) {
          gi = new ki();
          const n = this.parseModels(t.skeletons, e, i), r = Xt.Objects.Model, a = this;
          n.forEach(function(c) {
            const l = r[c.ID];
            a.setLookAtProperties(c, l), Le.get(c.ID).parents.forEach(function(d) {
              const u = n.get(d.ID);
              u !== void 0 && u.add(c);
            }), c.parent === null && gi.add(c);
          }), this.bindSkeleton(t.skeletons, e, n), this.addGlobalSceneSettings(), gi.traverse(function(c) {
            if (c.userData.transformData) {
              c.parent && (c.userData.transformData.parentMatrix = c.parent.matrix, c.userData.transformData.parentMatrixWorld = c.parent.matrixWorld);
              const l = gg(c.userData.transformData);
              c.applyMatrix4(l), c.updateWorldMatrix();
            }
          });
          const o = new uL().parse();
          gi.children.length === 1 && gi.children[0].isGroup && (gi.children[0].animations = o, gi = gi.children[0]), gi.animations = o;
        }
        parseModels(t, e, i) {
          const n = /* @__PURE__ */ new Map(), r = Xt.Objects.Model;
          for (const a in r) {
            const o = parseInt(a), c = r[a], l = Le.get(o);
            let h = this.buildSkeleton(l, t, o, c.attrName);
            if (!h) {
              switch (c.attrType) {
                case "Camera":
                  h = this.createCamera(l);
                  break;
                case "Light":
                  h = this.createLight(l);
                  break;
                case "Mesh":
                  h = this.createMesh(l, e, i);
                  break;
                case "NurbsCurve":
                  h = this.createCurve(l, e);
                  break;
                case "LimbNode":
                case "Root":
                  h = new ia();
                  break;
                case "Null":
                default:
                  h = new ki();
                  break;
              }
              h.name = c.attrName ? ee.sanitizeNodeName(c.attrName) : "", h.userData.originalName = c.attrName, h.ID = o;
            }
            this.getTransformData(h, c), n.set(o, h);
          }
          return n;
        }
        buildSkeleton(t, e, i, n) {
          let r = null;
          return t.parents.forEach(function(a) {
            for (const o in e) {
              const c = e[o];
              c.rawBones.forEach(function(l, h) {
                if (l.ID === a.ID) {
                  const d = r;
                  r = new ia(), r.matrixWorld.copy(l.transformLink), r.name = n ? ee.sanitizeNodeName(n) : "", r.userData.originalName = n, r.ID = i, c.bones[h] = r, d !== null && r.add(d);
                }
              });
            }
          }), r;
        }
        createCamera(t) {
          let e, i;
          if (t.children.forEach(function(n) {
            const r = Xt.Objects.NodeAttribute[n.ID];
            r !== void 0 && (i = r);
          }), i === void 0) e = new ce();
          else {
            let n = 0;
            i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (n = 1);
            let r = 1;
            i.NearPlane !== void 0 && (r = i.NearPlane.value / 1e3);
            let a = 1e3;
            i.FarPlane !== void 0 && (a = i.FarPlane.value / 1e3);
            let o = window.innerWidth, c = window.innerHeight;
            i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (o = i.AspectWidth.value, c = i.AspectHeight.value);
            const l = o / c;
            let h = 45;
            i.FieldOfView !== void 0 && (h = i.FieldOfView.value);
            const d = i.FocalLength ? i.FocalLength.value : null;
            switch (n) {
              case 0:
                e = new Ve(h, l, r, a), d !== null && e.setFocalLength(d);
                break;
              case 1:
                console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."), e = new ce();
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), e = new ce();
                break;
            }
          }
          return e;
        }
        createLight(t) {
          let e, i;
          if (t.children.forEach(function(n) {
            const r = Xt.Objects.NodeAttribute[n.ID];
            r !== void 0 && (i = r);
          }), i === void 0) e = new ce();
          else {
            let n;
            i.LightType === void 0 ? n = 0 : n = i.LightType.value;
            let r = 16777215;
            i.Color !== void 0 && (r = zt.toWorkingColorSpace(new ht().fromArray(i.Color.value), ne));
            let a = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
            i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (a = 0);
            let o = 0;
            i.FarAttenuationEnd !== void 0 && (i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? o = 0 : o = i.FarAttenuationEnd.value);
            const c = 1;
            switch (n) {
              case 0:
                e = new lh(r, a, o, c);
                break;
              case 1:
                e = new ec(r, a);
                break;
              case 2:
                let l = Math.PI / 3;
                i.InnerAngle !== void 0 && (l = ke.degToRad(i.InnerAngle.value));
                let h = 0;
                i.OuterAngle !== void 0 && (h = ke.degToRad(i.OuterAngle.value), h = Math.max(h, 1)), e = new Vp(r, a, o, l, h, c);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), e = new lh(r, a);
                break;
            }
            i.CastShadows !== void 0 && i.CastShadows.value === 1 && (e.castShadow = true);
          }
          return e;
        }
        createMesh(t, e, i) {
          let n, r = null, a = null;
          const o = [];
          if (t.children.forEach(function(c) {
            e.has(c.ID) && (r = e.get(c.ID)), i.has(c.ID) && o.push(i.get(c.ID));
          }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new eo({
            name: Ui.DEFAULT_MATERIAL_NAME,
            color: 13421772
          }), o.push(a)), "color" in r.attributes && o.forEach(function(c) {
            c.vertexColors = true;
          }), r.groups.length > 0) {
            let c = false;
            for (let l = 0, h = r.groups.length; l < h; l++) {
              const d = r.groups[l];
              (d.materialIndex < 0 || d.materialIndex >= o.length) && (d.materialIndex = o.length, c = true);
            }
            if (c) {
              const l = new eo();
              o.push(l);
            }
          }
          return r.FBX_Deformer ? (n = new Wh(r, a), n.normalizeSkinWeights()) : n = new me(r, a), n;
        }
        createCurve(t, e) {
          const i = t.children.reduce(function(r, a) {
            return e.has(a.ID) && (r = e.get(a.ID)), r;
          }, null), n = new ma({
            name: Ui.DEFAULT_MATERIAL_NAME,
            color: 3342591,
            linewidth: 1
          });
          return new ls(i, n);
        }
        getTransformData(t, e) {
          const i = {};
          "InheritType" in e && (i.inheritType = parseInt(e.InheritType.value)), "RotationOrder" in e ? i.eulerOrder = Aa(e.RotationOrder.value) : i.eulerOrder = Aa(0), "Lcl_Translation" in e && (i.translation = e.Lcl_Translation.value), "PreRotation" in e && (i.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (i.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (i.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (i.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (i.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (i.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (i.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (i.rotationPivot = e.RotationPivot.value), t.userData.transformData = i;
        }
        setLookAtProperties(t, e) {
          "LookAtProperty" in e && Le.get(t.ID).children.forEach(function(n) {
            if (n.relationship === "LookAtProperty") {
              const r = Xt.Objects.Model[n.ID];
              if ("Lcl_Translation" in r) {
                const a = r.Lcl_Translation.value;
                t.target !== void 0 ? (t.target.position.fromArray(a), gi.add(t.target)) : t.lookAt(new I().fromArray(a));
              }
            }
          });
        }
        bindSkeleton(t, e, i) {
          const n = this.parsePoseNodes();
          for (const r in t) {
            const a = t[r];
            Le.get(parseInt(a.ID)).parents.forEach(function(c) {
              if (e.has(c.ID)) {
                const l = c.ID;
                Le.get(l).parents.forEach(function(d) {
                  i.has(d.ID) && i.get(d.ID).bind(new _a(a.bones), n[d.ID]);
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const t = {};
          if ("Pose" in Xt.Objects) {
            const e = Xt.Objects.Pose;
            for (const i in e) if (e[i].attrType === "BindPose" && e[i].NbPoseNodes > 0) {
              const n = e[i].PoseNode;
              Array.isArray(n) ? n.forEach(function(r) {
                t[r.Node] = new ft().fromArray(r.Matrix.a);
              }) : t[n.Node] = new ft().fromArray(n.Matrix.a);
            }
          }
          return t;
        }
        addGlobalSceneSettings() {
          if ("GlobalSettings" in Xt) {
            if ("AmbientColor" in Xt.GlobalSettings) {
              const t = Xt.GlobalSettings.AmbientColor.value, e = t[0], i = t[1], n = t[2];
              if (e !== 0 || i !== 0 || n !== 0) {
                const r = new ht().setRGB(e, i, n, ne);
                gi.add(new id(r, 1));
              }
            }
            "UnitScaleFactor" in Xt.GlobalSettings && (gi.userData.unitScaleFactor = Xt.GlobalSettings.UnitScaleFactor.value);
          }
        }
      }
      class dL {
        constructor() {
          this.negativeMaterialIndices = false;
        }
        parse(t) {
          const e = /* @__PURE__ */ new Map();
          if ("Geometry" in Xt.Objects) {
            const i = Xt.Objects.Geometry;
            for (const n in i) {
              const r = Le.get(parseInt(n)), a = this.parseGeometry(r, i[n], t);
              e.set(parseInt(n), a);
            }
          }
          return this.negativeMaterialIndices === true && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), e;
        }
        parseGeometry(t, e, i) {
          switch (e.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(t, e, i);
            case "NurbsCurve":
              return this.parseNurbsGeometry(e);
          }
        }
        parseMeshGeometry(t, e, i) {
          const n = i.skeletons, r = [], a = t.parents.map(function(d) {
            return Xt.Objects.Model[d.ID];
          });
          if (a.length === 0) return;
          const o = t.children.reduce(function(d, u) {
            return n[u.ID] !== void 0 && (d = n[u.ID]), d;
          }, null);
          t.children.forEach(function(d) {
            i.morphTargets[d.ID] !== void 0 && r.push(i.morphTargets[d.ID]);
          });
          const c = a[0], l = {};
          "RotationOrder" in c && (l.eulerOrder = Aa(c.RotationOrder.value)), "InheritType" in c && (l.inheritType = parseInt(c.InheritType.value)), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value);
          const h = gg(l);
          return this.genGeometry(e, o, r, h);
        }
        genGeometry(t, e, i, n) {
          const r = new Fe();
          t.attrName && (r.name = t.attrName);
          const a = this.parseGeoNode(t, e), o = this.genBuffers(a), c = new le(o.vertex, 3);
          if (c.applyMatrix4(n), r.setAttribute("position", c), o.colors.length > 0 && r.setAttribute("color", new le(o.colors, 3)), e && (r.setAttribute("skinIndex", new Jo(o.weightsIndices, 4)), r.setAttribute("skinWeight", new le(o.vertexWeights, 4)), r.FBX_Deformer = e), o.normal.length > 0) {
            const l = new Ot().getNormalMatrix(n), h = new le(o.normal, 3);
            h.applyNormalMatrix(l), r.setAttribute("normal", h);
          }
          if (o.uvs.forEach(function(l, h) {
            const d = h === 0 ? "uv" : `uv${h}`;
            r.setAttribute(d, new le(o.uvs[h], 2));
          }), a.material && a.material.mappingType !== "AllSame") {
            let l = o.materialIndex[0], h = 0;
            if (o.materialIndex.forEach(function(d, u) {
              d !== l && (r.addGroup(h, u - h, l), l = d, h = u);
            }), r.groups.length > 0) {
              const d = r.groups[r.groups.length - 1], u = d.start + d.count;
              u !== o.materialIndex.length && r.addGroup(u, o.materialIndex.length - u, l);
            }
            r.groups.length === 0 && r.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
          }
          return this.addMorphTargets(r, t, i, n), r;
        }
        parseGeoNode(t, e) {
          const i = {};
          if (i.vertexPositions = t.Vertices !== void 0 ? t.Vertices.a : [], i.vertexIndices = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (i.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (i.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (i.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
            i.uv = [];
            let n = 0;
            for (; t.LayerElementUV[n]; ) t.LayerElementUV[n].UV && i.uv.push(this.parseUVs(t.LayerElementUV[n])), n++;
          }
          return i.weightTable = {}, e !== null && (i.skeleton = e, e.rawBones.forEach(function(n, r) {
            n.indices.forEach(function(a, o) {
              i.weightTable[a] === void 0 && (i.weightTable[a] = []), i.weightTable[a].push({
                id: r,
                weight: n.weights[o]
              });
            });
          })), i;
        }
        genBuffers(t) {
          const e = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
          };
          let i = 0, n = 0, r = false, a = [], o = [], c = [], l = [], h = [], d = [];
          const u = this;
          return t.vertexIndices.forEach(function(f, p) {
            let m, g = false;
            f < 0 && (f = f ^ -1, g = true);
            let A = [], x = [];
            if (a.push(f * 3, f * 3 + 1, f * 3 + 2), t.color) {
              const b = _o(p, i, f, t.color);
              c.push(b[0], b[1], b[2]);
            }
            if (t.skeleton) {
              if (t.weightTable[f] !== void 0 && t.weightTable[f].forEach(function(b) {
                x.push(b.weight), A.push(b.id);
              }), x.length > 4) {
                r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = true);
                const b = [
                  0,
                  0,
                  0,
                  0
                ], y = [
                  0,
                  0,
                  0,
                  0
                ];
                x.forEach(function(M, T) {
                  let R = M, B = A[T];
                  y.forEach(function(S, E, P) {
                    if (R > S) {
                      P[E] = R, R = S;
                      const G = b[E];
                      b[E] = B, B = G;
                    }
                  });
                }), A = b, x = y;
              }
              for (; x.length < 4; ) x.push(0), A.push(0);
              for (let b = 0; b < 4; ++b) h.push(x[b]), d.push(A[b]);
            }
            if (t.normal) {
              const b = _o(p, i, f, t.normal);
              o.push(b[0], b[1], b[2]);
            }
            t.material && t.material.mappingType !== "AllSame" && (m = _o(p, i, f, t.material)[0], m < 0 && (u.negativeMaterialIndices = true, m = 0)), t.uv && t.uv.forEach(function(b, y) {
              const M = _o(p, i, f, b);
              l[y] === void 0 && (l[y] = []), l[y].push(M[0]), l[y].push(M[1]);
            }), n++, g && (u.genFace(e, t, a, m, o, c, l, h, d, n), i++, n = 0, a = [], o = [], c = [], l = [], h = [], d = []);
          }), e;
        }
        getNormalNewell(t) {
          const e = new I(0, 0, 0);
          for (let i = 0; i < t.length; i++) {
            const n = t[i], r = t[(i + 1) % t.length];
            e.x += (n.y - r.y) * (n.z + r.z), e.y += (n.z - r.z) * (n.x + r.x), e.z += (n.x - r.x) * (n.y + r.y);
          }
          return e.normalize(), e;
        }
        getNormalTangentAndBitangent(t) {
          const e = this.getNormalNewell(t), n = (Math.abs(e.z) > 0.5 ? new I(0, 1, 0) : new I(0, 0, 1)).cross(e).normalize(), r = e.clone().cross(n).normalize();
          return {
            normal: e,
            tangent: n,
            bitangent: r
          };
        }
        flattenVertex(t, e, i) {
          return new rt(t.dot(e), t.dot(i));
        }
        genFace(t, e, i, n, r, a, o, c, l, h) {
          let d;
          if (h > 3) {
            const u = [], f = e.baseVertexPositions || e.vertexPositions;
            for (let A = 0; A < i.length; A += 3) u.push(new I(f[i[A]], f[i[A + 1]], f[i[A + 2]]));
            const { tangent: p, bitangent: m } = this.getNormalTangentAndBitangent(u), g = [];
            for (const A of u) g.push(this.flattenVertex(A, p, m));
            d = Jh.triangulateShape(g, []);
          } else d = [
            [
              0,
              1,
              2
            ]
          ];
          for (const [u, f, p] of d) t.vertex.push(e.vertexPositions[i[u * 3]]), t.vertex.push(e.vertexPositions[i[u * 3 + 1]]), t.vertex.push(e.vertexPositions[i[u * 3 + 2]]), t.vertex.push(e.vertexPositions[i[f * 3]]), t.vertex.push(e.vertexPositions[i[f * 3 + 1]]), t.vertex.push(e.vertexPositions[i[f * 3 + 2]]), t.vertex.push(e.vertexPositions[i[p * 3]]), t.vertex.push(e.vertexPositions[i[p * 3 + 1]]), t.vertex.push(e.vertexPositions[i[p * 3 + 2]]), e.skeleton && (t.vertexWeights.push(c[u * 4]), t.vertexWeights.push(c[u * 4 + 1]), t.vertexWeights.push(c[u * 4 + 2]), t.vertexWeights.push(c[u * 4 + 3]), t.vertexWeights.push(c[f * 4]), t.vertexWeights.push(c[f * 4 + 1]), t.vertexWeights.push(c[f * 4 + 2]), t.vertexWeights.push(c[f * 4 + 3]), t.vertexWeights.push(c[p * 4]), t.vertexWeights.push(c[p * 4 + 1]), t.vertexWeights.push(c[p * 4 + 2]), t.vertexWeights.push(c[p * 4 + 3]), t.weightsIndices.push(l[u * 4]), t.weightsIndices.push(l[u * 4 + 1]), t.weightsIndices.push(l[u * 4 + 2]), t.weightsIndices.push(l[u * 4 + 3]), t.weightsIndices.push(l[f * 4]), t.weightsIndices.push(l[f * 4 + 1]), t.weightsIndices.push(l[f * 4 + 2]), t.weightsIndices.push(l[f * 4 + 3]), t.weightsIndices.push(l[p * 4]), t.weightsIndices.push(l[p * 4 + 1]), t.weightsIndices.push(l[p * 4 + 2]), t.weightsIndices.push(l[p * 4 + 3])), e.color && (t.colors.push(a[u * 3]), t.colors.push(a[u * 3 + 1]), t.colors.push(a[u * 3 + 2]), t.colors.push(a[f * 3]), t.colors.push(a[f * 3 + 1]), t.colors.push(a[f * 3 + 2]), t.colors.push(a[p * 3]), t.colors.push(a[p * 3 + 1]), t.colors.push(a[p * 3 + 2])), e.material && e.material.mappingType !== "AllSame" && (t.materialIndex.push(n), t.materialIndex.push(n), t.materialIndex.push(n)), e.normal && (t.normal.push(r[u * 3]), t.normal.push(r[u * 3 + 1]), t.normal.push(r[u * 3 + 2]), t.normal.push(r[f * 3]), t.normal.push(r[f * 3 + 1]), t.normal.push(r[f * 3 + 2]), t.normal.push(r[p * 3]), t.normal.push(r[p * 3 + 1]), t.normal.push(r[p * 3 + 2])), e.uv && e.uv.forEach(function(m, g) {
            t.uvs[g] === void 0 && (t.uvs[g] = []), t.uvs[g].push(o[g][u * 2]), t.uvs[g].push(o[g][u * 2 + 1]), t.uvs[g].push(o[g][f * 2]), t.uvs[g].push(o[g][f * 2 + 1]), t.uvs[g].push(o[g][p * 2]), t.uvs[g].push(o[g][p * 2 + 1]);
          });
        }
        addMorphTargets(t, e, i, n) {
          if (i.length === 0) return;
          t.morphTargetsRelative = true, t.morphAttributes.position = [];
          const r = this;
          i.forEach(function(a) {
            a.rawTargets.forEach(function(o) {
              const c = Xt.Objects.Geometry[o.geoID];
              c !== void 0 && r.genMorphGeometry(t, e, c, n, o.name);
            });
          });
        }
        genMorphGeometry(t, e, i, n, r) {
          const a = e.Vertices !== void 0 ? e.Vertices.a : [], o = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], c = i.Vertices !== void 0 ? i.Vertices.a : [], l = i.Indexes !== void 0 ? i.Indexes.a : [], h = t.attributes.position.count * 3, d = new Float32Array(h);
          for (let m = 0; m < l.length; m++) {
            const g = l[m] * 3;
            d[g] = c[m * 3], d[g + 1] = c[m * 3 + 1], d[g + 2] = c[m * 3 + 2];
          }
          const u = {
            vertexIndices: o,
            vertexPositions: d,
            baseVertexPositions: a
          }, f = this.genBuffers(u), p = new le(f.vertex, 3);
          p.name = r || i.attrName, p.applyMatrix4(n), t.morphAttributes.position.push(p);
        }
        parseNormals(t) {
          const e = t.MappingInformationType, i = t.ReferenceInformationType, n = t.Normals.a;
          let r = [];
          return i === "IndexToDirect" && ("NormalIndex" in t ? r = t.NormalIndex.a : "NormalsIndex" in t && (r = t.NormalsIndex.a)), {
            dataSize: 3,
            buffer: n,
            indices: r,
            mappingType: e,
            referenceType: i
          };
        }
        parseUVs(t) {
          const e = t.MappingInformationType, i = t.ReferenceInformationType, n = t.UV.a;
          let r = [];
          return i === "IndexToDirect" && (r = t.UVIndex.a), {
            dataSize: 2,
            buffer: n,
            indices: r,
            mappingType: e,
            referenceType: i
          };
        }
        parseVertexColors(t) {
          const e = t.MappingInformationType, i = t.ReferenceInformationType, n = t.Colors.a;
          let r = [];
          i === "IndexToDirect" && (r = t.ColorIndex.a);
          for (let a = 0, o = new ht(); a < n.length; a += 4) o.fromArray(n, a), zt.toWorkingColorSpace(o, ne), o.toArray(n, a);
          return {
            dataSize: 4,
            buffer: n,
            indices: r,
            mappingType: e,
            referenceType: i
          };
        }
        parseMaterialIndices(t) {
          const e = t.MappingInformationType, i = t.ReferenceInformationType;
          if (e === "NoMappingInformation") return {
            dataSize: 1,
            buffer: [
              0
            ],
            indices: [
              0
            ],
            mappingType: "AllSame",
            referenceType: i
          };
          const n = t.Materials.a, r = [];
          for (let a = 0; a < n.length; ++a) r.push(a);
          return {
            dataSize: 1,
            buffer: n,
            indices: r,
            mappingType: e,
            referenceType: i
          };
        }
        parseNurbsGeometry(t) {
          const e = parseInt(t.Order);
          if (isNaN(e)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new Fe();
          const i = e - 1, n = t.KnotVector.a, r = [], a = t.Points.a;
          for (let d = 0, u = a.length; d < u; d += 4) r.push(new jt().fromArray(a, d));
          let o, c;
          if (t.Form === "Closed") r.push(r[0]);
          else if (t.Form === "Periodic") {
            o = i, c = n.length - 1 - o;
            for (let d = 0; d < i; ++d) r.push(r[d]);
          }
          const h = new cL(i, n, r, o, c).getPoints(r.length * 12);
          return new Fe().setFromPoints(h);
        }
      }
      class uL {
        parse() {
          const t = [], e = this.parseClips();
          if (e !== void 0) for (const i in e) {
            const n = e[i], r = this.addClip(n);
            t.push(r);
          }
          return t;
        }
        parseClips() {
          if (Xt.Objects.AnimationCurve === void 0) return;
          const t = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(t);
          const e = this.parseAnimationLayers(t);
          return this.parseAnimStacks(e);
        }
        parseAnimationCurveNodes() {
          const t = Xt.Objects.AnimationCurveNode, e = /* @__PURE__ */ new Map();
          for (const i in t) {
            const n = t[i];
            if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
              const r = {
                id: n.id,
                attr: n.attrName,
                curves: {}
              };
              e.set(r.id, r);
            }
          }
          return e;
        }
        parseAnimationCurves(t) {
          const e = Xt.Objects.AnimationCurve;
          for (const i in e) {
            const n = {
              id: e[i].id,
              times: e[i].KeyTime.a.map(_L),
              values: e[i].KeyValueFloat.a
            }, r = Le.get(n.id);
            if (r !== void 0) {
              const a = r.parents[0].ID, o = r.parents[0].relationship;
              o.match(/X/) ? t.get(a).curves.x = n : o.match(/Y/) ? t.get(a).curves.y = n : o.match(/Z/) ? t.get(a).curves.z = n : o.match(/DeformPercent/) && t.has(a) && (t.get(a).curves.morph = n);
            }
          }
        }
        parseAnimationLayers(t) {
          const e = Xt.Objects.AnimationLayer, i = /* @__PURE__ */ new Map();
          for (const n in e) {
            const r = [], a = Le.get(parseInt(n));
            a !== void 0 && (a.children.forEach(function(c, l) {
              if (t.has(c.ID)) {
                const h = t.get(c.ID);
                if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
                  if (r[l] === void 0) {
                    const d = Le.get(c.ID).parents.filter(function(u) {
                      return u.relationship !== void 0;
                    })[0].ID;
                    if (d !== void 0) {
                      const u = Xt.Objects.Model[d.toString()];
                      if (u === void 0) {
                        console.warn("THREE.FBXLoader: Encountered a unused curve.", c);
                        return;
                      }
                      const f = {
                        modelName: u.attrName ? ee.sanitizeNodeName(u.attrName) : "",
                        ID: u.id,
                        initialPosition: [
                          0,
                          0,
                          0
                        ],
                        initialRotation: [
                          0,
                          0,
                          0
                        ],
                        initialScale: [
                          1,
                          1,
                          1
                        ]
                      };
                      gi.traverse(function(p) {
                        p.ID === u.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                      }), f.transform || (f.transform = new ft()), "PreRotation" in u && (f.preRotation = u.PreRotation.value), "PostRotation" in u && (f.postRotation = u.PostRotation.value), r[l] = f;
                    }
                  }
                  r[l] && (r[l][h.attr] = h);
                } else if (h.curves.morph !== void 0) {
                  if (r[l] === void 0) {
                    const d = Le.get(c.ID).parents.filter(function(A) {
                      return A.relationship !== void 0;
                    })[0].ID, u = Le.get(d).parents[0].ID, f = Le.get(u).parents[0].ID, p = Le.get(f).parents[0].ID, m = Xt.Objects.Model[p], g = {
                      modelName: m.attrName ? ee.sanitizeNodeName(m.attrName) : "",
                      morphName: Xt.Objects.Deformer[d].attrName
                    };
                    r[l] = g;
                  }
                  r[l][h.attr] = h;
                }
              }
            }), i.set(parseInt(n), r));
          }
          return i;
        }
        parseAnimStacks(t) {
          const e = Xt.Objects.AnimationStack, i = {};
          for (const n in e) {
            const r = Le.get(parseInt(n)).children;
            r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const a = t.get(r[0].ID);
            i[n] = {
              name: e[n].attrName,
              layer: a
            };
          }
          return i;
        }
        addClip(t) {
          let e = [];
          const i = this;
          return t.layer.forEach(function(n) {
            e = e.concat(i.generateTracks(n));
          }), new Qo(t.name, -1, e);
        }
        generateTracks(t) {
          const e = [];
          let i = new I(), n = new I();
          if (t.transform && t.transform.decompose(i, new ue(), n), i = i.toArray(), n = n.toArray(), t.T !== void 0 && Object.keys(t.T.curves).length > 0) {
            const r = this.generateVectorTrack(t.modelName, t.T.curves, i, "position");
            r !== void 0 && e.push(r);
          }
          if (t.R !== void 0 && Object.keys(t.R.curves).length > 0) {
            const r = this.generateRotationTrack(t.modelName, t.R.curves, t.preRotation, t.postRotation, t.eulerOrder);
            r !== void 0 && e.push(r);
          }
          if (t.S !== void 0 && Object.keys(t.S.curves).length > 0) {
            const r = this.generateVectorTrack(t.modelName, t.S.curves, n, "scale");
            r !== void 0 && e.push(r);
          }
          if (t.DeformPercent !== void 0) {
            const r = this.generateMorphTrack(t);
            r !== void 0 && e.push(r);
          }
          return e;
        }
        generateVectorTrack(t, e, i, n) {
          const r = this.getTimesForAllAxes(e), a = this.getKeyframeTrackValues(r, e, i);
          return new br(t + "." + n, r, a);
        }
        generateRotationTrack(t, e, i, n, r) {
          let a, o;
          if (e.x !== void 0 && e.y !== void 0 && e.z !== void 0) {
            const u = this.interpolateRotations(e.x, e.y, e.z, r);
            a = u[0], o = u[1];
          }
          const c = Aa(0);
          i !== void 0 && (i = i.map(ke.degToRad), i.push(c), i = new Oe().fromArray(i), i = new ue().setFromEuler(i)), n !== void 0 && (n = n.map(ke.degToRad), n.push(c), n = new Oe().fromArray(n), n = new ue().setFromEuler(n).invert());
          const l = new ue(), h = new Oe(), d = [];
          if (!o || !a) return new Wn(t + ".quaternion", [
            0
          ], [
            0
          ]);
          for (let u = 0; u < o.length; u += 3) h.set(o[u], o[u + 1], o[u + 2], r), l.setFromEuler(h), i !== void 0 && l.premultiply(i), n !== void 0 && l.multiply(n), u > 2 && new ue().fromArray(d, (u - 3) / 3 * 4).dot(l) < 0 && l.set(-l.x, -l.y, -l.z, -l.w), l.toArray(d, u / 3 * 4);
          return new Wn(t + ".quaternion", a, d);
        }
        generateMorphTrack(t) {
          const e = t.DeformPercent.curves.morph, i = e.values.map(function(r) {
            return r / 100;
          }), n = gi.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];
          return new wr(t.modelName + ".morphTargetInfluences[" + n + "]", e.times, i);
        }
        getTimesForAllAxes(t) {
          let e = [];
          if (t.x !== void 0 && (e = e.concat(t.x.times)), t.y !== void 0 && (e = e.concat(t.y.times)), t.z !== void 0 && (e = e.concat(t.z.times)), e = e.sort(function(i, n) {
            return i - n;
          }), e.length > 1) {
            let i = 1, n = e[0];
            for (let r = 1; r < e.length; r++) {
              const a = e[r];
              a !== n && (e[i] = a, n = a, i++);
            }
            e = e.slice(0, i);
          }
          return e;
        }
        getKeyframeTrackValues(t, e, i) {
          const n = i, r = [];
          let a = -1, o = -1, c = -1;
          return t.forEach(function(l) {
            if (e.x && (a = e.x.times.indexOf(l)), e.y && (o = e.y.times.indexOf(l)), e.z && (c = e.z.times.indexOf(l)), a !== -1) {
              const h = e.x.values[a];
              r.push(h), n[0] = h;
            } else r.push(n[0]);
            if (o !== -1) {
              const h = e.y.values[o];
              r.push(h), n[1] = h;
            } else r.push(n[1]);
            if (c !== -1) {
              const h = e.z.values[c];
              r.push(h), n[2] = h;
            } else r.push(n[2]);
          }), r;
        }
        interpolateRotations(t, e, i, n) {
          const r = [], a = [];
          r.push(t.times[0]), a.push(ke.degToRad(t.values[0])), a.push(ke.degToRad(e.values[0])), a.push(ke.degToRad(i.values[0]));
          for (let o = 1; o < t.values.length; o++) {
            const c = [
              t.values[o - 1],
              e.values[o - 1],
              i.values[o - 1]
            ];
            if (isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2])) continue;
            const l = c.map(ke.degToRad), h = [
              t.values[o],
              e.values[o],
              i.values[o]
            ];
            if (isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2])) continue;
            const d = h.map(ke.degToRad), u = [
              h[0] - c[0],
              h[1] - c[1],
              h[2] - c[2]
            ], f = [
              Math.abs(u[0]),
              Math.abs(u[1]),
              Math.abs(u[2])
            ];
            if (f[0] >= 180 || f[1] >= 180 || f[2] >= 180) {
              const m = Math.max(...f) / 180, g = new Oe(...l, n), A = new Oe(...d, n), x = new ue().setFromEuler(g), b = new ue().setFromEuler(A);
              x.dot(b) && b.set(-b.x, -b.y, -b.z, -b.w);
              const y = t.times[o - 1], M = t.times[o] - y, T = new ue(), R = new Oe();
              for (let B = 0; B < 1; B += 1 / m) T.copy(x.clone().slerp(b.clone(), B)), r.push(y + B * M), R.setFromQuaternion(T, n), a.push(R.x), a.push(R.y), a.push(R.z);
            } else r.push(t.times[o]), a.push(ke.degToRad(t.values[o])), a.push(ke.degToRad(e.values[o])), a.push(ke.degToRad(i.values[o]));
          }
          return [
            r,
            a
          ];
        }
      }
      class fL {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(t) {
          this.nodeStack.push(t), this.currentIndent += 1;
        }
        popStack() {
          this.nodeStack.pop(), this.currentIndent -= 1;
        }
        setCurrentProp(t, e) {
          this.currentProp = t, this.currentPropName = e;
        }
        parse(t) {
          this.currentIndent = 0, this.allNodes = new Ag(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
          const e = this, i = t.split(/[\r\n]+/);
          return i.forEach(function(n, r) {
            const a = n.match(/^[\s\t]*;/), o = n.match(/^[\s\t]*$/);
            if (a || o) return;
            const c = n.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = n.match("^\\t{" + (e.currentIndent - 1) + "}}");
            c ? e.parseNodeBegin(n, c) : l ? e.parseNodeProperty(n, l, i[++r]) : h ? e.popStack() : n.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(n);
          }), this.allNodes;
        }
        parseNodeBegin(t, e) {
          const i = e[1].trim().replace(/^"/, "").replace(/"$/, ""), n = e[2].split(",").map(function(c) {
            return c.trim().replace(/^"/, "").replace(/"$/, "");
          }), r = {
            name: i
          }, a = this.parseNodeAttr(n), o = this.getCurrentNode();
          this.currentIndent === 0 ? this.allNodes.add(i, r) : i in o ? (i === "PoseNode" ? o.PoseNode.push(r) : o[i].id !== void 0 && (o[i] = {}, o[i][o[i].id] = o[i]), a.id !== "" && (o[i][a.id] = r)) : typeof a.id == "number" ? (o[i] = {}, o[i][a.id] = r) : i !== "Properties70" && (i === "PoseNode" ? o[i] = [
            r
          ] : o[i] = r), typeof a.id == "number" && (r.id = a.id), a.name !== "" && (r.attrName = a.name), a.type !== "" && (r.attrType = a.type), this.pushStack(r);
        }
        parseNodeAttr(t) {
          let e = t[0];
          t[0] !== "" && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
          let i = "", n = "";
          return t.length > 1 && (i = t[1].replace(/^(\w+)::/, ""), n = t[2]), {
            id: e,
            name: i,
            type: n
          };
        }
        parseNodeProperty(t, e, i) {
          let n = e[1].replace(/^"/, "").replace(/"$/, "").trim(), r = e[2].replace(/^"/, "").replace(/"$/, "").trim();
          n === "Content" && r === "," && (r = i.replace(/"/g, "").replace(/,$/, "").trim());
          const a = this.getCurrentNode();
          if (a.name === "Properties70") {
            this.parseNodeSpecialProperty(t, n, r);
            return;
          }
          if (n === "C") {
            const c = r.split(",").slice(1), l = parseInt(c[0]), h = parseInt(c[1]);
            let d = r.split(",").slice(3);
            d = d.map(function(u) {
              return u.trim().replace(/^"/, "");
            }), n = "connections", r = [
              l,
              h
            ], wL(r, d), a[n] === void 0 && (a[n] = []);
          }
          n === "Node" && (a.id = r), n in a && Array.isArray(a[n]) ? a[n].push(r) : n !== "a" ? a[n] = r : a.a = r, this.setCurrentProp(a, n), n === "a" && r.slice(-1) !== "," && (a.a = Ml(r));
        }
        parseNodePropertyContinued(t) {
          const e = this.getCurrentNode();
          e.a += t, t.slice(-1) !== "," && (e.a = Ml(e.a));
        }
        parseNodeSpecialProperty(t, e, i) {
          const n = i.split('",').map(function(h) {
            return h.trim().replace(/^\"/, "").replace(/\s/, "_");
          }), r = n[0], a = n[1], o = n[2], c = n[3];
          let l = n[4];
          switch (a) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              l = parseFloat(l);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              l = Ml(l);
              break;
          }
          this.getPrevNode()[r] = {
            type: a,
            type2: o,
            flag: c,
            value: l
          }, this.setCurrentProp(this.getPrevNode(), r);
        }
      }
      class pL {
        parse(t) {
          const e = new tp(t);
          e.skip(23);
          const i = e.getUint32();
          if (i < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
          const n = new Ag();
          for (; !this.endOfContent(e); ) {
            const r = this.parseNode(e, i);
            r !== null && n.add(r.name, r);
          }
          return n;
        }
        endOfContent(t) {
          return t.size() % 16 === 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size();
        }
        parseNode(t, e) {
          const i = {}, n = e >= 7500 ? t.getUint64() : t.getUint32(), r = e >= 7500 ? t.getUint64() : t.getUint32();
          e >= 7500 ? t.getUint64() : t.getUint32();
          const a = t.getUint8(), o = t.getString(a);
          if (n === 0) return null;
          const c = [];
          for (let u = 0; u < r; u++) c.push(this.parseProperty(t));
          const l = c.length > 0 ? c[0] : "", h = c.length > 1 ? c[1] : "", d = c.length > 2 ? c[2] : "";
          for (i.singleProperty = r === 1 && t.getOffset() === n; n > t.getOffset(); ) {
            const u = this.parseNode(t, e);
            u !== null && this.parseSubNode(o, i, u);
          }
          return i.propertyList = c, typeof l == "number" && (i.id = l), h !== "" && (i.attrName = h), d !== "" && (i.attrType = d), o !== "" && (i.name = o), i;
        }
        parseSubNode(t, e, i) {
          if (i.singleProperty === true) {
            const n = i.propertyList[0];
            Array.isArray(n) ? (e[i.name] = i, i.a = n) : e[i.name] = n;
          } else if (t === "Connections" && i.name === "C") {
            const n = [];
            i.propertyList.forEach(function(r, a) {
              a !== 0 && n.push(r);
            }), e.connections === void 0 && (e.connections = []), e.connections.push(n);
          } else if (i.name === "Properties70") Object.keys(i).forEach(function(r) {
            e[r] = i[r];
          });
          else if (t === "Properties70" && i.name === "P") {
            let n = i.propertyList[0], r = i.propertyList[1];
            const a = i.propertyList[2], o = i.propertyList[3];
            let c;
            n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), r === "Color" || r === "ColorRGB" || r === "Vector" || r === "Vector3D" || r.indexOf("Lcl_") === 0 ? c = [
              i.propertyList[4],
              i.propertyList[5],
              i.propertyList[6]
            ] : c = i.propertyList[4], e[n] = {
              type: r,
              type2: a,
              flag: o,
              value: c
            };
          } else e[i.name] === void 0 ? typeof i.id == "number" ? (e[i.name] = {}, e[i.name][i.id] = i) : e[i.name] = i : i.name === "PoseNode" ? (Array.isArray(e[i.name]) || (e[i.name] = [
            e[i.name]
          ]), e[i.name].push(i)) : e[i.name][i.id] === void 0 && (e[i.name][i.id] = i);
        }
        parseProperty(t) {
          const e = t.getString(1);
          let i;
          switch (e) {
            case "C":
              return t.getBoolean();
            case "D":
              return t.getFloat64();
            case "F":
              return t.getFloat32();
            case "I":
              return t.getInt32();
            case "L":
              return t.getInt64();
            case "R":
              return i = t.getUint32(), t.getArrayBuffer(i);
            case "S":
              return i = t.getUint32(), t.getString(i);
            case "Y":
              return t.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const n = t.getUint32(), r = t.getUint32(), a = t.getUint32();
              if (r === 0) switch (e) {
                case "b":
                case "c":
                  return t.getBooleanArray(n);
                case "d":
                  return t.getFloat64Array(n);
                case "f":
                  return t.getFloat32Array(n);
                case "i":
                  return t.getInt32Array(n);
                case "l":
                  return t.getInt64Array(n);
              }
              const o = ZF(new Uint8Array(t.getArrayBuffer(a))), c = new tp(o.buffer);
              switch (e) {
                case "b":
                case "c":
                  return c.getBooleanArray(n);
                case "d":
                  return c.getFloat64Array(n);
                case "f":
                  return c.getFloat32Array(n);
                case "i":
                  return c.getInt32Array(n);
                case "l":
                  return c.getInt64Array(n);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + e);
          }
        }
      }
      class tp {
        constructor(t, e) {
          this.dv = new DataView(t), this.offset = 0, this.littleEndian = e !== void 0 ? e : true, this._textDecoder = new TextDecoder();
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(t) {
          this.offset += t;
        }
        getBoolean() {
          return (this.getUint8() & 1) === 1;
        }
        getBooleanArray(t) {
          const e = [];
          for (let i = 0; i < t; i++) e.push(this.getBoolean());
          return e;
        }
        getUint8() {
          const t = this.dv.getUint8(this.offset);
          return this.offset += 1, t;
        }
        getInt16() {
          const t = this.dv.getInt16(this.offset, this.littleEndian);
          return this.offset += 2, t;
        }
        getInt32() {
          const t = this.dv.getInt32(this.offset, this.littleEndian);
          return this.offset += 4, t;
        }
        getInt32Array(t) {
          const e = [];
          for (let i = 0; i < t; i++) e.push(this.getInt32());
          return e;
        }
        getUint32() {
          const t = this.dv.getUint32(this.offset, this.littleEndian);
          return this.offset += 4, t;
        }
        getInt64() {
          let t, e;
          return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), e & 2147483648 ? (e = ~e & 4294967295, t = ~t & 4294967295, t === 4294967295 && (e = e + 1 & 4294967295), t = t + 1 & 4294967295, -(e * 4294967296 + t)) : e * 4294967296 + t;
        }
        getInt64Array(t) {
          const e = [];
          for (let i = 0; i < t; i++) e.push(this.getInt64());
          return e;
        }
        getUint64() {
          let t, e;
          return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), e * 4294967296 + t;
        }
        getFloat32() {
          const t = this.dv.getFloat32(this.offset, this.littleEndian);
          return this.offset += 4, t;
        }
        getFloat32Array(t) {
          const e = [];
          for (let i = 0; i < t; i++) e.push(this.getFloat32());
          return e;
        }
        getFloat64() {
          const t = this.dv.getFloat64(this.offset, this.littleEndian);
          return this.offset += 8, t;
        }
        getFloat64Array(t) {
          const e = [];
          for (let i = 0; i < t; i++) e.push(this.getFloat64());
          return e;
        }
        getArrayBuffer(t) {
          const e = this.dv.buffer.slice(this.offset, this.offset + t);
          return this.offset += t, e;
        }
        getString(t) {
          const e = this.offset;
          let i = new Uint8Array(this.dv.buffer, e, t);
          this.skip(t);
          const n = i.indexOf(0);
          return n >= 0 && (i = new Uint8Array(this.dv.buffer, e, n)), this._textDecoder.decode(i);
        }
      }
      class Ag {
        add(t, e) {
          this[t] = e;
        }
      }
      function AL(s) {
        const t = "Kaydara FBX Binary  \0";
        return s.byteLength >= t.length && t === _g(s, 0, t.length);
      }
      function gL(s) {
        const t = [
          "K",
          "a",
          "y",
          "d",
          "a",
          "r",
          "a",
          "\\",
          "F",
          "B",
          "X",
          "\\",
          "B",
          "i",
          "n",
          "a",
          "r",
          "y",
          "\\",
          "\\"
        ];
        let e = 0;
        function i(n) {
          const r = s[n - 1];
          return s = s.slice(e + n), e++, r;
        }
        for (let n = 0; n < t.length; ++n) if (i(1) === t[n]) return false;
        return true;
      }
      function ep(s) {
        const t = /FBXVersion: (\d+)/, e = s.match(t);
        if (e) return parseInt(e[1]);
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
      }
      function _L(s) {
        return s / 46186158e3;
      }
      const mL = [];
      function _o(s, t, e, i) {
        let n;
        switch (i.mappingType) {
          case "ByPolygonVertex":
            n = s;
            break;
          case "ByPolygon":
            n = t;
            break;
          case "ByVertice":
            n = e;
            break;
          case "AllSame":
            n = i.indices[0];
            break;
          default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType);
        }
        i.referenceType === "IndexToDirect" && (n = i.indices[n]);
        const r = n * i.dataSize, a = r + i.dataSize;
        return bL(mL, i.buffer, r, a);
      }
      const Il = new Oe(), jr = new I();
      function gg(s) {
        const t = new ft(), e = new ft(), i = new ft(), n = new ft(), r = new ft(), a = new ft(), o = new ft(), c = new ft(), l = new ft(), h = new ft(), d = new ft(), u = new ft(), f = s.inheritType ? s.inheritType : 0;
        s.translation && t.setPosition(jr.fromArray(s.translation));
        const p = Aa(0);
        if (s.preRotation) {
          const P = s.preRotation.map(ke.degToRad);
          P.push(p), e.makeRotationFromEuler(Il.fromArray(P));
        }
        if (s.rotation) {
          const P = s.rotation.map(ke.degToRad);
          P.push(s.eulerOrder || p), i.makeRotationFromEuler(Il.fromArray(P));
        }
        if (s.postRotation) {
          const P = s.postRotation.map(ke.degToRad);
          P.push(p), n.makeRotationFromEuler(Il.fromArray(P)), n.invert();
        }
        s.scale && r.scale(jr.fromArray(s.scale)), s.scalingOffset && o.setPosition(jr.fromArray(s.scalingOffset)), s.scalingPivot && a.setPosition(jr.fromArray(s.scalingPivot)), s.rotationOffset && c.setPosition(jr.fromArray(s.rotationOffset)), s.rotationPivot && l.setPosition(jr.fromArray(s.rotationPivot)), s.parentMatrixWorld && (d.copy(s.parentMatrix), h.copy(s.parentMatrixWorld));
        const m = e.clone().multiply(i).multiply(n), g = new ft();
        g.extractRotation(h);
        const A = new ft();
        A.copyPosition(h);
        const x = A.clone().invert().multiply(h), b = g.clone().invert().multiply(x), y = r, M = new ft();
        if (f === 0) M.copy(g).multiply(m).multiply(b).multiply(y);
        else if (f === 1) M.copy(g).multiply(b).multiply(m).multiply(y);
        else {
          const G = new ft().scale(new I().setFromMatrixScale(d)).clone().invert(), H = b.clone().multiply(G);
          M.copy(g).multiply(m).multiply(H).multiply(y);
        }
        const T = l.clone().invert(), R = a.clone().invert();
        let B = t.clone().multiply(c).multiply(l).multiply(e).multiply(i).multiply(n).multiply(T).multiply(o).multiply(a).multiply(r).multiply(R);
        const S = new ft().copyPosition(B), E = h.clone().multiply(S);
        return u.copyPosition(E), B = u.clone().multiply(M), B.premultiply(h.invert()), B;
      }
      function Aa(s) {
        s = s || 0;
        const t = [
          "ZYX",
          "YZX",
          "XZY",
          "ZXY",
          "YXZ",
          "XYZ"
        ];
        return s === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[s];
      }
      function Ml(s) {
        return s.split(",").map(function(e) {
          return parseFloat(e);
        });
      }
      function _g(s, t, e) {
        return t === void 0 && (t = 0), e === void 0 && (e = s.byteLength), new TextDecoder().decode(new Uint8Array(s, t, e));
      }
      function wL(s, t) {
        for (let e = 0, i = s.length, n = t.length; e < n; e++, i++) s[i] = t[e];
      }
      function bL(s, t, e, i) {
        for (let n = e, r = 0; n < i; n++, r++) s[r] = t[n];
        return s;
      }
      class yL {
        constructor(t) {
          this._animations = t;
        }
        get animations() {
          return this._animations;
        }
      }
      class xL {
        constructor() {
          this._init();
        }
        _init() {
          this._keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            space: false,
            shift: false,
            esc: false,
            action: false,
            read: false,
            limitAreaReachedAct: false,
            limitAreaTurn: false,
            limitAreaWalk: false,
            selfieMode: false,
            thirdPersonCamera: true,
            freeCamera: false,
            actionsAllowed: true
          }, document.addEventListener("keydown", (t) => this._onKeyDown(t), false), document.addEventListener("keyup", (t) => this._onKeyUp(t), false);
        }
        _onKeyDown(t) {
          switch (t.keyCode) {
            case 87:
            case 38:
              this._keys.forward = true;
              break;
            case 65:
            case 37:
              this._keys.left = true;
              break;
            case 83:
            case 40:
              this._keys.backward = true;
              break;
            case 68:
            case 39:
              this._keys.right = true;
              break;
            case 32:
              this._keys.space = true;
              break;
            case 17:
              this._keys.ctrl = true;
              break;
            case 82:
              this._keys.read = true;
              break;
            case 16:
              this._keys.shift = true;
              break;
            case 84:
              this._keys.thirdPersonCamera = true;
              break;
            case 70:
              this._keys.action = true;
              break;
            case 89:
              this._keys.freeCamera = true;
              break;
            case 27:
              this._keys.esc = true;
              break;
          }
        }
        _onKeyUp(t) {
          switch (t.keyCode) {
            case 87:
            case 38:
              this._keys.forward = false;
              break;
            case 65:
            case 37:
              this._keys.left = false;
              break;
            case 83:
            case 40:
              this._keys.backward = false;
              break;
            case 68:
            case 39:
              this._keys.right = false;
              break;
            case 32:
              this._keys.space = false;
              break;
            case 17:
              this._keys.ctrl = false;
              break;
            case 82:
              this._keys.read = false;
              break;
            case 16:
              this._keys.shift = false;
              break;
            case 84:
              this._keys.thirdPersonCamera = false;
              break;
            case 70:
              this._keys.action = false;
              break;
            case 89:
              this._keys.freeCamera = false;
              break;
            case 27:
              this._keys.esc = false;
              break;
          }
        }
        set actionsAllowed(t = true) {
          this._keys.actionsAllowed !== t && (this._keys.actionsAllowed = t);
        }
        set limitAreaReachedAct(t) {
          this._keys.limitAreaReachedAct = t;
        }
        get keys() {
          return this._keys;
        }
      }
      class vL {
        constructor(t, e) {
          this.characterHeight = 16, this._loadingManager = e, this._initCharControl(t);
        }
        _initCharControl(t) {
          this._params = t, this._decceleration = new I(-5e-4, -1e-4, -5), this._acceleration = new I(1, 0.25, 50), this._velocity = new I(0, 0, 0), this._position = new I(), this._animations = {}, this.thirdCameraViewEnabled = t.thirdPersonCameraEnabled, this._input = new xL(), this._stateMachine = new UF(new yL(this._animations), this._input._keys), this._loadModels();
        }
        _loadModels() {
          const t = new lL(this._loadingManager);
          t.load("./models/characters/Big_Vegas.fbx", (e) => {
            e.scale.setScalar(0.1), e.traverse((c) => {
              c.castShadow = true;
            });
            const i = new cn().setFromObject(e), n = i.max.y - i.min.y;
            e.userData.height = n, this._target = e, this._params.scene.add(this._target), this._mixer = new qp(this._target);
            const r = this._loadingManager.onLoad;
            this._loadingManager.onLoad = () => {
              r && r(), this._stateMachine && this._stateMachine.setState("idle");
            };
            const a = (c, l) => {
              const h = l.animations[0], d = this._mixer.clipAction(h);
              this._animations[c] = {
                clip: h,
                action: d
              };
            }, o = pc._jumpStates;
            t.setPath("./models/animations/"), t.load("walk_fwd.fbx", (c) => {
              a("walk_fwd", c);
            }), t.load("walk_bwd.fbx", (c) => {
              a("walk_bwd", c);
            }), t.load("run_fwd.fbx", (c) => {
              a("run_fwd", c);
            }), t.load("run_bwd.fbx", (c) => {
              a("run_bwd", c);
            }), t.load("idle.fbx", (c) => {
              a("idle", c);
            }), t.load("arguing.fbx", (c) => {
              a("end_area", c);
            }), t.load("walk_fwd.fbx", (c) => {
              a("lim_area_walk_fwd", c);
            }), Th.forEach((c) => t.load(c + ".fbx", (l) => {
              a(c, l);
            })), o.forEach((c) => t.load(c + ".fbx", (l) => {
              a(c, l);
            })), Rh.forEach((c) => t.load(c + ".fbx", (l) => {
              a(c, l);
            }));
          });
        }
        updateController(t) {
          if (!this._target) return;
          if (this._input._keys.thirdPersonCamera && !this._params.cameraState.thirdPersonCameraEnabled) {
            this._params.enableThirdCameraView();
            return;
          }
          if (this._input._keys.freeCamera && this._params.cameraState.thirdPersonCameraEnabled) {
            this._params.disableThirdCameraView();
            return;
          }
          this._stateMachine.update(t, this._input);
          const e = this._params.characterRigidBody.translation();
          this._target.position.set(e.x, e.y - this.characterHeight / 2, e.z), this._position.copy(this._target.position);
          let i = this._params.characterRigidBody.rotation();
          this._target.quaternion.set(i.x, i.y, i.z, i.w), this._mixer && this._mixer.update(t);
        }
        get position() {
          return this._position;
        }
        get rotation() {
          return this._target ? this._target.quaternion : new ue();
        }
      }
      const mg = (s, t, e) => {
        s.freeCameraInstance = new EF(t, e.domElement);
      }, EL = (s, t, e) => {
        mg(s, t, e), s.thirdPersonCameraEnabled = false;
      }, SL = (s) => {
        s.freeCameraInstance._freeCamera.dispose(), s.thirdPersonCameraEnabled = true;
      }, CL = (s, t, e, i, n, r, a) => {
        const o = {
          camera: s,
          scene: t,
          cameraState: e,
          disableThirdCameraView: () => EL(e, s, a),
          enableThirdCameraView: () => SL(e),
          characterRigidBody: r.rigidBody
        }, c = new vL(o, i, n);
        e.thirdPersonCameraInstance = new SF({
          camera: s,
          target: c
        });
        const l = c._input.keys;
        return r.basicController = c, {
          controls: c,
          keys: l
        };
      }, IL = (s, t, e, i = true) => {
        const a = li.RigidBodyDesc.dynamic().setTranslation(e.x, e.y, e.z), o = s.createRigidBody(a), c = li.ColliderDesc.capsule(4, 4);
        c.setRestitution(0.1), c.setMass(500), s.createCollider(c, o);
        const l = s.createCharacterController(0.01), h = {
          rigidBody: o,
          controller: l
        }, d = new Kh(4, 4 * 2, 8, 16), u = new ci({
          color: 16711680,
          wireframe: true
        }), f = new me(d, u);
        return i && t.add(f), h.mesh = f, h;
      }, ML = (s) => {
        const e = new hi().load("./noise/perlin_noise.png");
        e.wrapS = e.wrapT = ni;
        const i = [];
        return s.children.forEach((n) => {
          n._forShadersModifiable && n.traverse((r) => {
            r.isMesh && (Array.isArray(r.material) ? r.material : [
              r.material
            ]).forEach((o) => {
              o.isMeshStandardMaterial && (o.onBeforeCompile = (c) => {
                c.uniforms.fogTime = {
                  value: 0
                }, c.uniforms.perlinNoise = {
                  value: e
                }, i.push(c);
              });
            });
          });
        }), i;
      };
      class TL {
        constructor(t) {
          this.scene = t, this.blades = null, this._initRotation(), this.speed = 0.4, this.rotationAngle = 0;
        }
        _initRotation() {
          const t = this.scene.children.find((e) => e.name === "blade");
          if (!t || t.children.length === 0) {
            console.warn("Windmill blades not found!");
            return;
          }
          this.blades = t.children[0];
        }
        updateBlades(t) {
          this.blades && (this.rotationAngle += t * this.speed, this.blades.rotation.y = this.rotationAngle);
        }
      }
      class RL {
        constructor(t) {
          this.simpleWater = null, this.isFoggy = t, this._init(), this.waterLevel = -9;
        }
        _init() {
          const e = new hi().load("./noise/perlin_noise.png");
          e.wrapS = e.wrapT = ni;
          const i = new vr(400, 1300, 10, 10), n = new ci({
            color: 1592690,
            transparent: true,
            opacity: 0.7,
            fog: true,
            metalness: 0.1,
            roughness: 0.5
          });
          n.onBeforeCompile = (r) => {
            r.uniforms.fogTime = {
              value: 0
            }, r.uniforms.perlinNoise = {
              value: e
            }, this.isFoggy || (r.vertexShader = `#define USE_FOG
      varying vec3 vWorldPosition;
      ${r.vertexShader}`), r.vertexShader = r.vertexShader.replace("#include <fog_vertex>", `vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
         #include <fog_vertex>`);
          }, this.simpleWater = new me(i, n), i.rotateX(ke.degToRad(-90)), i.translate(90, -9, 0);
        }
      }
      const zn = [
        {
          action: "Idle_A",
          probFactor: 4,
          maxDurFactor: 5,
          speed: 0,
          rotatable: false
        },
        {
          action: "Idle_B",
          probFactor: 2,
          maxDurFactor: 3,
          speed: 0,
          rotatable: false
        },
        {
          action: "Idle_C",
          probFactor: 2,
          maxDurFactor: 3,
          speed: 0,
          rotatable: false
        },
        {
          action: "Run",
          probFactor: 3,
          maxDurFactor: 4,
          speed: 7,
          rotatable: true
        },
        {
          action: "Eat",
          probFactor: 6,
          maxDurFactor: 4,
          speed: 1,
          rotatable: true
        },
        {
          action: "Fly",
          probFactor: 3,
          maxDurFactor: 2,
          speed: 8,
          rotatable: true
        },
        {
          action: "Jump",
          probFactor: 2,
          maxDurFactor: 1,
          speed: 4,
          rotatable: true
        },
        {
          action: "Roll",
          probFactor: 1,
          maxDurFactor: 3,
          speed: 5,
          rotatable: true
        },
        {
          action: "Sit",
          probFactor: 4,
          maxDurFactor: 6,
          speed: 0,
          rotatable: false
        },
        {
          action: "Walk",
          probFactor: 9,
          maxDurFactor: 5,
          speed: 4,
          rotatable: true
        }
      ];
      class BL {
        constructor() {
          this._chickStates = {}, this._chickCurState = null;
        }
        _addState(t, e) {
          this._chickStates[t] = e;
        }
        setState(t) {
          const e = this._chickCurState;
          if (e) {
            if (e.Name == t) return;
            e.exit();
          }
          const i = new this._chickStates[t](this);
          this._chickCurState = i, i.enter(e);
        }
        update(t, e) {
          this._chickCurState && this._chickCurState.update(t, e);
        }
      }
      class DL extends BL {
        constructor(t, e) {
          super(), this._proxy = t, this.chickAction = e, this._initStates();
        }
        _initStates() {
          this._addState("Idle_A", PL), this._addState("Idle_B", FL), this._addState("Idle_C", LL), this._addState("Run", kL), this._addState("Eat", NL), this._addState("Fly", UL), this._addState("Jump", QL), this._addState("Roll", OL), this._addState("Sit", zL), this._addState("Swim", GL), this._addState("Walk", HL);
        }
      }
      class nn {
        constructor(t) {
          this._parent = t;
        }
        enter() {
        }
        exit() {
        }
        update(t, e) {
          const i = Object.keys(e).find((n) => e[n]);
          i !== this.Name && this._parent.setState(i);
        }
      }
      class PL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Idle_A";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Idle_A.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class FL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Idle_B";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Idle_B.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class LL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Idle_C";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Idle_C.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class kL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Run";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Run.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class NL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Eat";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Eat.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class UL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Fly";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Fly.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class QL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Jump";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Jump.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class OL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Roll";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Roll.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class zL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Sit";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Sit.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class GL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Swim";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Swim.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play();
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class HL extends nn {
        constructor(t) {
          super(t);
        }
        get Name() {
          return "Walk";
        }
        enter(t) {
          const e = this._parent._proxy._animations.Walk.action;
          if (t) {
            const i = this._parent._proxy._animations[t.Name].action;
            e.time = 0, e.enabled = true, e.setEffectiveTimeScale(1), e.setEffectiveWeight(1), e.crossFadeFrom(i, 0.5, true), e.play();
          } else e.play(), console.log(e);
        }
        exit() {
        }
        update(t, e) {
          super.update(t, e);
        }
      }
      class VL {
        constructor(t) {
          this._animations = t;
        }
        get animations() {
          return this._animations;
        }
      }
      class WL {
        constructor() {
          this._init();
        }
        _init() {
          this._actions = {}, zn.forEach(({ action: t }) => this._actions[t] = false), this._actions.Swim = false;
        }
        get actions() {
          return this._actions;
        }
      }
      class jL {
        constructor(t, e, i, n, r, a, o, c, l, h, d) {
          __publicField(this, "frameCounter", 0);
          this._loadingManager = e, this.terrainMeshes = r, this.loader = i, this.actionDisplay = c, this.maxChickOffset = o, this.isFoggy = l, this.mainCharStatus = h, this.mainCharPosition = d, this.chickPhysics = n, this.actionDurationBase = 500, this.speed = 10, this.waterLevel = -8.5, this.maxAllowedDepthPos = -50, this.safeDistance = {
            min: 0,
            max: 30
          }, this.maxChickPosition = {
            minX: 500,
            maxX: 500,
            minZ: 500,
            maxZ: 500
          }, this.chickInitPosition = a, this.dummyTimerNumber = 1, this.turnToTimer = this.dummyTimerNumber, this.chickOutAllowedArea = false, this.nextActionNoCharTimer = null, this.charBehaviorInitiated = false, this.noCharBehaviorInitiated = false, this.isCharMoving = false, this.chickCharDistance = null, this._initChickControl(t);
        }
        _initChickControl(t) {
          this._params = t, this._decceleration = new I(-5e-4, -1e-4, -5), this._acceleration = new I(1, 0.25, 50), this._velocity = new I(0, 0, 0), this._position = new I(), this._animations = {}, this._input = new WL(), this._chickStateMachine = new DL(new VL(this._animations), this._input.actions), this.size = t.chickenSize, this._getMaxChickPosition(), this._loadModels();
        }
        _getMaxChickPosition() {
          this.maxChickPosition.maxX = this.chickInitPosition.x + this.maxChickOffset.maxX, this.maxChickPosition.minX = this.chickInitPosition.x - this.maxChickOffset.minX, this.maxChickPosition.maxZ = this.chickInitPosition.z + this.maxChickOffset.maxZ, this.maxChickPosition.minZ = this.chickInitPosition.z - this.maxChickOffset.minZ;
        }
        _createStatusLabel() {
          const t = document.createElement("canvas");
          t.width = 348, t.height = 128;
          const e = t.getContext("2d");
          e.fillStyle = "white", e.font = "100px Arial", e.fillText("Loading...", 50, 90);
          const i = new pm(t), n = new Ep({
            map: i,
            transparent: true
          });
          this.statusLabel = new nm(n), this.statusLabel.scale.set(0.5, 0.25, 1), this.statusLabel.position.set(0, 1, 0), this.model.add(this.statusLabel);
        }
        getRandom(t, e) {
          return Math.floor(Math.random() * (e - t + 1)) + t;
        }
        _resetChickPosition(t, e) {
          console.log(t);
          const { x: i, y: n, z: r } = e;
          t.rigidBody.setTranslation(new li.Vector3(i, n, r), true), t.rigidBody.setLinvel(new li.Vector3(0, 0, 0), true);
        }
        _loadModels() {
          new da(this._loadingManager).load("./models/characters/animals/chick/Chick_LOD0.glb", (e) => {
            this.model = e.scene, e.scene.scale.setScalar(this.size), this._params.scene.add(this.model);
            const n = new hi().load("./noise/perlin_noise.png");
            n.wrapS = n.wrapT = ni, e.scene.traverse((c) => {
              c.isMesh && (Array.isArray(c.material) ? c.material : [
                c.material
              ]).forEach((h, d) => {
                if (h.isMeshStandardMaterial) {
                  const u = h.clone();
                  u.fog = true, u.onBeforeCompile = (f) => {
                    f.uniforms.fogTime = {
                      value: 0
                    }, f.uniforms.perlinNoise = {
                      value: n
                    }, this.isFoggy || (f.vertexShader = `#define USE_FOG
                  varying vec3 vWorldPosition;
                  ${f.vertexShader}`), f.vertexShader = f.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
                    #ifndef CUSTOM_FOG_POSITION
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    #endif`);
                  }, Array.isArray(c.material) ? c.material[d] = u : c.material = u, u.needsUpdate = true;
                }
              });
            }), this.mixer = new qp(this.model);
            const r = this._loadingManager.onLoad;
            this.actionDisplay && (this._createStatusLabel(), this.showStatus()), this._loadingManager.onLoad = () => {
              r && r(), this._chickStateMachine && (this._chickStateMachine.setState("Idle_A"), this._input.actions.Idle_A = true);
            };
            const a = (c, l) => {
              const h = l.animations[0], d = this.mixer.clipAction(h);
              this._animations[c] = {
                clip: h,
                action: d
              };
            }, o = new da(this._loadingManager);
            o.setPath("./models/animations/chick/"), zn.forEach(({ action: c }) => o.load("Chick_" + c + ".glb", (l) => {
              a(c, l);
            })), o.load("Chick_Swim.glb", (c) => a("Swim", c));
          });
        }
        _chickSpeed(t) {
          if (!t) return 0;
          const e = this.getRandom(t - 1, t + 2);
          return e <= 0 ? 0.5 : e;
        }
        _resetActionsStatus() {
          Object.keys(this._input.actions).forEach((e) => {
            this._input.actions[e] = false;
          });
        }
        _chickBehaviorNoCharAround() {
          this.nextActionNoCharTimer && (clearTimeout(this.nextActionNoCharTimer), this.nextActionNoCharTimer = null);
          const t = (n) => {
            let r = zn.map((c, l) => [
              c,
              l
            ]).filter(([c, l]) => c.probFactor >= n);
            r.length === 0 && (r = zn.map((c, l) => [
              c,
              l
            ]));
            const a = this.getRandom(0, r.length - 1);
            return r[a][1];
          }, e = (n) => this.getRandom(0, 9) * this.actionDurationBase * zn[n].maxDurFactor, i = () => {
            const n = this.getRandom(0, zn.length - 1), r = t(n), a = e(r);
            this.speed = this._chickSpeed(zn[r].speed), this._chickStateMachine && (this._resetActionsStatus(), this._input.actions[zn[r].action] = true), this.nextActionNoCharTimer = setTimeout(i, a);
          };
          i(), setTimeout(() => {
            this.setTurnSpeed(), this.startTurnTo();
          }, 200);
        }
        _chickBehaviorCharAround(t, e) {
          const i = [
            {
              action: "Fly",
              probFactor: 3,
              maxDurFactor: 2,
              speed: 3,
              rotatable: true
            },
            {
              action: "Jump",
              probFactor: 2,
              maxDurFactor: 1,
              speed: 2,
              rotatable: true
            },
            {
              action: "Walk",
              probFactor: 2,
              maxDurFactor: 5,
              speed: 2,
              rotatable: true
            },
            {
              action: "Eat",
              probFactor: 8,
              maxDurFactor: 5,
              speed: 1,
              rotatable: true
            }
          ], n = [
            {
              action: "Run",
              probFactor: 3,
              maxDurFactor: 4,
              speed: 7,
              rotatable: true
            },
            {
              action: "Fly",
              probFactor: 3,
              maxDurFactor: 2,
              speed: 8,
              rotatable: true
            },
            {
              action: "Jump",
              probFactor: 2,
              maxDurFactor: 1,
              speed: 4,
              rotatable: true
            },
            {
              action: "Roll",
              probFactor: 1,
              maxDurFactor: 3,
              speed: 5,
              rotatable: true
            },
            {
              action: "Walk",
              probFactor: 9,
              maxDurFactor: 5,
              speed: 4,
              rotatable: true
            }
          ], r = (c, l) => {
            let h = l.map((f, p) => [
              f,
              p
            ]).filter(([f, p]) => f.probFactor >= c);
            h.length === 0 && (h = h.map((f, p) => [
              f,
              p
            ]));
            const d = this.getRandom(0, h.length - 1);
            return h[d][1];
          };
          this.nextActionNoCharTimer && (clearTimeout(this.nextActionNoCharTimer), this.nextActionNoCharTimer = null), this.turnToTimer && (clearTimeout(this.turnToTimer), this.turnToTimer = null), this.speed && (this.speed = 0);
          const a = (c, l) => this.getRandom(2, 9) * this.actionDurationBase * l[c].maxDurFactor, o = () => {
            let c = 0;
            if (this.chickCharDistance > this.safeDistance.max || this.chickCharDistance < this.safeDistance.min) {
              const l = this.getRandom(0, n.length - 1), h = r(l, n);
              c = a(h, n), this.speed = this._chickSpeed(n[h].speed), this._chickStateMachine && (this._resetActionsStatus(), this._input.actions[n[h].action] = true);
            } else {
              const l = this.getRandom(0, i.length - 1), h = r(l, i);
              c = a(h, i), this.speed = this._chickSpeed(i[h].speed), this._chickStateMachine && (this._resetActionsStatus(), this._input.actions[i[h].action] = true);
            }
            this.nextActionNoCharTimer = setTimeout(o, c);
          };
          o();
        }
        showStatus() {
          var _a3;
          const t = ((_a3 = this._chickStateMachine._chickCurState) == null ? void 0 : _a3.Name) || "Unknown", e = this.statusLabel.material.map.image, i = e.getContext("2d");
          i.clearRect(0, 0, e.width, e.height), i.fillStyle = "white", i.font = "100px Arial", i.fillText(t, 50, 90), this.statusLabel.material.map.needsUpdate = true;
        }
        setTurnSpeed(t = 0.1, e = 5) {
          this.turnSpeed = this.getRandom(t, e), setTimeout(() => this.setTurnSpeed(), this.getRandom(100, 5e3));
        }
        updateRotation(t) {
          if (this.targetRotationY === void 0) return;
          const e = this.chickPhysics.mesh.rotation.y, i = this.targetRotationY - e, n = Math.sign(i) * this.turnSpeed * t;
          Math.abs(n) >= Math.abs(i) ? (this.chickPhysics.mesh.rotation.y = this.targetRotationY, this.targetRotationY = void 0) : this.chickPhysics.mesh.rotation.y += n;
          const r = new Oe(0, this.chickPhysics.mesh.rotation.y, 0), a = new ue().setFromEuler(r);
          this.chickPhysics.rigidBody.setNextKinematicRotation(new li.Quaternion(a.x, a.y, a.z, a.w)), this.model.quaternion.copy(this.chickPhysics.mesh.quaternion);
        }
        swimHandler(t, e) {
          e <= this.waterLevel && !this._input.actions.Swim ? (this._resetActionsStatus(), this._input.actions.Swim = true) : e > this.waterLevel && this._input.actions.Swim && (this._resetActionsStatus(), this._input.actions.Walk = true);
        }
        startTurnTo() {
          this.targetRotationY = this.getRandom(-Math.PI / 4, Math.PI / 4), this.turnToTimer = setTimeout(() => this.startTurnTo(), this.getRandom(100, 3e3));
        }
        checkBoundaryAndAdjustRotation(t, e) {
          const { maxX: i, minX: n, maxZ: r, minZ: a } = this.maxChickPosition, o = 2, c = (n + i) / 2, l = (a + r) / 2, h = c - t.x, d = l - t.z, u = t.x >= i - o || t.x <= n + o || t.z >= r - o || t.z <= a + o;
          u ? (this.chickOutAllowedArea = true, this.targetRotationY = (Math.atan2(h, d) + 2 * Math.PI) % (2 * Math.PI), this.turnToTimer && (clearTimeout(this.turnToTimer), this.turnToTimer = null)) : u || (this.chickOutAllowedArea = false, this.turnToTimer || (this.turnToTimer = this.dummyTimerNumber, this.startTurnTo()));
        }
        charAreaInteractionHandler() {
          const { maxX: t, minX: e, maxZ: i, minZ: n } = this.maxChickPosition, { x: r, z: a } = this.mainCharPosition;
          return r > e && r < t && a > n && a < i;
        }
        charMovingChecker() {
          const { action: t, backward: e, ctrl: i, forward: n, left: r, right: a, space: o } = this.mainCharStatus;
          t || e || i || n || r || a || o ? this.isCharMoving = true : this.isCharMoving = false;
        }
        _charChickDistanceHandler(t, e) {
          const i = e.rigidBody.translation(), n = new I(t.x, t.y, t.z), r = new I(i.x, i.y, i.z);
          this.chickCharDistance = n.distanceTo(r);
        }
        _getAndSetAngleToChar(t, e) {
          const i = e.rigidBody.translation(), n = t.x - i.x, r = t.z - i.z;
          this.chickCharDistance > this.safeDistance.max ? this.targetRotationY = (Math.atan2(n, r) + 2 * Math.PI) % (2 * Math.PI) : this.chickCharDistance < this.safeDistance.min ? this.targetRotationY = (Math.atan2(r, n) + 2 * Math.PI) % (2 * Math.PI) : this.targetRotationY = this.getRandom(-Math.PI / 4, Math.PI / 4);
        }
        _safeDistancePositionHandler() {
          this.isCharMoving ? (this.safeDistance.max = 60, this.safeDistance.min = 30) : (this.safeDistance.max = 30, this.safeDistance.min = 0);
        }
        updateChickController(t) {
          if (this.frameCounter++, !!this.model) {
            if (this.actionDisplay && this.showStatus(), this._chickStateMachine.update(t, this._input.actions), this.chickPhysics.rigidBody && this.model) {
              const i = this.speed * 2 * t, n = this.chickPhysics.rigidBody.translation();
              this.charAreaInteractionHandler() ? this.charBehaviorInitiated || (this.noCharBehaviorInitiated = false, this.charBehaviorInitiated = true, this._chickBehaviorCharAround(this.mainCharPosition, this.chickPhysics)) : (this.checkBoundaryAndAdjustRotation(n, this.chickPhysics.mesh.rotation.y), this.noCharBehaviorInitiated || (this.noCharBehaviorInitiated = true, this.charBehaviorInitiated = false, this._chickBehaviorNoCharAround()));
              const r = new I(0, 0, 1);
              r.applyAxisAngle(new I(0, 1, 0), this.chickPhysics.mesh.rotation.y), r.normalize();
              const a = n.x + r.x * i, o = n.z + r.z * i, c = new Xp(), l = new I(a, n.y + 10, o), h = new I(0, -1, 0);
              c.set(l, h);
              let d = n.y;
              const u = c.intersectObjects([
                this.terrainMeshes
              ], true);
              u.length > 0 && (d = u[0].point.y + 0.1, d = Math.max(d, this.waterLevel - 1)), this.frameCounter % 4 === 0 && (this.charAreaInteractionHandler(), this.updateRotation(t), this.swimHandler(t, d), (n.y < this.maxAllowedDepthPos || n.x < po.minX || n.x > po.maxX || n.z < po.minZ || n.z > po.maxZ) && this._resetChickPosition(this.chickPhysics, this.chickInitPosition), this.charMovingChecker(), this.charBehaviorInitiated && (this._charChickDistanceHandler(this.mainCharPosition, this.chickPhysics), this._getAndSetAngleToChar(this.mainCharPosition, this.chickPhysics), this._safeDistancePositionHandler())), this.chickPhysics.rigidBody.setNextKinematicTranslation(new li.Vector3(a, d, o)), this.model.position.set(a, d, o), this.chickPhysics.mesh.position.set(a, d, o);
            }
            this.mixer && this.mixer.update(t);
          }
        }
      }
      const qL = (s) => {
        if (!s) throw new Error("No mesh found");
        const t = s.getObjectByName("Plane");
        if (!t) throw new Error("\u274C Terrain 'Plane' not found!");
        let e = [];
        if (t.type === "Mesh" ? e.push(t) : e = t.children.filter((a) => a.isMesh), e.length === 0) throw new Error("\u274C No meshes found inside 'Plane'!");
        const i = e.map((a) => {
          const o = a.geometry.clone().applyMatrix4(a.matrixWorld);
          return o.scale(2, 2, 2), o;
        }), n = nc(i, false);
        if (!n) throw new Error("\u274C Terrain mesh not found!");
        return new me(n, new ci({
          color: 65280
        }));
      }, XL = (s, t, e, i, n, r, a, o, c, l, h, d, u) => {
        const f = {
          scene: s,
          chickenSize: o
        }, p = KL(i, s, n, c);
        return {
          controls: new jL(f, t, e, p, a, n, r, l, h, d, u),
          chickPhysics: p
        };
      }, YL = (s, t, e, i, n, r, a, o, c, l, h, d, u, f, p) => {
        const m = [], g = qL(n);
        for (let A = 0; A < o; A++) {
          const x = Math.max(0.1, a - 2 + Math.floor(Math.random() * 3));
          m.push(XL(s, t, e, i, r, d, g, x, c, l, h, f, p));
        }
        return m;
      }, KL = (s, t, e, i = true) => {
        const r = Math.random() * 2 * Math.PI, a = new ue().setFromAxisAngle(new I(0, 1, 0), r), o = li.RigidBodyDesc.kinematicPositionBased().setTranslation(e.x, e.y, e.z).setRotation(a.x, a.y, a.z, a.w), l = {
          rigidBody: s.createRigidBody(o)
        }, h = new Zh(2), d = new ci({
          color: 16711680,
          wireframe: i
        }), u = new me(h, d);
        return i && t.add(u), l.mesh = u, l;
      };
      class JL {
        constructor(t) {
          __publicField(this, "_addGrass", async (t) => {
            await pv(), this.grassField = new _v(t), this.grassField.createParticles(), this.scene.add(this.grassField);
          });
          __publicField(this, "_physicsFrameSkip", 2);
          __publicField(this, "_frameCount", 0);
          __publicField(this, "_previousFrame", null);
          __publicField(this, "_fixedTimeStep", 1 / 60);
          this.initSettings = t, this.shaders = [], this.initSettings.stats && (this.stats = new WP()), this.helpMenu = this.initHelpMenu(), this.LoadingManager = new mF(this.helpMenu).getManager(), this.GLTFLoader = new da(this.LoadingManager), this.terrain = null, this.cameraState = {
            thirdPersonCameraEnabled: false,
            freeCameraInstance: null,
            thirdPersonCameraInstance: null
          }, this._previousFrame = null, this.grassField = null, this.RAPIER = li, this._eventQueue = new this.RAPIER.EventQueue(true), this.movement = new this.RAPIER.Vector3(0, 0, 0), this.worldPhysics = new this.RAPIER.World(Al), this.simpleObjects = [], this.keys = {}, this.markersDistanceHandler = null, this._init();
        }
        async _init() {
          this.scene = new xo(), this.camera = new Ve(75, window.innerWidth / window.innerHeight, 1, 1e3), this.camera.position.set(-30, 50, 70), this.renderer = new eA({
            antialias: true
          }), this.renderer.shadowMap.enabled = true, this.renderer.shadowMap.type = np, this.renderer.setSize(window.innerWidth, window.innerHeight), document.body.appendChild(this.renderer.domElement), new _F(this.initSettings.fog, this.scene).addSkyBox(), this.initLighting(), mg(this.cameraState, this.camera, this.renderer), this.riverCurveMesh = this.createRiverCurveMesh(), this.groundMeshToScene = true, this.terrain = await UP(this.GLTFLoader, this.scene, this.groundMeshToScene), await this._loadStructures(), this.initSettings.blades && this._windMillBlades(), this.shaders = ML(this.scene), vF(this.worldPhysics, this.terrain), this.initSettings.grass && this._addGrass(this.terrain), this.initSettings.fog && this.addExpImprovedFog(14674419, 6e-4), this.character = IL(this.worldPhysics, this.scene, Ao, false), this._loadAnimatedModel(), this.loadPlayerAreaLimiter(), this.initSettings.chicks && this._loadAnimatedChicks(), this.audio = this._initAudio(), this.setInteractions(), this.setVegetation(), this.initSettings.water ? this._addWater() : this._addSimpleWater(), this.setCollidersManually(rg), this.animate();
        }
        _loadAnimatedChicks() {
          const n = this.controls._input._keys, r = this.character.mesh.position, c = YL(this.scene, this.LoadingManager, da, this.worldPhysics, this.terrain, yP, 4, 10, false, false, this.initSettings.fog, xP, false, n, r);
          this.chicks = c;
        }
        _windMillBlades() {
          this.windMill = new TL(this.scene);
        }
        loadPlayerAreaLimiter() {
          this.playerAreaLimiter = new bF(gl, this.character);
        }
        _loadAnimatedModel() {
          const { controls: t, keys: e } = CL(this.camera, this.scene, this.cameraState, this.LoadingManager, this.GLTFLoader, this.character, this.renderer);
          this.controls = t, this.keys = e;
        }
        initHelpMenu() {
          return new wF(this.initSettings.sounds, this.initSettings.music);
        }
        _initAudio() {
          return new uF(this.initSettings, this.riverCurveMesh, this.camera, this.keys, this.controls._stateMachine, fF, this.scene, this.initSettings.music, this.initSettings.sounds, this.helpMenu, this.chicks);
        }
        setInteractions() {
          this.markersDistanceHandler = new YP(this.character), this.chapterViewer = new dF(this.markersDistanceHandler, this.audio, this.LoadingManager), this.modalMarkers = new XP(this.markersDistanceHandler), this.modalChapter = new KP(this.markersDistanceHandler, this.chapterViewer, this.audio);
        }
        setCollidersManually(t) {
          new qP(this.worldPhysics).createColliders(t);
        }
        initLighting() {
          const t = new id(16777215, 0.25);
          this.dirLight = new AP();
          const e = new Mw(this.dirLight.dirLight, 5);
          e.visible = false, this.scene.add(e), this.scene.add(t), this.scene.add(this.dirLight.dirLight), this.scene.add(this.dirLight.dirLight.target);
        }
        setVegetation() {
          this.vegetation || (this.vegetation = new QP(this.scene, this.renderer, this.LoadingManager, this.terrain, this.worldPhysics, this.shaders)), this.vegetation.preloadModels(() => {
            this.vegetation.setVegetation();
          });
        }
        addExpImprovedFog(t, e) {
          this._fogController = new _P(this.terrain, this.shaders), this._fogController.fogHuck(), this.scene.fog = new Vh(t, e);
        }
        createRiverCurveMesh() {
          return new pF(this.scene);
        }
        _addWater() {
          new gP(this.scene, this.initSettings.fog);
        }
        _addSimpleWater() {
          const t = new RL(this.initSettings.fog);
          this.scene.add(t.simpleWater);
        }
        async _loadStructures() {
          await ks(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/bridges_c.glb", this.scene), await ks(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/signs_c.glb", this.scene), await ks(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/structures_no_wind_blade_c.glb", this.scene), await ks(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/wind_mill_blade_c.glb", this.scene, {
            x: -147.7,
            y: 77.4,
            z: 398
          }, {
            x: 8,
            y: 8,
            z: 8
          }, {
            x: pa(90),
            y: 0,
            z: pa(215)
          }, name = "blade");
        }
        _createPlaneGround(t = 100, e = 0.1, i = 100) {
          console.log("Ground Created");
          const n = this.RAPIER.RigidBodyDesc.fixed(), r = this.worldPhysics.createRigidBody(n), a = this.RAPIER.ColliderDesc.cuboid(t, e, i);
          this.worldPhysics.createCollider(a, r);
        }
        _updateCharacterMovement(t) {
          if (!this.character) return;
          const e = this.keys.shift ? 36 : 18, i = 60, n = -100, r = e * t * i;
          this._acceleration = new I(0.25, 0.5, 0.25), this._deceleration = new I(-0.5, -1e-4, -0.5), this._rotationSpeed = 4 * Math.PI * t * this._acceleration.y, this._rotationAxis = new I(0, 1, 0), this.rotation = new ue();
          const a = Math.exp(this._deceleration.x * t * i);
          !this.keys.forward && !this.keys.backward && (this.movement.x *= a, this.movement.z *= a), (this.keys.left && this.keys.actionsAllowed || this.keys.right && this.keys.actionsAllowed) && (this.rotation.setFromAxisAngle(this._rotationAxis, this.keys.left ? this._rotationSpeed : -this._rotationSpeed), this.character.mesh.quaternion.multiply(this.rotation));
          let o = new I(0, 0, 1);
          o.applyQuaternion(this.character.mesh.quaternion), o.normalize(), this.keys.backward && this.keys.actionsAllowed && (this.movement.x += (-o.x * r - this.movement.x) * this._acceleration.x, this.movement.z += (-o.z * r - this.movement.z) * this._acceleration.z), this.keys.forward && this.keys.actionsAllowed && (this.movement.x += (o.x * r - this.movement.x) * this._acceleration.x, this.movement.z += (o.z * r - this.movement.z) * this._acceleration.z);
          let c = this.character.rigidBody.linvel();
          c.y += Al.y * t, this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(this.movement.x, c.y, this.movement.z), true);
          let l = this.character.rigidBody.translation();
          l.y < n && (this.character.rigidBody.setTranslation(new this.RAPIER.Vector3(Ao.x, Ao.y, Ao.z), true), this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(0, 0, 0), true)), this.character.mesh.position.set(l.x, l.y, l.z);
          const h = this.character.mesh.quaternion;
          this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(h.x, h.y, h.z, h.w), true);
        }
        _updateCharacterMesh() {
          if (!this.character) return;
          const t = this.character.rigidBody.translation();
          this.character.mesh.position.set(t.x, t.y, t.z);
        }
        _updateLimitedAreaMovement(t) {
          const e = () => {
            const n = this.character.mesh, r = new I();
            n.getWorldPosition(r);
            const a = new I(0, r.y, 0), o = new I().subVectors(a, r).normalize(), c = new ue().setFromUnitVectors(new I(0, 0, 1), o);
            n.quaternion.slerp(c, this._rotationSpeed), this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(n.quaternion.x, n.quaternion.y, n.quaternion.z, n.quaternion.w), true), n.quaternion.angleTo(c) < 0.01 && (this.keys.limitAreaTurn = false);
          }, i = () => {
            const a = 20 * t * 60, o = 30;
            let c = new I(0, 0, 1);
            c.applyQuaternion(this.character.mesh.quaternion), c.normalize(), this.movement.x += (c.x * a - this.movement.x) * this._acceleration.x, this.movement.z += (c.z * a - this.movement.z) * this._acceleration.z;
            let l = this.character.rigidBody.linvel();
            l.y += Al.y * t, this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(this.movement.x, l.y, this.movement.z), true);
            let h = this.character.rigidBody.translation();
            this.character.mesh.position.set(h.x, h.y, h.z);
            const d = this.character.mesh.quaternion;
            this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(d.x, d.y, d.z, d.w), true), Math.abs(h.x) < gl.maxX - o && Math.abs(h.z) < gl.maxZ - o && (this.keys.limitAreaWalk = false, this.keys.limitAreaReachedAct = false, this.keys.actionsAllowed = true);
          };
          this.keys.limitAreaTurn && e(), i();
        }
        animate(t = 0) {
          requestAnimationFrame(this.animate.bind(this)), this.stats && this.stats.stats.begin(), this._previousFrame === null && (this._previousFrame = t);
          const e = (t - this._previousFrame) * 1e-3;
          this._previousFrame = t, this._fogController && this._fogController.fogStep(t), this.grassField && this.grassField.update(t), this.renderer.render(this.scene, this.camera), this.step(e), this._frameCount % this._physicsFrameSkip === 0 && (this.keys.limitAreaWalk || this.keys.limitAreaTurn ? this._updateLimitedAreaMovement(e) : this._updateCharacterMovement(e), this.windMill && this.windMill.updateBlades(e), this.playerAreaLimiter && this.playerAreaLimiter.update(), this.markersDistanceHandler && (this.markersDistanceHandler.updateCharPositionDistance(), this.modalMarkers.updateMarkerModalStatus()), this.controls && this.dirLight && this.dirLight.updateDirLightPosition(this.controls.position), this.worldPhysics.step(this._eventQueue, this._fixedTimeStep), this.audio && this.audio.updateSoundsState(), this.simpleObjects.forEach((i) => {
            const n = i.rigidBody.translation();
            i.mesh.position.set(n.x, n.y, n.z);
          })), this._frameCount++, this.stats && this.stats.stats.end();
        }
        step(t) {
          if (this.controls && this.controls.updateController(t), this.chicks && this.chicks.length) for (let e = 0; e < this.chicks.length; e++) this.chicks[e].controls.updateChickController(t);
          this.cameraState.thirdPersonCameraEnabled && this.cameraState.thirdPersonCameraInstance._update(t);
        }
      }
      class ZL {
        constructor(t) {
          this._config = document.getElementById("config"), this._features = document.querySelector(".c-main__features"), this._lowPCBtn = document.querySelector(".c-main__lowPC-button"), this._startBtn = document.querySelector(".c-footer__start-btn"), this.settings = {
            fog: false,
            water: false,
            grass: false,
            sounds: false,
            music: false,
            stats: false,
            blades: false,
            chicks: false
          }, this.Game = t, this._init();
        }
        _init() {
          this._startBtn.addEventListener("click", (t) => {
            this._getSettings(), this._config.classList.add("config-hide"), this.Game && new this.Game(this.settings);
          }), this._lowPCBtn.addEventListener("click", (t) => {
            t.target.classList.toggle("config-active"), t.target.classList.contains("config-active") ? this._setCheckBoxes(false) : this._setCheckBoxes(true);
          });
        }
        _getSettings() {
          Array.from(this._features.children).forEach((t) => {
            const e = t.children[0];
            this.settings[e.value] = e.checked;
          });
        }
        _setCheckBoxes(t) {
          Array.from(this._features.children).forEach((e) => {
            const i = e.children[0];
            i.checked = t;
          });
        }
      }
      new ZL(JL);
    })();
  }
});
export default require_stdin();
